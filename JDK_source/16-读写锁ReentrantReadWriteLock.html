<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.62" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://blog.guosgbin.cn/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html"><meta property="og:title" content="16-读写锁ReentrantReadWriteLock"><meta property="og:description" content="版本 内容 时间 ---- ---- ---------------------- V1 新建 2022年09月29日23:50:27 概述 ReentrantReadWriteLock 顾名思义就是一个可重入的读写锁，内部也是基于 AQS 的。 读写锁的写锁和读锁都可以重入；; 读写锁的读锁和写锁都支持公平模式和非公平模式；; 互斥; 当一个线程获取..."><meta property="og:type" content="article"><meta property="og:image" content="https://blog.guosgbin.cn/"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-05-04T02:26:04.000Z"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="16-读写锁ReentrantReadWriteLock"><meta property="article:author" content="超威蓝猫 Dylan Kwok"><meta property="article:modified_time" content="2023-05-04T02:26:04.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"16-读写锁ReentrantReadWriteLock","image":["https://blog.guosgbin.cn/"],"dateModified":"2023-05-04T02:26:04.000Z","author":[{"@type":"Person","name":"超威蓝猫 Dylan Kwok","url":"","email":"guosgbin@163.com"}]}</script><link rel="icon" href="/小熊猫.svg"><title>16-读写锁ReentrantReadWriteLock</title><meta name="description" content="版本 内容 时间 ---- ---- ---------------------- V1 新建 2022年09月29日23:50:27 概述 ReentrantReadWriteLock 顾名思义就是一个可重入的读写锁，内部也是基于 AQS 的。 读写锁的写锁和读锁都可以重入；; 读写锁的读锁和写锁都支持公平模式和非公平模式；; 互斥; 当一个线程获取...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-542658da.css" as="style"><link rel="stylesheet" href="/assets/style-542658da.css">
    <link rel="modulepreload" href="/assets/app-1d017c6a.js"><link rel="modulepreload" href="/assets/16-读写锁ReentrantReadWriteLock.html-de44a1d3.js"><link rel="modulepreload" href="/assets/16-读写锁ReentrantReadWriteLock.html-1b57c2cc.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-c27b6911.js"><link rel="prefetch" href="/assets/index.html-18305222.js" as="script"><link rel="prefetch" href="/assets/01-创建和销毁对象.html-98280ce1.js" as="script"><link rel="prefetch" href="/assets/index.html-c4f42206.js" as="script"><link rel="prefetch" href="/assets/01-CAS和Unsafe的API分析.html-612c4d6a.js" as="script"><link rel="prefetch" href="/assets/02-基本类型原子类AtomicLong.html-4083b8fd.js" as="script"><link rel="prefetch" href="/assets/03-引用类型原子类AtomicReference.html-8442553d.js" as="script"><link rel="prefetch" href="/assets/04-原子数组类AtomicLongArray.html-74e4c741.js" as="script"><link rel="prefetch" href="/assets/05-原子操作类AtomicReferenceFieldUpdater.html-d0310b2a.js" as="script"><link rel="prefetch" href="/assets/06-高性能原子类LongAdder.html-d6e3da8b.js" as="script"><link rel="prefetch" href="/assets/07-LockSupport分析.html-8117dd17.js" as="script"><link rel="prefetch" href="/assets/08-AQS简单介绍.html-30b6ef5b.js" as="script"><link rel="prefetch" href="/assets/09-基于ReentrantLock分析AQS的独占模式.html-2423c430.js" as="script"><link rel="prefetch" href="/assets/10-基于CountDownLatch分析AQS的共享模式.html-91ef4833.js" as="script"><link rel="prefetch" href="/assets/11-AQS的Condition机制.html-836364af.js" as="script"><link rel="prefetch" href="/assets/12-信号量Semaphore.html-3509682c.js" as="script"><link rel="prefetch" href="/assets/13-循环栏栅CyclicBarrier.html-812d137d.js" as="script"><link rel="prefetch" href="/assets/14-阶段Phaser.html-d684f4a1.js" as="script"><link rel="prefetch" href="/assets/15-交换Exchanger.html-b9bf24f3.js" as="script"><link rel="prefetch" href="/assets/17-Future模式-FutureTask.html-641c6250.js" as="script"><link rel="prefetch" href="/assets/18-线程池体系概述.html-dbcc52e5.js" as="script"><link rel="prefetch" href="/assets/19-线程池体系-AbstractExecutorService.html-fbd70afb.js" as="script"><link rel="prefetch" href="/assets/20-线程池体系-ThreadPoolExecutor.html-a274637a.js" as="script"><link rel="prefetch" href="/assets/21-线程池体系-ScheduledThreadPoolExecutor.html-707ffd40.js" as="script"><link rel="prefetch" href="/assets/22-CopyOnWriteArrayList写时复制.html-914977b9.js" as="script"><link rel="prefetch" href="/assets/23-CopyOnWriteArraySet写时复制.html-6c9c3cf6.js" as="script"><link rel="prefetch" href="/assets/24-ConcurrentSkipListMap跳表.html-6cff54bf.js" as="script"><link rel="prefetch" href="/assets/25-ConcurrentSkipListSet跳表.html-36cf4f7d.js" as="script"><link rel="prefetch" href="/assets/26-ConcurrentHashMap源码分析.html-a3bba8a9.js" as="script"><link rel="prefetch" href="/assets/27-阻塞队列ArrayBlockingQueue.html-cd091357.js" as="script"><link rel="prefetch" href="/assets/28-阻塞队列LinkedBlockingQueue.html-d3579ee7.js" as="script"><link rel="prefetch" href="/assets/29-阻塞队列LinkedBlockingDeque.html-32c13680.js" as="script"><link rel="prefetch" href="/assets/30-阻塞队列PriorityBlockingQueue.html-b5455c77.js" as="script"><link rel="prefetch" href="/assets/31-阻塞队列DelayQueue.html-7759c195.js" as="script"><link rel="prefetch" href="/assets/32-阻塞队列SynchronousQueue.html-97ed879a.js" as="script"><link rel="prefetch" href="/assets/33-阻塞队列LinkedTransferQueue.html-3281c1b4.js" as="script"><link rel="prefetch" href="/assets/index.html-f5239cf3.js" as="script"><link rel="prefetch" href="/assets/SPI机制.html-a1ca3921.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis01：myabtis的整体架构.html-f25c0705.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis02：入门案例.html-30e68cd3.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis03：解析全局配置文件.html-2db85266.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis04：解析Mapper映射文件.html-60756a5b.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis05：解析Statement操作节点.html-31e11b60.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis06：解析SQL语句.html-a9181b56.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis07：Java方法和SQL语句绑定.html-9bfa3db6.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis08：获得SqlSession.html-e2a92940.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis09：Executor执行器.html-ad701715.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis10：缓存机制.html-f2daa10c.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis11：StatementHandler.html-95b30d9b.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis12：参数解析和赋值.html-5778c0ea.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis13：结果集处理.html-2ff72779.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis14：插件.html-76cc6bf8.js" as="script"><link rel="prefetch" href="/assets/01-服务端启动流程.html-d2fc1f19.js" as="script"><link rel="prefetch" href="/assets/02-服务端启动添加ChannelInitializer到管道.html-86cb5d6a.js" as="script"><link rel="prefetch" href="/assets/03-客户端启动流程.html-becc83be.js" as="script"><link rel="prefetch" href="/assets/04-线程体系-NioEventLoopGroup.html-700e797e.js" as="script"><link rel="prefetch" href="/assets/05-线程体系-NioEventLoop相关父接口分析.html-754320bc.js" as="script"><link rel="prefetch" href="/assets/06-线程体系-AbstractEventExecutor.html-5250cd42.js" as="script"><link rel="prefetch" href="/assets/07-线程体系-AbstractScheduledEventExecutor-优先队列.html-e7bbaf32.js" as="script"><link rel="prefetch" href="/assets/08-线程体系-NioEventLoop概述.html-fce3fb2c.js" as="script"><link rel="prefetch" href="/assets/09-线程体系-NioEventLoop开启Selector及优化.html-6d8230cf.js" as="script"><link rel="prefetch" href="/assets/10-线程体系-NioEventLoop绑定线程.html-db947821.js" as="script"><link rel="prefetch" href="/assets/11-线程体系-NioEventLoop的run方法.html-def4cc31.js" as="script"><link rel="prefetch" href="/assets/12-线程体系-NioEventLoop规避JDK的NIO空循环bug.html-16ecaf4e.js" as="script"><link rel="prefetch" href="/assets/13-线程体系-NioEventLoop的优雅关闭.html-912d668d.js" as="script"><link rel="prefetch" href="/assets/14-服务端处理客户端的连接(ACCEPT).html-63afdec1.js" as="script"><link rel="prefetch" href="/assets/15-客户端处理READ事件概述.html-b35daeb8.js" as="script"><link rel="prefetch" href="/assets/16-客户端处理READ事件详解及RecvByteBufAllocator.html-a9faccfa.js" as="script"><link rel="prefetch" href="/assets/17-Netty管道机制.html-ba70b238.js" as="script"><link rel="prefetch" href="/assets/18-Netty发送数据流程及出站缓冲区.html-223d04a7.js" as="script"><link rel="prefetch" href="/assets/index.html-b475d8b0.js" as="script"><link rel="prefetch" href="/assets/Redis_Benchmark基准测试.html-dbf21951.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群和槽管理命令.html-2b4a1244.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群基本特性和集群搭建.html-42be726b.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群管理工具redis-cli.html-fc4f1503.js" as="script"><link rel="prefetch" href="/assets/Redis_Pipeline优化RTT.html-8a4aa041.js" as="script"><link rel="prefetch" href="/assets/Redis_Sentinel高可用.html-6bcdb34a.js" as="script"><link rel="prefetch" href="/assets/Redis_key设计规范.html-ab90a7dc.js" as="script"><link rel="prefetch" href="/assets/Redis事务.html-e43061e1.js" as="script"><link rel="prefetch" href="/assets/Redis内存淘汰策略.html-feabd314.js" as="script"><link rel="prefetch" href="/assets/Redis发布订阅.html-68771977.js" as="script"><link rel="prefetch" href="/assets/Redis复制.html-33b20d6f.js" as="script"><link rel="prefetch" href="/assets/Redis大key和热key问题.html-394d194e.js" as="script"><link rel="prefetch" href="/assets/Redis慢查询日志.html-7fb06db0.js" as="script"><link rel="prefetch" href="/assets/Redis持久化机制.html-53af3f7a.js" as="script"><link rel="prefetch" href="/assets/Redis键空间通知(keyspace notification).html-012bd277.js" as="script"><link rel="prefetch" href="/assets/redis-cli 使用.html-f7ab22db.js" as="script"><link rel="prefetch" href="/assets/01-RocketMQ概述.html-25463efe.js" as="script"><link rel="prefetch" href="/assets/02-NameServer启动流程.html-a514999f.js" as="script"><link rel="prefetch" href="/assets/03-Broker启动流程.html-43c84806.js" as="script"><link rel="prefetch" href="/assets/04-RocketMQ网络通信原理.html-ac88de8d.js" as="script"><link rel="prefetch" href="/assets/05-RocketMQ 服务端和客户端的启动.html-ef7f1888.js" as="script"><link rel="prefetch" href="/assets/06-RocketMQ网络通信源码.html-b8e0bf43.js" as="script"><link rel="prefetch" href="/assets/07-NameServer作用和路由元信息.html-82a23869.js" as="script"><link rel="prefetch" href="/assets/08-NameServer路由管理源码分析.html-8da2bd72.js" as="script"><link rel="prefetch" href="/assets/09-生产者相关类分析.html-08f6e840.js" as="script"><link rel="prefetch" href="/assets/10-生产者启动流程.html-d761cf07.js" as="script"><link rel="prefetch" href="/assets/11-生产者发送消息.html-743328bc.js" as="script"><link rel="prefetch" href="/assets/12-Broker存储机制概述.html-5e7ed491.js" as="script"><link rel="prefetch" href="/assets/13-MappedFile和MappedFileQueue分析.html-5b9afaf2.js" as="script"><link rel="prefetch" href="/assets/14-CommitLog原理分析.html-93362aa2.js" as="script"><link rel="prefetch" href="/assets/15-broker的刷盘机制.html-21e2029f.js" as="script"><link rel="prefetch" href="/assets/16-ConsumeQueue和Index原理分析.html-ff18bade.js" as="script"><link rel="prefetch" href="/assets/17-broker过期文件删除机制.html-89f05919.js" as="script"><link rel="prefetch" href="/assets/18-消费者启动流程(TODO).html-988c43b3.js" as="script"><link rel="prefetch" href="/assets/19-消息拉取入口和消息队列负载均衡.html-7e4e20d4.js" as="script"><link rel="prefetch" href="/assets/20-消费者发送消息拉取请求流程.html-19825069.js" as="script"><link rel="prefetch" href="/assets/21-broker处理消息拉取请求-1-主流程.html-d9ca6fa4.js" as="script"><link rel="prefetch" href="/assets/22-broker处理消息拉取请求-2-长轮询.html-0aba4f38.js" as="script"><link rel="prefetch" href="/assets/23-broker处理消息拉取请求-3-读取消息.html-729d741b.js" as="script"><link rel="prefetch" href="/assets/24-消费者处理从broker拉取的消息.html-dcfb7d07.js" as="script"><link rel="prefetch" href="/assets/25-并发消费原理.html-5ef206ec.js" as="script"><link rel="prefetch" href="/assets/JUC相关问题.html-9dc4b717.js" as="script"><link rel="prefetch" href="/assets/JVM问题.html-17300c49.js" as="script"><link rel="prefetch" href="/assets/MySQL相关问题.html-a6c2cd41.js" as="script"><link rel="prefetch" href="/assets/index.html-8f5e683a.js" as="script"><link rel="prefetch" href="/assets/Redis相关问题.html-575f1ee1.js" as="script"><link rel="prefetch" href="/assets/HowToSayResume.html-11d8bbca.js" as="script"><link rel="prefetch" href="/assets/resume.html-3b3f8934.js" as="script"><link rel="prefetch" href="/assets/404.html-f3795607.js" as="script"><link rel="prefetch" href="/assets/index.html-1f3390c0.js" as="script"><link rel="prefetch" href="/assets/index.html-10b45510.js" as="script"><link rel="prefetch" href="/assets/index.html-dfd17ea5.js" as="script"><link rel="prefetch" href="/assets/index.html-2f392b9e.js" as="script"><link rel="prefetch" href="/assets/index.html-0efbdc5e.js" as="script"><link rel="prefetch" href="/assets/index.html-18831b3e.js" as="script"><link rel="prefetch" href="/assets/01-创建和销毁对象.html-43164fed.js" as="script"><link rel="prefetch" href="/assets/index.html-adc814cb.js" as="script"><link rel="prefetch" href="/assets/01-CAS和Unsafe的API分析.html-45feaf41.js" as="script"><link rel="prefetch" href="/assets/02-基本类型原子类AtomicLong.html-de030f23.js" as="script"><link rel="prefetch" href="/assets/03-引用类型原子类AtomicReference.html-b38e323a.js" as="script"><link rel="prefetch" href="/assets/04-原子数组类AtomicLongArray.html-0f328922.js" as="script"><link rel="prefetch" href="/assets/05-原子操作类AtomicReferenceFieldUpdater.html-a9190047.js" as="script"><link rel="prefetch" href="/assets/06-高性能原子类LongAdder.html-8331d452.js" as="script"><link rel="prefetch" href="/assets/07-LockSupport分析.html-53f2b50e.js" as="script"><link rel="prefetch" href="/assets/08-AQS简单介绍.html-48d01b98.js" as="script"><link rel="prefetch" href="/assets/09-基于ReentrantLock分析AQS的独占模式.html-3c777ce2.js" as="script"><link rel="prefetch" href="/assets/10-基于CountDownLatch分析AQS的共享模式.html-004b280a.js" as="script"><link rel="prefetch" href="/assets/11-AQS的Condition机制.html-6e524f67.js" as="script"><link rel="prefetch" href="/assets/12-信号量Semaphore.html-169654ba.js" as="script"><link rel="prefetch" href="/assets/13-循环栏栅CyclicBarrier.html-369b44a6.js" as="script"><link rel="prefetch" href="/assets/14-阶段Phaser.html-8b393887.js" as="script"><link rel="prefetch" href="/assets/15-交换Exchanger.html-565c0074.js" as="script"><link rel="prefetch" href="/assets/17-Future模式-FutureTask.html-1df365c4.js" as="script"><link rel="prefetch" href="/assets/18-线程池体系概述.html-e38d3ae2.js" as="script"><link rel="prefetch" href="/assets/19-线程池体系-AbstractExecutorService.html-650b9391.js" as="script"><link rel="prefetch" href="/assets/20-线程池体系-ThreadPoolExecutor.html-292775c2.js" as="script"><link rel="prefetch" href="/assets/21-线程池体系-ScheduledThreadPoolExecutor.html-8a4d175c.js" as="script"><link rel="prefetch" href="/assets/22-CopyOnWriteArrayList写时复制.html-5427c921.js" as="script"><link rel="prefetch" href="/assets/23-CopyOnWriteArraySet写时复制.html-cf71326e.js" as="script"><link rel="prefetch" href="/assets/24-ConcurrentSkipListMap跳表.html-39f38749.js" as="script"><link rel="prefetch" href="/assets/25-ConcurrentSkipListSet跳表.html-14c2553c.js" as="script"><link rel="prefetch" href="/assets/26-ConcurrentHashMap源码分析.html-390426d8.js" as="script"><link rel="prefetch" href="/assets/27-阻塞队列ArrayBlockingQueue.html-26c59958.js" as="script"><link rel="prefetch" href="/assets/28-阻塞队列LinkedBlockingQueue.html-290e2eb4.js" as="script"><link rel="prefetch" href="/assets/29-阻塞队列LinkedBlockingDeque.html-a9558dbb.js" as="script"><link rel="prefetch" href="/assets/30-阻塞队列PriorityBlockingQueue.html-47cd1298.js" as="script"><link rel="prefetch" href="/assets/31-阻塞队列DelayQueue.html-b74ec518.js" as="script"><link rel="prefetch" href="/assets/32-阻塞队列SynchronousQueue.html-db2e8b0f.js" as="script"><link rel="prefetch" href="/assets/33-阻塞队列LinkedTransferQueue.html-977cc8db.js" as="script"><link rel="prefetch" href="/assets/index.html-f9d1ece6.js" as="script"><link rel="prefetch" href="/assets/SPI机制.html-81c12657.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis01：myabtis的整体架构.html-50c92355.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis02：入门案例.html-0df73e0c.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis03：解析全局配置文件.html-ebc079a5.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis04：解析Mapper映射文件.html-f9d36faf.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis05：解析Statement操作节点.html-8b137a09.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis06：解析SQL语句.html-69361b10.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis07：Java方法和SQL语句绑定.html-f03839b2.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis08：获得SqlSession.html-aba45a9c.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis09：Executor执行器.html-ebca3789.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis10：缓存机制.html-466f0ba2.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis11：StatementHandler.html-f36cc3a1.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis12：参数解析和赋值.html-93c78139.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis13：结果集处理.html-de090303.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis14：插件.html-d07fbe32.js" as="script"><link rel="prefetch" href="/assets/01-服务端启动流程.html-ce68eb5e.js" as="script"><link rel="prefetch" href="/assets/02-服务端启动添加ChannelInitializer到管道.html-eccd931b.js" as="script"><link rel="prefetch" href="/assets/03-客户端启动流程.html-7f6bdaf4.js" as="script"><link rel="prefetch" href="/assets/04-线程体系-NioEventLoopGroup.html-f679e402.js" as="script"><link rel="prefetch" href="/assets/05-线程体系-NioEventLoop相关父接口分析.html-dce56b5e.js" as="script"><link rel="prefetch" href="/assets/06-线程体系-AbstractEventExecutor.html-f2fa658f.js" as="script"><link rel="prefetch" href="/assets/07-线程体系-AbstractScheduledEventExecutor-优先队列.html-311c4386.js" as="script"><link rel="prefetch" href="/assets/08-线程体系-NioEventLoop概述.html-09952cf6.js" as="script"><link rel="prefetch" href="/assets/09-线程体系-NioEventLoop开启Selector及优化.html-c764b19e.js" as="script"><link rel="prefetch" href="/assets/10-线程体系-NioEventLoop绑定线程.html-2bf69f6f.js" as="script"><link rel="prefetch" href="/assets/11-线程体系-NioEventLoop的run方法.html-999b539a.js" as="script"><link rel="prefetch" href="/assets/12-线程体系-NioEventLoop规避JDK的NIO空循环bug.html-4b0e0b2b.js" as="script"><link rel="prefetch" href="/assets/13-线程体系-NioEventLoop的优雅关闭.html-735ac232.js" as="script"><link rel="prefetch" href="/assets/14-服务端处理客户端的连接(ACCEPT).html-29281de3.js" as="script"><link rel="prefetch" href="/assets/15-客户端处理READ事件概述.html-7bfca68a.js" as="script"><link rel="prefetch" href="/assets/16-客户端处理READ事件详解及RecvByteBufAllocator.html-3fb7feb4.js" as="script"><link rel="prefetch" href="/assets/17-Netty管道机制.html-aa076e2c.js" as="script"><link rel="prefetch" href="/assets/18-Netty发送数据流程及出站缓冲区.html-fcf48e74.js" as="script"><link rel="prefetch" href="/assets/index.html-be900ba4.js" as="script"><link rel="prefetch" href="/assets/Redis_Benchmark基准测试.html-1e0eff39.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群和槽管理命令.html-32208a0e.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群基本特性和集群搭建.html-bedb7197.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群管理工具redis-cli.html-f902caf0.js" as="script"><link rel="prefetch" href="/assets/Redis_Pipeline优化RTT.html-52099eb8.js" as="script"><link rel="prefetch" href="/assets/Redis_Sentinel高可用.html-158393a9.js" as="script"><link rel="prefetch" href="/assets/Redis_key设计规范.html-2bf6bb1c.js" as="script"><link rel="prefetch" href="/assets/Redis事务.html-309bf455.js" as="script"><link rel="prefetch" href="/assets/Redis内存淘汰策略.html-2371e9c6.js" as="script"><link rel="prefetch" href="/assets/Redis发布订阅.html-73b9f85e.js" as="script"><link rel="prefetch" href="/assets/Redis复制.html-a75ba246.js" as="script"><link rel="prefetch" href="/assets/Redis大key和热key问题.html-f74620b3.js" as="script"><link rel="prefetch" href="/assets/Redis慢查询日志.html-9a18c87e.js" as="script"><link rel="prefetch" href="/assets/Redis持久化机制.html-ffdd97dd.js" as="script"><link rel="prefetch" href="/assets/Redis键空间通知(keyspace notification).html-8c62b947.js" as="script"><link rel="prefetch" href="/assets/redis-cli 使用.html-52613e85.js" as="script"><link rel="prefetch" href="/assets/01-RocketMQ概述.html-34b3490d.js" as="script"><link rel="prefetch" href="/assets/02-NameServer启动流程.html-0fb6f2e3.js" as="script"><link rel="prefetch" href="/assets/03-Broker启动流程.html-aadaa061.js" as="script"><link rel="prefetch" href="/assets/04-RocketMQ网络通信原理.html-76d78cd6.js" as="script"><link rel="prefetch" href="/assets/05-RocketMQ 服务端和客户端的启动.html-7e5bc8a5.js" as="script"><link rel="prefetch" href="/assets/06-RocketMQ网络通信源码.html-2b6a156a.js" as="script"><link rel="prefetch" href="/assets/07-NameServer作用和路由元信息.html-e3acf093.js" as="script"><link rel="prefetch" href="/assets/08-NameServer路由管理源码分析.html-ca0658db.js" as="script"><link rel="prefetch" href="/assets/09-生产者相关类分析.html-09119ff1.js" as="script"><link rel="prefetch" href="/assets/10-生产者启动流程.html-7f41a97b.js" as="script"><link rel="prefetch" href="/assets/11-生产者发送消息.html-f9d0683e.js" as="script"><link rel="prefetch" href="/assets/12-Broker存储机制概述.html-0e6a3cd5.js" as="script"><link rel="prefetch" href="/assets/13-MappedFile和MappedFileQueue分析.html-94add6cd.js" as="script"><link rel="prefetch" href="/assets/14-CommitLog原理分析.html-7bbd65e8.js" as="script"><link rel="prefetch" href="/assets/15-broker的刷盘机制.html-da884406.js" as="script"><link rel="prefetch" href="/assets/16-ConsumeQueue和Index原理分析.html-19444331.js" as="script"><link rel="prefetch" href="/assets/17-broker过期文件删除机制.html-f0459970.js" as="script"><link rel="prefetch" href="/assets/18-消费者启动流程(TODO).html-cad00e4f.js" as="script"><link rel="prefetch" href="/assets/19-消息拉取入口和消息队列负载均衡.html-6426df1f.js" as="script"><link rel="prefetch" href="/assets/20-消费者发送消息拉取请求流程.html-883a91a0.js" as="script"><link rel="prefetch" href="/assets/21-broker处理消息拉取请求-1-主流程.html-fa4d17a0.js" as="script"><link rel="prefetch" href="/assets/22-broker处理消息拉取请求-2-长轮询.html-fb37af81.js" as="script"><link rel="prefetch" href="/assets/23-broker处理消息拉取请求-3-读取消息.html-9bf6438d.js" as="script"><link rel="prefetch" href="/assets/24-消费者处理从broker拉取的消息.html-e4cc92bf.js" as="script"><link rel="prefetch" href="/assets/25-并发消费原理.html-4abc7857.js" as="script"><link rel="prefetch" href="/assets/JUC相关问题.html-8792fb2a.js" as="script"><link rel="prefetch" href="/assets/JVM问题.html-b446a1a0.js" as="script"><link rel="prefetch" href="/assets/MySQL相关问题.html-ce7306db.js" as="script"><link rel="prefetch" href="/assets/index.html-d5baa442.js" as="script"><link rel="prefetch" href="/assets/Redis相关问题.html-3ef4ab44.js" as="script"><link rel="prefetch" href="/assets/HowToSayResume.html-cca4cb2a.js" as="script"><link rel="prefetch" href="/assets/resume.html-3a011de6.js" as="script"><link rel="prefetch" href="/assets/404.html-7c551c51.js" as="script"><link rel="prefetch" href="/assets/index.html-387030a5.js" as="script"><link rel="prefetch" href="/assets/index.html-56fdf909.js" as="script"><link rel="prefetch" href="/assets/index.html-4185aa04.js" as="script"><link rel="prefetch" href="/assets/index.html-839dd3bb.js" as="script"><link rel="prefetch" href="/assets/index.html-072ed91d.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-2450701e.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a href="/" class="vp-brand"><img class="vp-nav-logo" src="/小熊猫.png" alt><!----><!----></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><!----><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><!----><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><!--[--><a href="/JDK_source/" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="JUC包源码分析"><!---->JUC包源码分析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/01-CAS%E5%92%8CUnsafe%E7%9A%84API%E5%88%86%E6%9E%90.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="01-CAS和Unsafe的API分析"><!---->01-CAS和Unsafe的API分析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/02-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicLong.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="02-基本类型原子类AtomicLong"><!---->02-基本类型原子类AtomicLong<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/03-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicReference.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="03-引用类型原子类AtomicReference"><!---->03-引用类型原子类AtomicReference<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/04-%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84%E7%B1%BBAtomicLongArray.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="04-原子数组类AtomicLongArray"><!---->04-原子数组类AtomicLongArray<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/05-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BBAtomicReferenceFieldUpdater.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="05-原子操作类AtomicReferenceFieldUpdater"><!---->05-原子操作类AtomicReferenceFieldUpdater<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/06-%E9%AB%98%E6%80%A7%E8%83%BD%E5%8E%9F%E5%AD%90%E7%B1%BBLongAdder.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="06-高性能原子类LongAdder"><!---->06-高性能原子类LongAdder<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/07-LockSupport%E5%88%86%E6%9E%90.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="07-LockSupport分析"><!---->07-LockSupport分析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/08-AQS%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="08-AQS简单介绍"><!---->08-AQS简单介绍<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/09-%E5%9F%BA%E4%BA%8EReentrantLock%E5%88%86%E6%9E%90AQS%E7%9A%84%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="09-基于ReentrantLock分析AQS的独占模式"><!---->09-基于ReentrantLock分析AQS的独占模式<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/10-%E5%9F%BA%E4%BA%8ECountDownLatch%E5%88%86%E6%9E%90AQS%E7%9A%84%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="10-基于CountDownLatch分析AQS的共享模式"><!---->10-基于CountDownLatch分析AQS的共享模式<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="11-AQS的Condition机制"><!---->11-AQS的Condition机制<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/12-%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="12-信号量Semaphore"><!---->12-信号量Semaphore<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/13-%E5%BE%AA%E7%8E%AF%E6%A0%8F%E6%A0%85CyclicBarrier.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="13-循环栏栅CyclicBarrier"><!---->13-循环栏栅CyclicBarrier<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/14-%E9%98%B6%E6%AE%B5Phaser.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="14-阶段Phaser"><!---->14-阶段Phaser<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/15-%E4%BA%A4%E6%8D%A2Exchanger.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="15-交换Exchanger"><!---->15-交换Exchanger<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html" class="router-link-active router-link-exact-active nav-link active vp-sidebar-link vp-sidebar-page active" aria-label="16-读写锁ReentrantReadWriteLock"><!---->16-读写锁ReentrantReadWriteLock<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#概述" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="概述"><!---->概述<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#案例" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="案例"><!---->案例<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#案例-1" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="案例 1"><!---->案例 1<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#案例-2" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="案例 2"><!---->案例 2<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#继承关系" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="继承关系"><!---->继承关系<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#读写锁的原理" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="读写锁的原理"><!---->读写锁的原理<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#构造方法" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="构造方法"><!---->构造方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#内部类-sync" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="内部类 Sync"><!---->内部类 Sync<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#获取写锁" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="获取写锁"><!---->获取写锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#释放写锁" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="释放写锁"><!---->释放写锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#获取读锁" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="获取读锁"><!---->获取读锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#释放读锁" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="释放读锁"><!---->释放读锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#读写锁的特点" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="读写锁的特点"><!---->读写锁的特点<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#读锁与写锁的互斥关系" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="读锁与写锁的互斥关系"><!---->读锁与写锁的互斥关系<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#可重入性" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="可重入性"><!---->可重入性<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#锁的升降级" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="锁的升降级"><!---->锁的升降级<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#公平模式和非公平模式" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="公平模式和非公平模式"><!---->公平模式和非公平模式<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#小结" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="小结"><!---->小结<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/JDK_source/17-Future%E6%A8%A1%E5%BC%8F-FutureTask.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="17-Future模式-FutureTask"><!---->17-Future模式-FutureTask<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/18-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB%E6%A6%82%E8%BF%B0.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="18-线程池体系概述"><!---->18-线程池体系概述<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/19-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-AbstractExecutorService.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="19-线程池体系-AbstractExecutorService"><!---->19-线程池体系-AbstractExecutorService<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="20-线程池体系-ThreadPoolExecutor"><!---->20-线程池体系-ThreadPoolExecutor<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/21-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ScheduledThreadPoolExecutor.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="21-线程池体系-ScheduledThreadPoolExecutor"><!---->21-线程池体系-ScheduledThreadPoolExecutor<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/22-CopyOnWriteArrayList%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="22-CopyOnWriteArrayList写时复制"><!---->22-CopyOnWriteArrayList写时复制<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/23-CopyOnWriteArraySet%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="23-CopyOnWriteArraySet写时复制"><!---->23-CopyOnWriteArraySet写时复制<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/24-ConcurrentSkipListMap%E8%B7%B3%E8%A1%A8.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="24-ConcurrentSkipListMap跳表"><!---->24-ConcurrentSkipListMap跳表<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/25-ConcurrentSkipListSet%E8%B7%B3%E8%A1%A8.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="25-ConcurrentSkipListSet跳表"><!---->25-ConcurrentSkipListSet跳表<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="26-ConcurrentHashMap源码分析"><!---->26-ConcurrentHashMap源码分析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/27-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97ArrayBlockingQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="27-阻塞队列ArrayBlockingQueue"><!---->27-阻塞队列ArrayBlockingQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/28-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97LinkedBlockingQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="28-阻塞队列LinkedBlockingQueue"><!---->28-阻塞队列LinkedBlockingQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/29-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97LinkedBlockingDeque.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="29-阻塞队列LinkedBlockingDeque"><!---->29-阻塞队列LinkedBlockingDeque<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/30-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97PriorityBlockingQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="30-阻塞队列PriorityBlockingQueue"><!---->30-阻塞队列PriorityBlockingQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/31-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97DelayQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="31-阻塞队列DelayQueue"><!---->31-阻塞队列DelayQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/32-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97SynchronousQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="32-阻塞队列SynchronousQueue"><!---->32-阻塞队列SynchronousQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/33-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97LinkedTransferQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="33-阻塞队列LinkedTransferQueue"><!---->33-阻塞队列LinkedTransferQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->16-读写锁ReentrantReadWriteLock</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="page-author-item">超威蓝猫 Dylan Kwok</span></span><span property="author" content="超威蓝猫 Dylan Kwok"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-05-04T02:26:04.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 21 分钟</span><meta property="timeRequired" content="PT21M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#概述" class="router-link-active router-link-exact-active toc-link level2">概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#案例" class="router-link-active router-link-exact-active toc-link level2">案例</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#案例-1" class="router-link-active router-link-exact-active toc-link level3">案例 1</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#案例-2" class="router-link-active router-link-exact-active toc-link level3">案例 2</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#继承关系" class="router-link-active router-link-exact-active toc-link level2">继承关系</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#读写锁的原理" class="router-link-active router-link-exact-active toc-link level2">读写锁的原理</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#构造方法" class="router-link-active router-link-exact-active toc-link level3">构造方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#内部类-sync" class="router-link-active router-link-exact-active toc-link level3">内部类 Sync</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#获取写锁" class="router-link-active router-link-exact-active toc-link level3">获取写锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#释放写锁" class="router-link-active router-link-exact-active toc-link level3">释放写锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#获取读锁" class="router-link-active router-link-exact-active toc-link level3">获取读锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#释放读锁" class="router-link-active router-link-exact-active toc-link level3">释放读锁</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#读写锁的特点" class="router-link-active router-link-exact-active toc-link level2">读写锁的特点</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#读锁与写锁的互斥关系" class="router-link-active router-link-exact-active toc-link level3">读锁与写锁的互斥关系</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#可重入性" class="router-link-active router-link-exact-active toc-link level3">可重入性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#锁的升降级" class="router-link-active router-link-exact-active toc-link level3">锁的升降级</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#公平模式和非公平模式" class="router-link-active router-link-exact-active toc-link level3">公平模式和非公平模式</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html#小结" class="router-link-active router-link-exact-active toc-link level2">小结</a></li><!----><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><table><thead><tr><th>版本</th><th>内容</th><th>时间</th></tr></thead><tbody><tr><td>V1</td><td>新建</td><td>2022年09月29日23:50:27</td></tr></tbody></table><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>ReentrantReadWriteLock 顾名思义就是一个可重入的读写锁，内部也是基于 AQS 的。</p><ul><li>读写锁的写锁和读锁都<strong>可以重入</strong>；</li><li>读写锁的读锁和写锁都<strong>支持公平模式和非公平模式</strong>；</li><li>互斥 <ul><li>当一个线程获取了写锁，其他线程无法获取写锁（独占锁）；</li><li>当一个线程获取了读锁，所有线程都无法获取写锁；</li></ul></li><li>支持锁降级：<strong>写锁可以降级为读锁，读锁不能升级为写锁</strong>； <ul><li>锁降级，就是先获取写锁，然后获取读锁，最后释放写锁，这样写锁就降级成了读锁。</li></ul></li></ul><h2 id="案例" tabindex="-1"><a class="header-anchor" href="#案例" aria-hidden="true">#</a> 案例</h2><p>JDK 中提供了两个案例</p><h3 id="案例-1" tabindex="-1"><a class="header-anchor" href="#案例-1" aria-hidden="true">#</a> 案例 1</h3><p>展示了如何在更新缓存后执行<strong>锁降级</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">CachedData</span> <span class="token punctuation">{</span>
    <span class="token comment">// 保存的数据</span>
    <span class="token class-name">Object</span> data<span class="token punctuation">;</span>
    <span class="token comment">// 缓存数据是否有效的标志</span>
    <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> cacheValid<span class="token punctuation">;</span>
    <span class="token comment">// 读写锁对象</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantReadWriteLock</span> rwl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token doc-comment comment">/**
     * 处理缓存数据
     */</span>
    <span class="token keyword">void</span> <span class="token function">processCachedData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取读锁</span>
        rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 校验缓存是否有效</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cacheValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// Must release read lock before acquiring write lock</span>
            <span class="token comment">// 释放读锁，尝试获取写锁</span>
            rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            rwl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// Recheck state because another thread might have</span>
                <span class="token comment">// acquired write lock and changed state before we did.</span>
                <span class="token comment">// 双重检查，再次检查缓存的状态</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cacheValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    data <span class="token operator">=</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    cacheValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// Downgrade by acquiring read lock before releasing write lock</span>
                <span class="token comment">// 再次获取读锁</span>
                rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                rwl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Unlock write, still hold read</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token function">useDate</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;模拟获取数据...&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">useDate</span><span class="token punctuation">(</span><span class="token class-name">Object</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="案例-2" tabindex="-1"><a class="header-anchor" href="#案例-2" aria-hidden="true">#</a> 案例 2</h3><p>ReentrantReadWriteLocks 可用于<strong>改善某些类型集合的某些使用中的并发性</strong>。</p><p>只有当集合预期很大，读线程比写线程访问的多，并且需要的操作开销超过同步开销时，这通常才是值得的。</p><p>下面的案例使用 ReentrantReadWriteLock 控制对 TreeMap 的访问，将 TreeMap 封装成一个线程安全的集合。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">RWDictionary</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 封装的 map</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 读写锁对象</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantReadWriteLock</span> rwl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> r <span class="token operator">=</span> rwl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> w <span class="token operator">=</span> rwl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        r<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            r<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">allKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        r<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            r<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            m<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="继承关系" tabindex="-1"><a class="header-anchor" href="#继承关系" aria-hidden="true">#</a> 继承关系</h2><p><img src="/assets/19-ReentrantReadWriteLock的继承关系-e6a7d6c9.png" alt="19-ReentrantReadWriteLock的继承关系"></p><p>读写锁的接口</p><p>ReentrantReadWriteLock 实现了 ReadWriteLock 接口，该接口就两个获取读锁和写锁的方法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ReadWriteLock</span> <span class="token punctuation">{</span>
    <span class="token class-name">Lock</span> <span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Lock</span> <span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ReentrantReadWriteLock 里面有以下几个内部类：</p><ul><li>Sync：抽象类，继承 AbstractQueuedSynchronizer，这个类主要就是实现 AQS 的模板方法； <ul><li>HoldCounter 类：<strong>记录当前线程的读锁重入的次数</strong>；</li><li>ThreadLocalHoldCounter 类：<strong>就是一个 ThreadLocal，用于保存 HoldCounter 对象</strong>；</li></ul></li><li>NonfairSync：继承自 Sync，是 Sync 的非公平实现；</li><li>FairSync：继承自 Sync，是 Sync 的公平实现；</li><li>ReadLock：读锁实现；</li><li>WriteLock：写锁实现；</li></ul><p>后面会依次分析这些内部类的作用。</p><h2 id="读写锁的原理" tabindex="-1"><a class="header-anchor" href="#读写锁的原理" aria-hidden="true">#</a> 读写锁的原理</h2><h3 id="构造方法" tabindex="-1"><a class="header-anchor" href="#构造方法" aria-hidden="true">#</a> 构造方法</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 默认非公平锁</span>
<span class="token keyword">public</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    readerLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReadLock</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    writerLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WriteLock</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ReentrantReadWriteLock <strong>默认非公平锁</strong>，在构造方法中就是创建了 Sync 类、读锁对象和写锁对象。</p><h3 id="内部类-sync" tabindex="-1"><a class="header-anchor" href="#内部类-sync" aria-hidden="true">#</a> 内部类 Sync</h3><p>在看 Sync 内部类之前思考一下，ReentrantLock 的 AQS 的同步资源 state 表示独占锁的重入次数。</p><p>ReentrantReadWriteLock 有读锁和写锁，那么怎么用一个 int 表示这两个锁的数据呢？在 JUC 中有很多是根据位来分割不同的数据的，这里也是一样。</p><p><strong>ReentrantReadWriteLock 的同步资源 state 是 int 类型</strong>，它的</p><ul><li><strong>高 16 位表示共享锁的计数；</strong></li><li><strong>低 16 位表示独占锁的计数；</strong></li></ul><p>这里只分析 Sync 类的一些属性，具体方法在调用处分析。</p><h4 id="sync-的常量" tabindex="-1"><a class="header-anchor" href="#sync-的常量" aria-hidden="true">#</a> Sync 的常量</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">6317671515068378041L</span><span class="token punctuation">;</span>

    <span class="token comment">/*
     * Read vs write count extraction constants and functions.
     * Lock state is logically divided into two unsigned shorts:
     * The lower one representing the exclusive (writer) lock hold count,
     * and the upper the shared (reader) hold count.
     */</span>

    <span class="token comment">// 低位表示独占锁定保持计数</span>
    <span class="token comment">// 高位表示共享保持计数</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SHARED_SHIFT</span>   <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>
    <span class="token comment">// 1 00000000 00000000</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SHARED_UNIT</span>    <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">SHARED_SHIFT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 11111111 11111111</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_COUNT</span>      <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">SHARED_SHIFT</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 初始值 11111111 11111111</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">EXCLUSIVE_MASK</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">SHARED_SHIFT</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token doc-comment comment">/** Returns the number of shared holds represented in count  */</span>
    <span class="token comment">// 获取共享的个数，int 32 位，右移 16 位则得到高位值</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sharedCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&gt;&gt;&gt;</span> <span class="token constant">SHARED_SHIFT</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token doc-comment comment">/** Returns the number of exclusive holds represented in count  */</span>
    <span class="token comment">// 获取独占的个数，int 32 位，&amp; 上 EXCLUSIVE_MASK 则得到地位值</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token constant">EXCLUSIVE_MASK</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token comment">// 省略......</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析上面常量的作用</p><ul><li><strong>SHARED_SHIFT</strong>：用于计算当前读锁和写锁的个数，将 AQS 的同步资源 state 分为两部分；</li><li><strong>SHARED_UNIT</strong>：因为高 16 代表读锁的计数，将读锁加 1 需要在 state 上加 SHARED_UNIT 的值；</li><li><strong>MAX_COUNT</strong>：读锁或者写锁的最大持有个数；</li><li><strong>EXCLUSIVE_MASK</strong>：用于获得写锁的个数的掩码，低 16 位都是 1；</li></ul><p>下面两个方法就是用于获取共享锁的个数和独占锁的个数。</p><h4 id="线程读锁计数" tabindex="-1"><a class="header-anchor" href="#线程读锁计数" aria-hidden="true">#</a> 线程读锁计数</h4><p>在 Sync 中有两个内部类 HoldCounter 和 ThreadLocalHoldCounter。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HoldCounter</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当前线程重入读锁的次数</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// Use id, not reference, to avoid garbage retention</span>
    <span class="token comment">// 获取线程 id</span>
    <span class="token keyword">final</span> <span class="token keyword">long</span> tid <span class="token operator">=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// THreadLocal 保存 HoldCounter</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalHoldCounter</span>
    <span class="token keyword">extends</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HoldCounter</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">HoldCounter</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HoldCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 当前线程持有的可重入读锁数。</span>
<span class="token comment">// 每个线程保存 一个 HoldCounter 对象</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">ThreadLocalHoldCounter</span> readHolds<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>HoldCounter 用于记录每个线程的读锁的重入次数，这个对象保存在 ThreadLocal 中</strong>。</p><h4 id="最近获取读锁线程缓存" tabindex="-1"><a class="header-anchor" href="#最近获取读锁线程缓存" aria-hidden="true">#</a> 最近获取读锁线程缓存</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HoldCounter</span> cachedHoldCounter<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在 Sync 中还有一个 HoldCounter 变量</p><p><strong>关于 cachedHoldCounter 的作用</strong>，一般获取和释放读锁的线程都是最后一个线程，虽然每个线程的重入次数都会使用 readHolds 这个 ThreadLocal 来保存，但是假如每次获取读锁重入次数都要去 ThreadLocal 里面去查的话，就比较费时。这是就可以用 cachedHoldCounter 保存最后一个线程的读锁重入次数，这样就可以较少很多查询了，直接拿这个缓存用即可，这算是一个优化吧，<strong>空间换时间</strong>。</p><h4 id="记录首个获取读锁的线程" tabindex="-1"><a class="header-anchor" href="#记录首个获取读锁的线程" aria-hidden="true">#</a> 记录首个获取读锁的线程</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 第一个获取读锁的线程</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Thread</span> firstReader <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// firstReaderHoldCount 是 firstReader 的计数（持有的读锁数）</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> firstReaderHoldCount<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="获取写锁" tabindex="-1"><a class="header-anchor" href="#获取写锁" aria-hidden="true">#</a> 获取写锁</h3><p>内部类 WriteLock 实现了 Lock 接口，本次分析它的 WriteLock#lock 方法，其他支持中断的那些方法的流程基本类似。</p><div class="language-s line-numbers-mode" data-ext="s"><pre class="language-s"><code>public void lock() {
    sync.acquire(1);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接调的 AQS 的方法，AbstractQueuedSynchronizer#acquire</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 独占地获取资源，忽略中断</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// tryAcquire 方法尝试获取资源，获取成功返回 true</span>
    <span class="token comment">// 获取资源失败返回 false，则需要将当前线程包装成节点加入等待队列</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">EXCLUSIVE</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法之前分析 AQS 的时候分析过，大致的思路就是先尝试获取锁，获取失败就将当前线程封装成节点加入到等待队列中阻塞等待被唤醒。</p><p>那么此次重点分析读写锁类重写的 tryAcquire 方法，Sync#tryAcquire</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 尝试获取写锁
 */</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
     * Walkthrough:
     * 1. If read count nonzero or write count nonzero
     *    and owner is a different thread, fail.
     * 2. If count would saturate, fail. (This can only
     *    happen if count is already nonzero.)
     * 3. Otherwise, this thread is eligible for lock if
     *    it is either a reentrant acquire or
     *    queue policy allows it. If so, update state
     *    and set owner.
     */</span>
    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 同步状态</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取独占锁的次数</span>
    <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// c != 0 说明读锁和写锁至少有一个</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> current <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment">// 如果有线程持有读锁，或写锁被获取但不是当前线程获取的，则获取失败</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">+</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token constant">MAX_COUNT</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// Reentrant acquire</span>
        <span class="token comment">// 锁重入，直接 set 是因为只有当前线程能重入</span>
        <span class="token function">setState</span><span class="token punctuation">(</span>c <span class="token operator">+</span> acquires<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 走到这里的前置条件 c == 0，说明既没有读锁也没有写锁</span>

    <span class="token comment">// 条件 1 根据是否是公平锁做不同的判断</span>
    <span class="token comment">// 条件 2 就是尝试抢锁了</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 抢锁成功，设置独占线程</span>
    <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>读锁和写锁的互斥关系</p><ul><li><strong>读锁和写锁是互斥的</strong>：只要有线程持有读锁，所有线程都不能获取写锁；</li><li><strong>写锁和写锁是互斥的</strong>：写锁被其他线程占用时，当前线程不能获取写锁；</li></ul><p>当前线程持有读锁时，当前线程不能获取写锁，也就是说<strong>读锁无法升级成写锁</strong>的；</p><p><strong>获取写锁小结：</strong></p><ol><li>调用 Sync#tryAcquire 方法尝试获取写锁，获取写锁成功则直接结束方法，未获取成功走后面的代码；</li><li>将当前线程封装成一个 Node 节点并加入到 AQS 的等待队列中；</li><li>假如当前是等待队列的 head.next 节点则尝试获取锁，不是这个节点或者获取失败则阻塞等待前驱节点唤醒；</li></ol><h3 id="释放写锁" tabindex="-1"><a class="header-anchor" href="#释放写锁" aria-hidden="true">#</a> 释放写锁</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>释放写锁是直接调用的 AbstractQueuedSynchronizer#release 方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 释放独占资源</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 尝试释放独占资源</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token comment">// h.waitStatus != 0 说明等待队列中有线程在排队</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token comment">// 通过 head 节点唤醒队首节点</span>
            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法之前分析过，这里主要分析读写锁重写的 tryRelease 方法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 释放写锁
 */</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> nextc <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>free<span class="token punctuation">)</span>
        <span class="token comment">// 如果释放锁之后锁空闲，那么需要将锁持有者置为null</span>
        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> free<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>很简单，就是直接将 state 的写锁计数减 1。</p><p>释放写锁小结：</p><ol><li>调用 AbstractQueuedSynchronizer#release 方法尝试释放读锁，将 state 的写锁计数减 1；</li><li>唤醒 AQS 的等待队列的 head.next 节点（如果存在的话），该节点就可以继续尝试获取写锁了；</li></ol><h3 id="获取读锁" tabindex="-1"><a class="header-anchor" href="#获取读锁" aria-hidden="true">#</a> 获取读锁</h3><p>ReadLock#lock</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync<span class="token punctuation">.</span><span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也是直接调用 AQS 的方法，AbstractQueuedSynchronizer#acquireShared</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 共享地获取资源</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">doAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法之前分析过，这里我们需要分析读写锁重写的 tryAcquireShared 方法。</p><p>Sync#tryAcquireShared</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> current<span class="token punctuation">)</span>
        <span class="token comment">// 有线程使用了独占锁，且不是当前线程，那么直接返回失败</span>
        <span class="token comment">// 这里也说明了获取写锁的线程还是有机会获取读锁的</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">sharedCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">readerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>     <span class="token comment">// 先进行公平性判断是否应该让步，这可能会导致重入读锁的线程获取失败</span>
        r <span class="token operator">&lt;</span> <span class="token constant">MAX_COUNT</span> <span class="token operator">&amp;&amp;</span>    <span class="token comment">// r &lt; MAX_COUNT 判断读锁是否到上限</span>
        <span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> <span class="token constant">SHARED_UNIT</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// CAS失败会进入下面的完全获取读锁的方法</span>

        <span class="token comment">// 到这里获取共享锁成功，且写锁计数已经增加</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 第一个获取读锁的线程的处理</span>
            firstReader <span class="token operator">=</span> current<span class="token punctuation">;</span>
            firstReaderHoldCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 将第一个获取读锁的线程的计数 +1</span>
            firstReaderHoldCount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 该线程不是首个获取读锁的线程，需要记录到 readHolds 中</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 获取最近获取读锁的 HoldCounter 缓存</span>
            <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>
            <span class="token comment">// 判断这个 HoldCounter 缓存是不是属于当前线程的</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment">// 到这里说明 rh 是 null，或者 rh 的线程 id 不是当前线程</span>
                <span class="token comment">// 获取当前线程的 HoldCounter 值放到 cachedHoldCounter 中，也就是目前来说的最后一个线程获取读锁的线程</span>
                cachedHoldCounter <span class="token operator">=</span> rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 前置条件：cachedHoldC ounter 是属于当前线程的</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                readHolds<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 读锁次数加 1</span>
            rh<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 只要进了这个 if 代码块就返回 1 表示成功</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 前置条件：readerShouldBlock() 返回的 true，或者读锁计数超过最大值了，或者 cas 更改读锁计数失败了</span>
    <span class="token comment">// 前面 if 代码块并未处理读锁锁重入</span>
    <span class="token keyword">return</span> <span class="token function">fullTryAcquireShared</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于这个 Sync#tryAcquireShared 方法，这个方法的返回值</p><ol><li>返回 1 表示获取读锁成功；</li><li>返回 -1 表示获取读锁失败，那么会在 AbstractQueuedSynchronizer#acquireShared 将当前节点封装成读模式的节点并添加到 AQS 的等待队列中；</li></ol><p>Sync#tryAcquireShared 简单分析：</p><ol><li>首先会校验一下锁的状态，假如有线程持有了写锁，且不是当前线程，那么会直接返回 -1 表示获取读锁失败；</li><li>然后会走一个 if 判断，据当前读写锁的公平模式来决定是否尝试阻塞当前线程，判断读锁计数是否溢出，CAS 更新 state 是否成功； <ol><li>假如通过校验，说明 readerShouldBlock() 返回 false 且 CAS 更新成功了，此时会处理增加读锁重入计数，处理 cachedHoldCounter 等。走到这里面肯定是获取读锁成功了，直接返回 1；</li><li>假如没有通过校验，可能的情况是 readerShouldBlock() 返回 true，或者 CAS 更新 state 失败，此时需要调用 ReentrantReadWriteLock.Sync#fullTryAcquireShared 方法去获取读锁；</li></ol></li></ol><p>Sync#tryAcquireShared 的前半部分并没有处理读锁重入和 CAS 更新 state 失败的情况，所有需要调用 ReentrantReadWriteLock.Sync#fullTryAcquireShared 去处理这里个场景。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">fullTryAcquireShared</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// exclusiveCount(c) != 0 说明有线程已经获取了写锁了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> current<span class="token punctuation">)</span>
                <span class="token comment">// 持有写锁的线程不是当前线程，返回 -1 表示获取读锁失败</span>
                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token comment">// else we hold the exclusive lock; blocking here</span>
            <span class="token comment">// would cause deadlock.</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 前置条件：exclusiveCount(c) == 0 说明当前是没有线程持有写锁的</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">readerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 这个分支是在处理读锁重入的情况</span>
            <span class="token comment">// Make sure we&#39;re not acquiring read lock reentrantly</span>
            <span class="token comment">// 如果当前线程就是firstReader，那么它一定是重入读，不让它失败，</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// assert firstReaderHoldCount &gt; 0;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 获取最近一次获取读锁的线程信息</span>
                    rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>
                    <span class="token comment">// 条件成立说明，rh 没有 或者 rh 里存的线程不是当前线程</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">// 赋值当前线程的 HoldCounter</span>
                        rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token comment">// 条件成立：说明当前线程的 readHolds 是上一行代码 rh = readHolds.get() 创建的，</span>
                        <span class="token comment">// 可以推断出来，当前线程不是锁重入的情况</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                            <span class="token comment">// 说明当前线程没有持有读锁，直接移除当前线程的 HoldCounter</span>
                            readHolds<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    <span class="token comment">// 条件成立：说明当前线程的 readHolds 是上一行代码 rh = readHolds.get() 创建的，</span>
                    <span class="token comment">// 可以推断出来，当前线程不是锁重入的情况</span>
                    <span class="token comment">// 当前线程既不持有读锁（不是重入读），并且被公平性判断为应该阻塞，那么就获取失败</span>
                    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sharedCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">MAX_COUNT</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 那些情况会进入到下面的代码呢？</span>
        <span class="token comment">// 1.无线程占用写锁，当前线程 CAS 修改 state 失败，，然后进入到 fullTryAcquireShared 方法（没有抢过其他读锁线程）</span>
        <span class="token comment">// 2.持有读锁的线程进行读锁重入</span>

        <span class="token comment">// 下面的逻辑基本上和 tryAcquire 中差不多，不过这里的 CAS 如果失败，会重新 loop 直到成功为止</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> <span class="token constant">SHARED_UNIT</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sharedCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                firstReader <span class="token operator">=</span> current<span class="token punctuation">;</span>
                firstReaderHoldCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                firstReaderHoldCount<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    readHolds<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span>
                rh<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
                cachedHoldCounter <span class="token operator">=</span> rh<span class="token punctuation">;</span> <span class="token comment">// cache for release</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于读锁的重入处理，假如上面的 readerShouldBlock() 返回 true，这个条件说明需要将当前的线程阻塞，<strong>需要进一步判断是否是已经获取读锁的线程的读锁重入</strong>，假如不是读锁重入，这里会返回 -1 表示需要将当前线程封装节点添加到等待队列中阻塞等待；</p><h3 id="释放读锁" tabindex="-1"><a class="header-anchor" href="#释放读锁" aria-hidden="true">#</a> 释放读锁</h3><p>ReadLock#unlock</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接调用的 AQS 的 AbstractQueuedSynchronizer#releaseShared 方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 释放共享资源</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// tryReleaseShared 返回true 表示已经释放完了</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们需要看读写锁重写的 tryReleaseShared 方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 尝试释放读锁
 */</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// assert firstReaderHoldCount &gt; 0;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReaderHoldCount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
            firstReader <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            firstReaderHoldCount<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 一般释放读锁的都是最后获取读锁的那个线程</span>
        <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>
            rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> rh<span class="token punctuation">.</span>count<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果释放读锁后不再持有锁，那么移除 readHolds 保存的线程局部 HoldCounter 变量</span>
            readHolds<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token function">unmatchedUnlockException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token operator">--</span>rh<span class="token punctuation">.</span>count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 循环 CAS 保证修改同步资源 state 成功</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">-</span> <span class="token constant">SHARED_UNIT</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nextc<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment">// Releasing the read lock has no effect on readers,</span>
            <span class="token comment">// but it may allow waiting writers to proceed if</span>
            <span class="token comment">// both read and write locks are now free.</span>
            <span class="token comment">// 如果释放后锁空闲，那么返回true，否则返回false</span>
            <span class="token keyword">return</span> nextc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到释放读锁的方法就简单很多了</p><ul><li>假如当前线程是第一个获取读锁的线程，则需要特殊处理；</li><li>假如当前线程不是第一个获取读锁的线程，则配合 cachedHoldCounter 去释放读锁；</li><li>最后会使用 CAS 保证修改同步资源 state 一定成功；</li><li>释放读锁成功后，会调用 AbstractQueuedSynchronizer#doReleaseShared 方法，这个方法会传播唤醒等待队列中的共享节点，也就是等待获取读锁的节点；</li></ul><p><strong>关于 cachedHoldCounter 的作用</strong>，一般获取和释放读锁的线程都是最后一个线程，虽然每个线程的重入次数都会使用 readHolds 这个 ThreadLocal 来保存，但是假如每次获取读锁重入次数都要去 ThreadLocal 里面去查的话，就比较费时。这是就可以用 cachedHoldCounter 保存最后一个线程的读锁重入次数，这样就可以较少很多查询了，直接拿这个缓存用即可，这算是一个优化吧，空间换时间。</p><h2 id="读写锁的特点" tabindex="-1"><a class="header-anchor" href="#读写锁的特点" aria-hidden="true">#</a> 读写锁的特点</h2><h3 id="读锁与写锁的互斥关系" tabindex="-1"><a class="header-anchor" href="#读锁与写锁的互斥关系" aria-hidden="true">#</a> 读锁与写锁的互斥关系</h3><ul><li><strong>读锁和写锁的互斥：当一个线程持有了读锁时，所有线程都无法获取写锁（共享锁）；</strong></li><li><strong>写锁和写锁的互斥：当一个线程持有了写锁时，其他线程无法获取写锁（独占锁）；</strong></li></ul><p>分析下上面的结论：</p><p>先看获取写锁的方法 ReentrantReadWriteLock.Sync#tryAcquire</p><ul><li>首先 <code>c != 0</code> 表示肯定有线程持有读写锁；</li><li>然后 <code>w == 0 || current != getExclusiveOwnerThread()</code><ul><li>第一个条件<code> w == 0</code> 表示写锁计数是 0，那么肯定是<strong>有别的线程持有读锁了，这时直接获取写锁失败</strong>；</li><li>第二个条件 <code>w != 0 &amp;&amp; current != getExclusiveOwnerThread()</code> 说明有线程持有写锁，但是不是当前线程，那么也会获取写锁失败；</li></ul></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> current <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token comment">// 省略...</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 省略....</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再看获取读锁的方法</p><ul><li><code>exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current</code> 表示有线程获取了写锁，但不是当前线程，</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> current<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 省略......</span>
    
    <span class="token keyword">return</span> <span class="token function">fullTryAcquireShared</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="可重入性" tabindex="-1"><a class="header-anchor" href="#可重入性" aria-hidden="true">#</a> 可重入性</h3><p>ReentrantReadWriteLock 的读锁和写锁都支持重入。</p><ul><li>写锁的重入：在 ReentrantReadWriteLock.Sync#tryAcquire 里会判断当前持有写锁的线程是不是当前线程，假如是当前线程的话，就会尝试获取写锁；</li><li>读锁的重入：读锁的重入是在 ReentrantReadWriteLock.Sync#fullTryAcquireShared 方法里面处理的。</li></ul><h3 id="锁的升降级" tabindex="-1"><a class="header-anchor" href="#锁的升降级" aria-hidden="true">#</a> 锁的升降级</h3><ul><li>当一个线程获取了读锁后，是不能升级为写锁的。也就是说不能从读锁升级为写锁；</li><li>当一个线程获取了写锁后，可以继续获取读锁。</li></ul><h3 id="公平模式和非公平模式" tabindex="-1"><a class="header-anchor" href="#公平模式和非公平模式" aria-hidden="true">#</a> 公平模式和非公平模式</h3><p>主要涉及到了两个内部类</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 公平模式的 Sync 实现
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">FairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2274990926593161451L</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">writerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">readerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 非公平模式的 Sync 实现
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NonfairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">8159625535654395037L</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">writerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// writers can always barge</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">readerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">apparentlyFirstQueuedIsExclusive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>公平模式无论是获取读锁还是获取写锁都需要调用 AbstractQueuedSynchronizer#hasQueuedPredecessors 校验是否需要阻塞等待，这个方法之前分析过，其实就是查询当前线程前面是否有别的线程在排队。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// The correctness of this depends on head being initialized</span>
    <span class="token comment">// before tail and on head.next being accurate if the current</span>
    <span class="token comment">// thread is first in queue.</span>
    <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span> <span class="token comment">// Read fields in reverse initialization order</span>
    <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token class-name">Node</span> s<span class="token punctuation">;</span>
    <span class="token comment">// 条件 1：h != t 说明等待队列内有元素</span>
    <span class="token comment">// 条件 2：(s = h.next) == null || s.thread != Thread.currentThread()</span>
    <span class="token comment">// (s = h.next) == null</span>
    <span class="token keyword">return</span> h <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>非公平模式的获取写锁的 writerShouldBlock() 方法直接返回的 false，表示在尝试获取写锁的时候，不管 AQS 中是否有尝试获取写锁的线程在等待，直接 CAS 尝试修改 state 的值。（<strong>这可能会导致在等待队列中的等待的尝试获取写锁的线程饥饿</strong>）</p><p>非公平模式的获取读锁的 readerShouldBlock() 方法是调用 AQS#apparentlyFirstQueuedIsExclusive 方法，这个方法就是判断当 head.next 节点是独占模式的节点的话，需要将当前尝试获取读锁的线程阻塞（当然前面分析了，ReentrantReadWriteLock 在这里不一定会阻塞，因为有读锁重入的情况）；</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">apparentlyFirstQueuedIsExclusive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span> h<span class="token punctuation">,</span> s<span class="token punctuation">;</span>
    <span class="token comment">// case1 有 head 节点</span>
    <span class="token comment">// case2 有 head.next 节点</span>
    <span class="token comment">// case3 不是共享节点</span>
    <span class="token comment">// case4 节点的线程不是 null</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span>  <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
        <span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">isShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token operator">&amp;&amp;</span>
        s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>ReentrantReadWriteLock 是基于 AQS 实现的一个读写锁，它有以下特性：</p><ul><li>读锁和写锁<strong>都支持锁重入</strong>；</li><li>读锁和写锁<strong>都支持公平模式和非公平模式</strong>；</li><li>锁之间的互斥关系： <ul><li>假如一个线程获取了写锁，其他线程无法获取写锁，写锁是一个独占锁；</li><li>假如一个线程获取了读锁，所有线程都无法获取写锁，这也说明了<strong>锁是无法升级的</strong>；</li><li>假如一个线程获取了写锁，这个线程还是可以获取读锁的，这也说明了<strong>锁是可以从写锁降级为读锁的</strong>；</li></ul></li></ul><p>写锁的获取和释放流程和 ReentrantLock 基本上一样：</p><p><strong>写锁的获取</strong></p><ol><li>先判断同步资源的状态 <ol><li>假如有一个线程持有读锁，不允许获取写锁；</li><li>假如有线程持有写锁，且不是当前线程持有的，不允许当前线程获取写锁。如果是当前线程持有的那就执行锁重入的逻辑；</li></ol></li><li>根据是否公平的策略决定当前线程是否需要在 AQS 中阻塞等待，假如不需要则尝试 CAS 更新状态获取写锁。</li></ol><p><strong>写锁的释放</strong></p><ol><li>首先需要判断当前线程是否是持有写锁的线程，假如不是则抛出异常；</li><li>修改同步资源 state 的值，释放写锁；</li></ol><p><strong>写锁获取和释放流程图</strong></p><p><img src="/assets/20-RRWL获取和释放写锁流程图-c34ec781.png" alt="20-RRWL获取和释放写锁流程图"></p><p><strong>读锁的获取</strong></p><ol><li>先判断同步资源的状态 <ol><li>假如有线程持有了读锁，但是不是当前线程持有的，此时不允许获取读锁；</li></ol></li><li>先判断是否需要在 AQS 等待队列阻塞挂起（是否公平），如果不需要，则尝试 CAS 更新同步资源值，更新成功则说明获取读锁成功，需要注意的是，第二步并未处理读锁重入的情况；</li><li>进入到第 3 步有两种情况，（1）第二步的线程需要在 AQS 等待队列阻塞挂起（2） CAS 更新同步资源失败，说明有并发情况。这两种情况需要进入循环尝试获取读锁的 fullTryAcquireShared 方法，这里面主要做两件事。 <ol><li>循环处理读锁重入的情况；</li><li>循环尝试 CAS 更新同步资源值；</li></ol></li></ol><p><strong>读锁的释放</strong></p><ol><li>处理用于读锁重入计数的变量，例如 firstReaderHoldCount 和 cachedHoldCounter 这些变量的值；</li><li>开启一个自旋尝试修改同步资源值 state，更新成功则释放读锁成功；</li></ol><p><strong>读锁获取和释放流程图</strong></p><p><img src="/assets/21-RRWL获取和释放读锁流程图-4d22476b.png" alt="21-RRWL获取和释放读锁流程图"></p></div><!----><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: guosgbin@163.com">Dylan Kwok</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a href="/JDK_source/15-%E4%BA%A4%E6%8D%A2Exchanger.html" class="nav-link prev" aria-label="15-交换Exchanger"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->15-交换Exchanger</div></a><a href="/JDK_source/17-Future%E6%A8%A1%E5%BC%8F-FutureTask.html" class="nav-link next" aria-label="17-Future模式-FutureTask"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">17-Future模式-FutureTask<!----></div></a></nav><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-1d017c6a.js" defer></script>
  </body>
</html>
