<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.62" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://blog.guosgbin.cn/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html"><meta property="og:title" content="20-线程池体系-ThreadPoolExecutor"><meta property="og:description" content="版本 内容 时间 ---- ------------------------ ---------------------- V1 新建 2021年03月12日23:09:11 V2 基于第一版修改并重新排版 2022年10月12日21:20:34 线程池的优势 降低资源消耗 我们知道，线程在Java堆里面是一个对象，也是操作系统的一部分资源，线程创建、..."><meta property="og:type" content="article"><meta property="og:image" content="https://blog.guosgbin.cn/"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-05-04T03:52:42.000Z"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="20-线程池体系-ThreadPoolExecutor"><meta property="article:author" content="超威蓝猫 Dylan Kwok"><meta property="article:modified_time" content="2023-05-04T03:52:42.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"20-线程池体系-ThreadPoolExecutor","image":["https://blog.guosgbin.cn/"],"dateModified":"2023-05-04T03:52:42.000Z","author":[{"@type":"Person","name":"超威蓝猫 Dylan Kwok","url":"","email":"guosgbin@163.com"}]}</script><link rel="icon" href="/小熊猫.svg"><title>20-线程池体系-ThreadPoolExecutor</title><meta name="description" content="版本 内容 时间 ---- ------------------------ ---------------------- V1 新建 2021年03月12日23:09:11 V2 基于第一版修改并重新排版 2022年10月12日21:20:34 线程池的优势 降低资源消耗 我们知道，线程在Java堆里面是一个对象，也是操作系统的一部分资源，线程创建、...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-219a40be.css" as="style"><link rel="stylesheet" href="/assets/style-219a40be.css">
    <link rel="modulepreload" href="/assets/app-2523771a.js"><link rel="modulepreload" href="/assets/20-线程池体系-ThreadPoolExecutor.html-96e09bd4.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-c27b6911.js"><link rel="modulepreload" href="/assets/20-线程池体系-ThreadPoolExecutor.html-a274637a.js"><link rel="prefetch" href="/assets/index.html-f838ce4f.js" as="script"><link rel="prefetch" href="/assets/01-CAS和Unsafe的API分析.html-612c4d6a.js" as="script"><link rel="prefetch" href="/assets/02-基本类型原子类AtomicLong.html-4083b8fd.js" as="script"><link rel="prefetch" href="/assets/03-引用类型原子类AtomicReference.html-8442553d.js" as="script"><link rel="prefetch" href="/assets/04-原子数组类AtomicLongArray.html-74e4c741.js" as="script"><link rel="prefetch" href="/assets/05-原子操作类AtomicReferenceFieldUpdater.html-d0310b2a.js" as="script"><link rel="prefetch" href="/assets/06-高性能原子类LongAdder.html-d6e3da8b.js" as="script"><link rel="prefetch" href="/assets/07-LockSupport分析.html-8117dd17.js" as="script"><link rel="prefetch" href="/assets/08-AQS简单介绍.html-f6f424de.js" as="script"><link rel="prefetch" href="/assets/09-基于ReentrantLock分析AQS的独占模式.html-2423c430.js" as="script"><link rel="prefetch" href="/assets/10-基于CountDownLatch分析AQS的共享模式.html-91ef4833.js" as="script"><link rel="prefetch" href="/assets/11-AQS的Condition机制.html-836364af.js" as="script"><link rel="prefetch" href="/assets/12-信号量Semaphore.html-3509682c.js" as="script"><link rel="prefetch" href="/assets/13-循环栏栅CyclicBarrier.html-812d137d.js" as="script"><link rel="prefetch" href="/assets/14-阶段Phaser.html-d684f4a1.js" as="script"><link rel="prefetch" href="/assets/15-交换Exchanger.html-b9bf24f3.js" as="script"><link rel="prefetch" href="/assets/16-读写锁ReentrantReadWriteLock.html-de44a1d3.js" as="script"><link rel="prefetch" href="/assets/17-Future模式-FutureTask.html-641c6250.js" as="script"><link rel="prefetch" href="/assets/18-线程池体系概述.html-dbcc52e5.js" as="script"><link rel="prefetch" href="/assets/19-线程池体系-AbstractExecutorService.html-fbd70afb.js" as="script"><link rel="prefetch" href="/assets/21-线程池体系-ScheduledThreadPoolExecutor.html-707ffd40.js" as="script"><link rel="prefetch" href="/assets/22-CopyOnWriteArrayList写时复制.html-914977b9.js" as="script"><link rel="prefetch" href="/assets/23-CopyOnWriteArraySet写时复制.html-6c9c3cf6.js" as="script"><link rel="prefetch" href="/assets/24-ConcurrentSkipListMap跳表.html-6cff54bf.js" as="script"><link rel="prefetch" href="/assets/25-ConcurrentSkipListSet跳表.html-36cf4f7d.js" as="script"><link rel="prefetch" href="/assets/26-ConcurrentHashMap源码分析.html-a3bba8a9.js" as="script"><link rel="prefetch" href="/assets/27-阻塞队列ArrayBlockingQueue.html-cd091357.js" as="script"><link rel="prefetch" href="/assets/28-阻塞队列LinkedBlockingQueue.html-d3579ee7.js" as="script"><link rel="prefetch" href="/assets/29-阻塞队列LinkedBlockingDeque.html-32c13680.js" as="script"><link rel="prefetch" href="/assets/30-阻塞队列PriorityBlockingQueue.html-b5455c77.js" as="script"><link rel="prefetch" href="/assets/31-阻塞队列DelayQueue.html-7759c195.js" as="script"><link rel="prefetch" href="/assets/32-阻塞队列SynchronousQueue.html-97ed879a.js" as="script"><link rel="prefetch" href="/assets/33-阻塞队列LinkedTransferQueue.html-3281c1b4.js" as="script"><link rel="prefetch" href="/assets/index.html-f5239cf3.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis01：myabtis的整体架构.html-f25c0705.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis02：入门案例.html-30e68cd3.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis03：解析全局配置文件.html-2db85266.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis04：解析Mapper映射文件.html-60756a5b.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis05：解析Statement操作节点.html-31e11b60.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis06：解析SQL语句.html-a9181b56.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis07：Java方法和SQL语句绑定.html-9bfa3db6.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis08：获得SqlSession.html-e2a92940.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis09：Executor执行器.html-ad701715.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis10：缓存机制.html-f2daa10c.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis11：StatementHandler.html-95b30d9b.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis12：参数解析和赋值.html-5778c0ea.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis13：结果集处理.html-2ff72779.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis14：插件.html-76cc6bf8.js" as="script"><link rel="prefetch" href="/assets/01-服务端启动流程.html-d2fc1f19.js" as="script"><link rel="prefetch" href="/assets/02-服务端启动添加ChannelInitializer到管道.html-86cb5d6a.js" as="script"><link rel="prefetch" href="/assets/03-客户端启动流程.html-becc83be.js" as="script"><link rel="prefetch" href="/assets/04-线程体系-NioEventLoopGroup.html-700e797e.js" as="script"><link rel="prefetch" href="/assets/05-线程体系-NioEventLoop相关父接口分析.html-754320bc.js" as="script"><link rel="prefetch" href="/assets/06-线程体系-AbstractEventExecutor.html-5250cd42.js" as="script"><link rel="prefetch" href="/assets/07-线程体系-AbstractScheduledEventExecutor-优先队列.html-e7bbaf32.js" as="script"><link rel="prefetch" href="/assets/08-线程体系-NioEventLoop概述.html-fce3fb2c.js" as="script"><link rel="prefetch" href="/assets/09-线程体系-NioEventLoop开启Selector及优化.html-6d8230cf.js" as="script"><link rel="prefetch" href="/assets/10-线程体系-NioEventLoop绑定线程.html-db947821.js" as="script"><link rel="prefetch" href="/assets/11-线程体系-NioEventLoop的run方法.html-def4cc31.js" as="script"><link rel="prefetch" href="/assets/12-线程体系-NioEventLoop规避JDK的NIO空循环bug.html-16ecaf4e.js" as="script"><link rel="prefetch" href="/assets/13-线程体系-NioEventLoop的优雅关闭.html-912d668d.js" as="script"><link rel="prefetch" href="/assets/14-服务端处理客户端的连接(ACCEPT).html-63afdec1.js" as="script"><link rel="prefetch" href="/assets/15-客户端处理READ事件概述.html-b35daeb8.js" as="script"><link rel="prefetch" href="/assets/16-客户端处理READ事件详解及RecvByteBufAllocator.html-a9faccfa.js" as="script"><link rel="prefetch" href="/assets/17-Netty管道机制.html-ba70b238.js" as="script"><link rel="prefetch" href="/assets/18-Netty发送数据流程及出站缓冲区.html-223d04a7.js" as="script"><link rel="prefetch" href="/assets/index.html-b475d8b0.js" as="script"><link rel="prefetch" href="/assets/Redis_Benchmark基准测试.html-dbf21951.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群和槽管理命令.html-2b4a1244.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群基本特性和集群搭建.html-42be726b.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群管理工具redis-cli.html-fc4f1503.js" as="script"><link rel="prefetch" href="/assets/Redis_Pipeline优化RTT.html-8a4aa041.js" as="script"><link rel="prefetch" href="/assets/Redis_Sentinel高可用.html-6bcdb34a.js" as="script"><link rel="prefetch" href="/assets/Redis_key设计规范.html-ab90a7dc.js" as="script"><link rel="prefetch" href="/assets/Redis事务.html-e43061e1.js" as="script"><link rel="prefetch" href="/assets/Redis内存淘汰策略.html-feabd314.js" as="script"><link rel="prefetch" href="/assets/Redis发布订阅.html-68771977.js" as="script"><link rel="prefetch" href="/assets/Redis复制.html-33b20d6f.js" as="script"><link rel="prefetch" href="/assets/Redis大key和热key问题.html-394d194e.js" as="script"><link rel="prefetch" href="/assets/Redis慢查询日志.html-7fb06db0.js" as="script"><link rel="prefetch" href="/assets/Redis持久化机制.html-53af3f7a.js" as="script"><link rel="prefetch" href="/assets/Redis键空间通知(keyspace notification).html-012bd277.js" as="script"><link rel="prefetch" href="/assets/redis-cli 使用.html-f7ab22db.js" as="script"><link rel="prefetch" href="/assets/01-RocketMQ概述.html-25463efe.js" as="script"><link rel="prefetch" href="/assets/02-NameServer启动流程.html-a514999f.js" as="script"><link rel="prefetch" href="/assets/03-Broker启动流程.html-43c84806.js" as="script"><link rel="prefetch" href="/assets/04-RocketMQ网络通信原理.html-ac88de8d.js" as="script"><link rel="prefetch" href="/assets/05-RocketMQ 服务端和客户端的启动.html-ef7f1888.js" as="script"><link rel="prefetch" href="/assets/06-RocketMQ网络通信源码.html-b8e0bf43.js" as="script"><link rel="prefetch" href="/assets/07-NameServer作用和路由元信息.html-82a23869.js" as="script"><link rel="prefetch" href="/assets/08-NameServer路由管理源码分析.html-8da2bd72.js" as="script"><link rel="prefetch" href="/assets/09-生产者相关类分析.html-08f6e840.js" as="script"><link rel="prefetch" href="/assets/10-生产者启动流程.html-d761cf07.js" as="script"><link rel="prefetch" href="/assets/11-生产者发送消息.html-743328bc.js" as="script"><link rel="prefetch" href="/assets/resume.html-ae9f6b8c.js" as="script"><link rel="prefetch" href="/assets/404.html-f3795607.js" as="script"><link rel="prefetch" href="/assets/index.html-10b45510.js" as="script"><link rel="prefetch" href="/assets/index.html-dfd17ea5.js" as="script"><link rel="prefetch" href="/assets/index.html-2f392b9e.js" as="script"><link rel="prefetch" href="/assets/index.html-0efbdc5e.js" as="script"><link rel="prefetch" href="/assets/index.html-ca6dfd42.js" as="script"><link rel="prefetch" href="/assets/01-CAS和Unsafe的API分析.html-7ba17841.js" as="script"><link rel="prefetch" href="/assets/02-基本类型原子类AtomicLong.html-1fd0e0c2.js" as="script"><link rel="prefetch" href="/assets/03-引用类型原子类AtomicReference.html-f8ecd582.js" as="script"><link rel="prefetch" href="/assets/04-原子数组类AtomicLongArray.html-693a6fe4.js" as="script"><link rel="prefetch" href="/assets/05-原子操作类AtomicReferenceFieldUpdater.html-8a26126d.js" as="script"><link rel="prefetch" href="/assets/06-高性能原子类LongAdder.html-e1f87209.js" as="script"><link rel="prefetch" href="/assets/07-LockSupport分析.html-a574f1fc.js" as="script"><link rel="prefetch" href="/assets/08-AQS简单介绍.html-10b7fbdb.js" as="script"><link rel="prefetch" href="/assets/09-基于ReentrantLock分析AQS的独占模式.html-ccd5152d.js" as="script"><link rel="prefetch" href="/assets/10-基于CountDownLatch分析AQS的共享模式.html-5cf0e2ee.js" as="script"><link rel="prefetch" href="/assets/11-AQS的Condition机制.html-7526fe2d.js" as="script"><link rel="prefetch" href="/assets/12-信号量Semaphore.html-49442431.js" as="script"><link rel="prefetch" href="/assets/13-循环栏栅CyclicBarrier.html-8197c1f6.js" as="script"><link rel="prefetch" href="/assets/14-阶段Phaser.html-17b533e6.js" as="script"><link rel="prefetch" href="/assets/15-交换Exchanger.html-308e2996.js" as="script"><link rel="prefetch" href="/assets/16-读写锁ReentrantReadWriteLock.html-ca79d4d3.js" as="script"><link rel="prefetch" href="/assets/17-Future模式-FutureTask.html-fc1ae379.js" as="script"><link rel="prefetch" href="/assets/18-线程池体系概述.html-25c9a3e1.js" as="script"><link rel="prefetch" href="/assets/19-线程池体系-AbstractExecutorService.html-57231832.js" as="script"><link rel="prefetch" href="/assets/21-线程池体系-ScheduledThreadPoolExecutor.html-6a99c023.js" as="script"><link rel="prefetch" href="/assets/22-CopyOnWriteArrayList写时复制.html-60b87bd1.js" as="script"><link rel="prefetch" href="/assets/23-CopyOnWriteArraySet写时复制.html-bf41b559.js" as="script"><link rel="prefetch" href="/assets/24-ConcurrentSkipListMap跳表.html-bfad0eee.js" as="script"><link rel="prefetch" href="/assets/25-ConcurrentSkipListSet跳表.html-f4028904.js" as="script"><link rel="prefetch" href="/assets/26-ConcurrentHashMap源码分析.html-9735c629.js" as="script"><link rel="prefetch" href="/assets/27-阻塞队列ArrayBlockingQueue.html-ef2b7834.js" as="script"><link rel="prefetch" href="/assets/28-阻塞队列LinkedBlockingQueue.html-f4393f96.js" as="script"><link rel="prefetch" href="/assets/29-阻塞队列LinkedBlockingDeque.html-e7f54a25.js" as="script"><link rel="prefetch" href="/assets/30-阻塞队列PriorityBlockingQueue.html-b6091772.js" as="script"><link rel="prefetch" href="/assets/31-阻塞队列DelayQueue.html-03a4c0ed.js" as="script"><link rel="prefetch" href="/assets/32-阻塞队列SynchronousQueue.html-99584a0a.js" as="script"><link rel="prefetch" href="/assets/33-阻塞队列LinkedTransferQueue.html-d3aa5acd.js" as="script"><link rel="prefetch" href="/assets/index.html-37a2f13f.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis01：myabtis的整体架构.html-ddf7694d.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis02：入门案例.html-21120744.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis03：解析全局配置文件.html-0e220500.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis04：解析Mapper映射文件.html-9b18cbb7.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis05：解析Statement操作节点.html-76d6a753.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis06：解析SQL语句.html-9fd200fb.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis07：Java方法和SQL语句绑定.html-41f8fe9e.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis08：获得SqlSession.html-c94319d0.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis09：Executor执行器.html-d4559164.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis10：缓存机制.html-6449b343.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis11：StatementHandler.html-f65ebbc7.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis12：参数解析和赋值.html-13dee4ed.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis13：结果集处理.html-c53a9c81.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis14：插件.html-2cd11f11.js" as="script"><link rel="prefetch" href="/assets/01-服务端启动流程.html-e26c618a.js" as="script"><link rel="prefetch" href="/assets/02-服务端启动添加ChannelInitializer到管道.html-92cd4736.js" as="script"><link rel="prefetch" href="/assets/03-客户端启动流程.html-7bcd50c4.js" as="script"><link rel="prefetch" href="/assets/04-线程体系-NioEventLoopGroup.html-3a10e518.js" as="script"><link rel="prefetch" href="/assets/05-线程体系-NioEventLoop相关父接口分析.html-197db18d.js" as="script"><link rel="prefetch" href="/assets/06-线程体系-AbstractEventExecutor.html-a020fd06.js" as="script"><link rel="prefetch" href="/assets/07-线程体系-AbstractScheduledEventExecutor-优先队列.html-740cfdc6.js" as="script"><link rel="prefetch" href="/assets/08-线程体系-NioEventLoop概述.html-9e53b84b.js" as="script"><link rel="prefetch" href="/assets/09-线程体系-NioEventLoop开启Selector及优化.html-4cd07e8b.js" as="script"><link rel="prefetch" href="/assets/10-线程体系-NioEventLoop绑定线程.html-c8221178.js" as="script"><link rel="prefetch" href="/assets/11-线程体系-NioEventLoop的run方法.html-866157b8.js" as="script"><link rel="prefetch" href="/assets/12-线程体系-NioEventLoop规避JDK的NIO空循环bug.html-8dfa5222.js" as="script"><link rel="prefetch" href="/assets/13-线程体系-NioEventLoop的优雅关闭.html-89178761.js" as="script"><link rel="prefetch" href="/assets/14-服务端处理客户端的连接(ACCEPT).html-243c879e.js" as="script"><link rel="prefetch" href="/assets/15-客户端处理READ事件概述.html-b57353a9.js" as="script"><link rel="prefetch" href="/assets/16-客户端处理READ事件详解及RecvByteBufAllocator.html-0e3314b9.js" as="script"><link rel="prefetch" href="/assets/17-Netty管道机制.html-8a5a570a.js" as="script"><link rel="prefetch" href="/assets/18-Netty发送数据流程及出站缓冲区.html-a0b3d6e0.js" as="script"><link rel="prefetch" href="/assets/index.html-93e15c87.js" as="script"><link rel="prefetch" href="/assets/Redis_Benchmark基准测试.html-fec02713.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群和槽管理命令.html-b8762600.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群基本特性和集群搭建.html-74c18eb5.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群管理工具redis-cli.html-26ee1786.js" as="script"><link rel="prefetch" href="/assets/Redis_Pipeline优化RTT.html-c53997a1.js" as="script"><link rel="prefetch" href="/assets/Redis_Sentinel高可用.html-3d3190c8.js" as="script"><link rel="prefetch" href="/assets/Redis_key设计规范.html-139be2b0.js" as="script"><link rel="prefetch" href="/assets/Redis事务.html-910bd516.js" as="script"><link rel="prefetch" href="/assets/Redis内存淘汰策略.html-ca1a68c0.js" as="script"><link rel="prefetch" href="/assets/Redis发布订阅.html-3c04a859.js" as="script"><link rel="prefetch" href="/assets/Redis复制.html-0fc585a3.js" as="script"><link rel="prefetch" href="/assets/Redis大key和热key问题.html-a051743e.js" as="script"><link rel="prefetch" href="/assets/Redis慢查询日志.html-cc751958.js" as="script"><link rel="prefetch" href="/assets/Redis持久化机制.html-edc370a3.js" as="script"><link rel="prefetch" href="/assets/Redis键空间通知(keyspace notification).html-0b7a5999.js" as="script"><link rel="prefetch" href="/assets/redis-cli 使用.html-67ec9191.js" as="script"><link rel="prefetch" href="/assets/01-RocketMQ概述.html-42bb3fc6.js" as="script"><link rel="prefetch" href="/assets/02-NameServer启动流程.html-c40b8eb8.js" as="script"><link rel="prefetch" href="/assets/03-Broker启动流程.html-d2cce092.js" as="script"><link rel="prefetch" href="/assets/04-RocketMQ网络通信原理.html-7b0752e1.js" as="script"><link rel="prefetch" href="/assets/05-RocketMQ 服务端和客户端的启动.html-811092ed.js" as="script"><link rel="prefetch" href="/assets/06-RocketMQ网络通信源码.html-47e2bd4f.js" as="script"><link rel="prefetch" href="/assets/07-NameServer作用和路由元信息.html-943e68b9.js" as="script"><link rel="prefetch" href="/assets/08-NameServer路由管理源码分析.html-3fed8567.js" as="script"><link rel="prefetch" href="/assets/09-生产者相关类分析.html-7f93645b.js" as="script"><link rel="prefetch" href="/assets/10-生产者启动流程.html-802d3584.js" as="script"><link rel="prefetch" href="/assets/11-生产者发送消息.html-36f66be5.js" as="script"><link rel="prefetch" href="/assets/resume.html-10f58f64.js" as="script"><link rel="prefetch" href="/assets/404.html-7c0f415c.js" as="script"><link rel="prefetch" href="/assets/index.html-dbae77d3.js" as="script"><link rel="prefetch" href="/assets/index.html-36bac0f5.js" as="script"><link rel="prefetch" href="/assets/index.html-77ddb35c.js" as="script"><link rel="prefetch" href="/assets/index.html-4e2a4ed6.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-2450701e.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a href="/" class="vp-brand"><img class="vp-nav-logo" src="/小熊猫.png" alt><!----><!----></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><!----><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><!----><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><!--[--><a href="/JDK_source/" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="JUC包源码分析"><!---->JUC包源码分析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/01-CAS%E5%92%8CUnsafe%E7%9A%84API%E5%88%86%E6%9E%90.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="01-CAS和Unsafe的API分析"><!---->01-CAS和Unsafe的API分析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/02-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicLong.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="02-基本类型原子类AtomicLong"><!---->02-基本类型原子类AtomicLong<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/03-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicReference.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="03-引用类型原子类AtomicReference"><!---->03-引用类型原子类AtomicReference<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/04-%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84%E7%B1%BBAtomicLongArray.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="04-原子数组类AtomicLongArray"><!---->04-原子数组类AtomicLongArray<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/05-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BBAtomicReferenceFieldUpdater.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="05-原子操作类AtomicReferenceFieldUpdater"><!---->05-原子操作类AtomicReferenceFieldUpdater<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/06-%E9%AB%98%E6%80%A7%E8%83%BD%E5%8E%9F%E5%AD%90%E7%B1%BBLongAdder.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="06-高性能原子类LongAdder"><!---->06-高性能原子类LongAdder<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/07-LockSupport%E5%88%86%E6%9E%90.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="07-LockSupport分析"><!---->07-LockSupport分析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/08-AQS%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="08-AQS简单介绍"><!---->08-AQS简单介绍<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/09-%E5%9F%BA%E4%BA%8EReentrantLock%E5%88%86%E6%9E%90AQS%E7%9A%84%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="09-基于ReentrantLock分析AQS的独占模式"><!---->09-基于ReentrantLock分析AQS的独占模式<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/10-%E5%9F%BA%E4%BA%8ECountDownLatch%E5%88%86%E6%9E%90AQS%E7%9A%84%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="10-基于CountDownLatch分析AQS的共享模式"><!---->10-基于CountDownLatch分析AQS的共享模式<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="11-AQS的Condition机制"><!---->11-AQS的Condition机制<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/12-%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="12-信号量Semaphore"><!---->12-信号量Semaphore<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/13-%E5%BE%AA%E7%8E%AF%E6%A0%8F%E6%A0%85CyclicBarrier.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="13-循环栏栅CyclicBarrier"><!---->13-循环栏栅CyclicBarrier<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/14-%E9%98%B6%E6%AE%B5Phaser.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="14-阶段Phaser"><!---->14-阶段Phaser<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/15-%E4%BA%A4%E6%8D%A2Exchanger.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="15-交换Exchanger"><!---->15-交换Exchanger<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="16-读写锁ReentrantReadWriteLock"><!---->16-读写锁ReentrantReadWriteLock<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/17-Future%E6%A8%A1%E5%BC%8F-FutureTask.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="17-Future模式-FutureTask"><!---->17-Future模式-FutureTask<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/18-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB%E6%A6%82%E8%BF%B0.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="18-线程池体系概述"><!---->18-线程池体系概述<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/19-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-AbstractExecutorService.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="19-线程池体系-AbstractExecutorService"><!---->19-线程池体系-AbstractExecutorService<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html" class="router-link-active router-link-exact-active nav-link active vp-sidebar-link vp-sidebar-page active" aria-label="20-线程池体系-ThreadPoolExecutor"><!---->20-线程池体系-ThreadPoolExecutor<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#线程池的优势" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="线程池的优势"><!---->线程池的优势<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#juc中线程池体系的继承关系" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="JUC中线程池体系的继承关系"><!---->JUC中线程池体系的继承关系<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#线程池基本介绍" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="线程池基本介绍"><!---->线程池基本介绍<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#引入" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="引入"><!---->引入<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#核心线程数和最大线程数" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="核心线程数和最大线程数"><!---->核心线程数和最大线程数<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#预启动线程" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="预启动线程"><!---->预启动线程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#创建新线程" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="创建新线程"><!---->创建新线程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#线程池存活时间" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="线程池存活时间"><!---->线程池存活时间<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#任务队列" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="任务队列"><!---->任务队列<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#拒绝策略" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="拒绝策略"><!---->拒绝策略<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#钩子方法" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="钩子方法"><!---->钩子方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#移除队列的任务" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="移除队列的任务"><!---->移除队列的任务<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#线程池关闭" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="线程池关闭"><!---->线程池关闭<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#构造方法" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="构造方法"><!---->构造方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#线程池状态和原子变量-ctl" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="线程池状态和原子变量 ctl"><!---->线程池状态和原子变量 ctl<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#原子变量-ctl" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="原子变量 ctl"><!---->原子变量 ctl<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#线程池生命周期" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="线程池生命周期"><!---->线程池生命周期<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#原子变量-ctl-的位操作" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="原子变量 ctl 的位操作"><!---->原子变量 ctl 的位操作<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#其他属性" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="其他属性"><!---->其他属性<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#内部类-worker" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="内部类 Worker"><!---->内部类 Worker<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#线程池提交任务流程" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="线程池提交任务流程"><!---->线程池提交任务流程<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#提交任务入口-execute" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="提交任务入口 execute"><!---->提交任务入口 execute<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#addworker" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="addWorker"><!---->addWorker<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#线程池任务的执行" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="线程池任务的执行"><!---->线程池任务的执行<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#runworker-方法" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="runWorker 方法"><!---->runWorker 方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#获取任务-gettask-方法" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="获取任务 getTask 方法"><!---->获取任务 getTask 方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#processworkerexit-方法" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="processWorkerExit 方法"><!---->processWorkerExit 方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#线程池优雅关闭" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="线程池优雅关闭"><!---->线程池优雅关闭<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#shutdown-方法" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="shutdown 方法"><!---->shutdown 方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#shutdownnow-方法" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="shutdownNow 方法"><!---->shutdownNow 方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#tryterminate-方法" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="tryTerminate 方法"><!---->tryTerminate 方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#awaittermination-等待任务完成" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="awaitTermination 等待任务完成"><!---->awaitTermination 等待任务完成<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#小结" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="小结"><!---->小结<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/JDK_source/21-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ScheduledThreadPoolExecutor.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="21-线程池体系-ScheduledThreadPoolExecutor"><!---->21-线程池体系-ScheduledThreadPoolExecutor<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/22-CopyOnWriteArrayList%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="22-CopyOnWriteArrayList写时复制"><!---->22-CopyOnWriteArrayList写时复制<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/23-CopyOnWriteArraySet%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="23-CopyOnWriteArraySet写时复制"><!---->23-CopyOnWriteArraySet写时复制<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/24-ConcurrentSkipListMap%E8%B7%B3%E8%A1%A8.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="24-ConcurrentSkipListMap跳表"><!---->24-ConcurrentSkipListMap跳表<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/25-ConcurrentSkipListSet%E8%B7%B3%E8%A1%A8.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="25-ConcurrentSkipListSet跳表"><!---->25-ConcurrentSkipListSet跳表<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="26-ConcurrentHashMap源码分析"><!---->26-ConcurrentHashMap源码分析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/27-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97ArrayBlockingQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="27-阻塞队列ArrayBlockingQueue"><!---->27-阻塞队列ArrayBlockingQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/28-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97LinkedBlockingQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="28-阻塞队列LinkedBlockingQueue"><!---->28-阻塞队列LinkedBlockingQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/29-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97LinkedBlockingDeque.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="29-阻塞队列LinkedBlockingDeque"><!---->29-阻塞队列LinkedBlockingDeque<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/30-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97PriorityBlockingQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="30-阻塞队列PriorityBlockingQueue"><!---->30-阻塞队列PriorityBlockingQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/31-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97DelayQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="31-阻塞队列DelayQueue"><!---->31-阻塞队列DelayQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/32-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97SynchronousQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="32-阻塞队列SynchronousQueue"><!---->32-阻塞队列SynchronousQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/33-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97LinkedTransferQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="33-阻塞队列LinkedTransferQueue"><!---->33-阻塞队列LinkedTransferQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->20-线程池体系-ThreadPoolExecutor</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="page-author-item">超威蓝猫 Dylan Kwok</span></span><span property="author" content="超威蓝猫 Dylan Kwok"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-05-04T02:26:04.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 41 分钟</span><meta property="timeRequired" content="PT41M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#线程池的优势" class="router-link-active router-link-exact-active toc-link level2">线程池的优势</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#juc中线程池体系的继承关系" class="router-link-active router-link-exact-active toc-link level2">JUC中线程池体系的继承关系</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#线程池基本介绍" class="router-link-active router-link-exact-active toc-link level2">线程池基本介绍</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#引入" class="router-link-active router-link-exact-active toc-link level3">引入</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#核心线程数和最大线程数" class="router-link-active router-link-exact-active toc-link level3">核心线程数和最大线程数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#预启动线程" class="router-link-active router-link-exact-active toc-link level3">预启动线程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#创建新线程" class="router-link-active router-link-exact-active toc-link level3">创建新线程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#线程池存活时间" class="router-link-active router-link-exact-active toc-link level3">线程池存活时间</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#任务队列" class="router-link-active router-link-exact-active toc-link level3">任务队列</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#拒绝策略" class="router-link-active router-link-exact-active toc-link level3">拒绝策略</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#钩子方法" class="router-link-active router-link-exact-active toc-link level3">钩子方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#移除队列的任务" class="router-link-active router-link-exact-active toc-link level3">移除队列的任务</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#线程池关闭" class="router-link-active router-link-exact-active toc-link level3">线程池关闭</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#构造方法" class="router-link-active router-link-exact-active toc-link level2">构造方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#线程池状态和原子变量-ctl" class="router-link-active router-link-exact-active toc-link level2">线程池状态和原子变量 ctl</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#原子变量-ctl" class="router-link-active router-link-exact-active toc-link level3">原子变量 ctl</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#线程池生命周期" class="router-link-active router-link-exact-active toc-link level3">线程池生命周期</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#原子变量-ctl-的位操作" class="router-link-active router-link-exact-active toc-link level3">原子变量 ctl 的位操作</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#其他属性" class="router-link-active router-link-exact-active toc-link level2">其他属性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#内部类-worker" class="router-link-active router-link-exact-active toc-link level2">内部类 Worker</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#线程池提交任务流程" class="router-link-active router-link-exact-active toc-link level2">线程池提交任务流程</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#提交任务入口-execute" class="router-link-active router-link-exact-active toc-link level3">提交任务入口 execute</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#addworker" class="router-link-active router-link-exact-active toc-link level3">addWorker</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#线程池任务的执行" class="router-link-active router-link-exact-active toc-link level2">线程池任务的执行</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#runworker-方法" class="router-link-active router-link-exact-active toc-link level3">runWorker 方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#获取任务-gettask-方法" class="router-link-active router-link-exact-active toc-link level3">获取任务 getTask 方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#processworkerexit-方法" class="router-link-active router-link-exact-active toc-link level3">processWorkerExit 方法</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#线程池优雅关闭" class="router-link-active router-link-exact-active toc-link level2">线程池优雅关闭</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#shutdown-方法" class="router-link-active router-link-exact-active toc-link level3">shutdown 方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#shutdownnow-方法" class="router-link-active router-link-exact-active toc-link level3">shutdownNow 方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#tryterminate-方法" class="router-link-active router-link-exact-active toc-link level3">tryTerminate 方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#awaittermination-等待任务完成" class="router-link-active router-link-exact-active toc-link level3">awaitTermination 等待任务完成</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html#小结" class="router-link-active router-link-exact-active toc-link level2">小结</a></li><!----><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><table><thead><tr><th>版本</th><th>内容</th><th>时间</th></tr></thead><tbody><tr><td>V1</td><td>新建</td><td>2021年03月12日23:09:11</td></tr><tr><td>V2</td><td>基于第一版修改并重新排版</td><td>2022年10月12日21:20:34</td></tr></tbody></table><h2 id="线程池的优势" tabindex="-1"><a class="header-anchor" href="#线程池的优势" aria-hidden="true">#</a> 线程池的优势</h2><p><b>降低资源消耗</b></p><p>我们知道，线程在Java堆里面是一个对象，也是操作系统的一部分资源，线程创建、销毁需要时间。如果创建线程加上销毁的时间大于执行任务的时间就很不划算了。所以，<strong>线程池通过重复利用已创建的线程降低线程创建和销毁造成的消耗</strong>。</p><p>Java对象占用堆内存，操作系统线程占用系统的内存，根据JVM虚拟机的规范，一个线程默认最大的是1M，我们可以通过-xss去修改，这个栈空间是需要内存分配的，<strong>线程的增加，必然增加内存的消耗，所以线程不是越多越好</strong>。</p><p><b>提高响应速度</b></p><p>当任务到达时，任务可以不需要等到线程创建就能立即执行。</p><p><b>提高线程的可管理性</b></p><p><strong>线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</strong>。</p><h2 id="juc中线程池体系的继承关系" tabindex="-1"><a class="header-anchor" href="#juc中线程池体系的继承关系" aria-hidden="true">#</a> JUC中线程池体系的继承关系</h2><p><img src="/assets/23-线程池框架的继承体系-dee7b0e0.png" alt="23-线程池框架的继承体系"></p><h2 id="线程池基本介绍" tabindex="-1"><a class="header-anchor" href="#线程池基本介绍" aria-hidden="true">#</a> 线程池基本介绍</h2><p>下面大部分翻译 JDK 的文档</p><h3 id="引入" tabindex="-1"><a class="header-anchor" href="#引入" aria-hidden="true">#</a> 引入</h3><p>ThreadPoolExecutor 类是 ExecutorService 接口的一个实现，提交的任务由线程池中的线程来执行。<b>线程池工厂 Executors 可以用来创建各种已经配置好参数的线程池。</b></p><p>线程池的引入主要解决下面的问题：</p><ol><li>线程池<b>提高了执行大量异步任务的性能，减少了每个任务的调用开销</b>，</li><li>给线程提供了限制和管理的一些措施。线程池还提供了一些统计功能，例如线程池总共完成了多少个任务等。</li></ol><p><b>ThreadPoolExecutor提供了多个可配置的参数和大量的钩子方法，钩子方法可以由子类实现来完成扩展</b>。例如在执行任务前调用的 beforeExecute 方法，执行任务后调用的 afterExecute 方法等。</p><h3 id="核心线程数和最大线程数" tabindex="-1"><a class="header-anchor" href="#核心线程数和最大线程数" aria-hidden="true">#</a> 核心线程数和最大线程数</h3><p>ThreadPoolExecutor 会根据 corePoolSize 和 maximumPoolSize 自动调整线程池的线程的个数。</p><p>当一个新的任务被提交到 execute 方法时：</p><ul><li>假如<strong>线程池中的线程的数量小于核心线程数 corePoolSize，此时会创建一个新的线程去处理这个任务</strong>，即使线程池中的线程是空闲的。</li><li>如果此时<strong>线程池的线程数量大于核心线程数但是小于最大线程数</strong>maximumPoolSize，此时<strong>只会在任务队列满了的时候才会创建一个新的线程</strong>。</li></ul><p>假如设置<strong>核心线程数</strong> corePoolSize 和<strong>最大线程数</strong> maximumPoolSize <strong>相同</strong>的话，<strong>表示这是一个固定的线程池</strong>。</p><p>假如将最大线程数 maximumPoolSize 设置的很大的话，如 Integer.MAX_VALUE，则表示允许线程池容纳任意数量的并发任务。核心线程个数 corePoolSize 和最大线程个数 maximumPoolSize 一般在构造器时赋值，但是也可以使用对应的 set 方法设置。</p><h3 id="预启动线程" tabindex="-1"><a class="header-anchor" href="#预启动线程" aria-hidden="true">#</a> 预启动线程</h3><ul><li><strong>默认情况下，即使是核心线程也是在一个新任务提交的时候才会去创建</strong>。但是可以使用方法 prestartCoreThread 和 prestartAllCoreThreads 动态覆盖。</li></ul><p>预启动线程的相关方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 开启一个核心线程</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">prestartCoreThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize <span class="token operator">&amp;&amp;</span>
        <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 与 prestartCoreThread 相同，</span>
<span class="token comment">// 即使 corePoolSize为0，也至少启动一个线程。</span>
<span class="token keyword">void</span> <span class="token function">ensurePrestart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span>
        <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 启动所有核心线程，不用等待任务到来时再创建线程</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">prestartAllCoreThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token operator">++</span>n<span class="token punctuation">;</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="创建新线程" tabindex="-1"><a class="header-anchor" href="#创建新线程" aria-hidden="true">#</a> 创建新线程</h3><ul><li><p><strong>线程是通过线程工厂 ThreadFactory 创建的</strong>。默认使用 DefaultThreadFactory 类来创建线程，它将创建具有相同线程组、优先级和守护状态。<strong>通过提供不同的线程工厂，我们可以更改线程的名称、线程组、优先级、守护进程状态等</strong>。</p></li><li><p>当线程工厂创建线程创建失败返回 null 时，代码会继续运行，但是可能任务无法执行成。</p></li></ul><h3 id="线程池存活时间" tabindex="-1"><a class="header-anchor" href="#线程池存活时间" aria-hidden="true">#</a> 线程池存活时间</h3><ul><li>如果线程池当前拥有的线程个数大于核心线程数 corePoolSize，多出的线程会在空闲超过过期时间 keepAliveTime 时被杀死，有效减少了线程池的资源消耗。</li><li>默认情况下，这个超时时间是针对超过核心线程数之外的线程，我们可以使用 allowCoreThreadTimeOut 方法设置核心线程也可以超时。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 空闲线程超时机制是否应用到核心线程</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">allowCoreThreadTimeOut</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&amp;&amp;</span> keepAliveTime <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Core threads must have nonzero keep alive times&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> allowCoreThreadTimeOut<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        allowCoreThreadTimeOut <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token comment">// 假如是 true，需要中断线程，因为核心线程可能在 获取阻塞队列的任务时 被阻塞了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span>
            <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="任务队列" tabindex="-1"><a class="header-anchor" href="#任务队列" aria-hidden="true">#</a> 任务队列</h3><p>可以使用任何阻塞队列BlockingQueue来传输和保存提交的任务。</p><ul><li>如果线程池的线程个数小于核心线程数 corePoolSize，此时来了新任务时会新创建一个线程去执行，而不是放到任务队列。</li><li>如果线程池的线程个数大于核心线程数 corePoolSize，此时来了新任务时会将任务入队，而不是创建新线程去执行。</li><li>如果一个任务无法入队，假如当前线程池的线程个数小于最大线程数 maximumPoolSize，此时会创建一个新线程去执行此任务，否则执行拒绝策略。</li></ul><p><strong>一般有三种入队的策略</strong>：</p><ul><li><p>Direct handoffs。一个好的选择是使用 SynchronousQueue，它将任务交给线程而不用其他方式保存它们。如果没有立即可用的线程来运行任务，那么就表示对任务的尝试入队失败，因此将创建一个新线程。在处理可能具有内部依赖关系的请求集时，此策略避免了锁定。Direct handoffs 通常需要无限制的最大线程数 maximumPoolSizes，以避免拒绝新提交的任务。<strong>有个缺点就是，当任务的平均提交速度超过了它们的处理速度时，就有可能导致无限制的线程增长</strong>。</p></li><li><p>Unbounded queues。<strong>无界队列</strong>，例如 LinkedBlockingQueue。<strong>使用长度无限制的队列在所有的核心线程都在执行任务时，会导致任务在队列中等待。此时，线程池中永远不会创建超过核心线程数的线程，所以最大线程数 maximumPoolSize 没什么用了</strong>。这种适合任务提交速度比较平缓的场景，假如是高并发访问的情况的话，就容易导致线程无限增长，导致OOM。</p></li><li><p>Bounded queues。<strong>有界队列</strong>，例如 ArrayBlockingQueue。这种队列可以配合配置最大线程数 maximumPoolSizes 来避免资源耗尽，但可能更难以调整和控制。</p><p>队列的长度和最大线程池个数可以相互权衡。<strong>使用容量大的队列配合小的最大线程数 maximumPoolSizes 会最大限度地减少 CPU 使用率、操作系统资源和上下文切换开销，但是这种会人为的降低吞吐量</strong>。</p><p>如果任务经常阻塞，可以考虑调用设置最大线程数的方法，重新设置线程池最大线程数。使用小队列通常需要更大的池大小，这会使 CPU 长期忙碌。如果线程池的容量设置的过大，并发量就会增加，则需要考虑线程调度的问题，反而可能会降低任务的吞吐量。</p></li></ul><p>线程池的线程可以这样配置：</p><ul><li>CPU 密集型任务：参考值可以设置为 NCPU + 1；</li><li>IO 密集型任务：参考值可以设置为 2 * NCPU；</li></ul><h3 id="拒绝策略" tabindex="-1"><a class="header-anchor" href="#拒绝策略" aria-hidden="true">#</a> 拒绝策略</h3><p>执行拒绝策略的情况：</p><ul><li><strong>线程池被关闭了</strong>，SHUTDOWN；</li><li><strong>线程池的任务队列满了，且线程池的线程达到最大线程数了</strong>；</li></ul><p>有4个预定义的拒绝策略：</p><ol><li><strong>默认的拒绝策略</strong>，ThreadPoolExecutor.AbortPolicy，<b>在拒绝的时候抛出一个运行时异常</b>。</li><li>ThreadPoolExecutor.CallerRunsPolicy，假如线程池还未关闭，让调用 execute 方法的线程直接去执行 run 方法，否则不执行。</li><li>ThreadPoolExecutor.DiscardPolicy，<b>这个拒绝策略，什么都没做。其实就是把任务抛弃了</b>。</li><li>ThreadPoolExecutor.DiscardOldestPolicy，用于被拒绝任务的处理程序，它放弃最旧的未处理请求，也就是<b>让最旧的任务出队，自己入队，然后重试 execute 。如果执行程序已关闭，在这种情况下，任务将被丢弃</b>。</li></ol><p>调用 reject 方法拒绝任务，根据设置的拒绝策略处理。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    handler<span class="token punctuation">.</span><span class="token function">rejectedExecution</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>默认 AbortPolicy，可以看到是直接抛出一个异常；</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">AbortPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionException</span><span class="token punctuation">(</span><span class="token string">&quot;Task &quot;</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                                             <span class="token string">&quot; rejected from &quot;</span> <span class="token operator">+</span>
                                             e<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>CallerRunsPolicy，就是在线程池运行状态下让调用 execute 方法的线程去执行这个拒绝的任务。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CallerRunsPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>e<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            r<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>DiscardPolicy，什么也没做，其实就是把任务抛弃了。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DiscardPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">DiscardPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>DiscardOldestPolicy，顾名思义，就是在线程池是运行态时丢掉最旧的任务，然后调用 execute 方法重新提交任务。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DiscardOldestPolicy</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">DiscardOldestPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token doc-comment comment">/**
     * Obtains and ignores the next task that the executor
     * would otherwise execute, if one is immediately available,
     * and then retries execution of task r, unless the executor
     * is shut down, in which case task r is instead discarded.
     *
     * <span class="token keyword">@param</span> <span class="token parameter">r</span> the runnable task requested to be executed
     * <span class="token keyword">@param</span> <span class="token parameter">e</span> the executor attempting to execute this task
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>e<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            e<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以自定义一个拒绝策略，做一下记录，例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomRejectedExecutionHandler</span> <span class="token keyword">implements</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token punctuation">{</span>
    <span class="token comment">// 共抛弃多少个任务</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicLong</span> handlerCount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 每抛弃多少个任务报警一次</span>
    <span class="token keyword">private</span> <span class="token class-name">Long</span> period<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">CustomRejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token class-name">Long</span> period<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>period <span class="token operator">=</span> period<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>executor<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            executor<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">long</span> currentCount <span class="token operator">=</span> handlerCount<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">long</span> model <span class="token operator">=</span> currentCount <span class="token operator">%</span> period<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>currentCount <span class="token operator">==</span> <span class="token number">1L</span> <span class="token operator">||</span> model <span class="token operator">==</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 打日志，发送短信或者钉钉......</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 处理...</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="钩子方法" tabindex="-1"><a class="header-anchor" href="#钩子方法" aria-hidden="true">#</a> 钩子方法</h3><p>提供了一些给子类实现的钩子方法，</p><p>例如在执行任务之前执行的 beforeExecute 方法，在执行任务之后执行的 afterExecute 方法。我们可以在这些方法里面加一些统计的操作。</p><p>此外，方法 terminated 可以被重写，以执行在线程池完全终止后需要完成的任何特殊处理。</p><p>如果钩子方法和回调方法抛出异常，内部工作线程可能会依次失败并突然终止。</p><h3 id="移除队列的任务" tabindex="-1"><a class="header-anchor" href="#移除队列的任务" aria-hidden="true">#</a> 移除队列的任务</h3><p>可以使用 getQueue 方法去获取任务队列对象。强烈建议不要将此方法用于任何其他目的。</p><p>提供的两个方法，remove(Runnable) 和 purge，可用于在取消大量排队的任务时帮助进行存储回收。</p><h3 id="线程池关闭" tabindex="-1"><a class="header-anchor" href="#线程池关闭" aria-hidden="true">#</a> 线程池关闭</h3><p>如果一个线程池在程序中不再被引用，并且内部没有剩余的线程，那么它将<strong>自动被 shutdown 关闭</strong>。</p><p>如果你想确保即使用户忘记调用 shutdown 也能回收未引用的线程，我们必须要让未使用的线程最终死亡。可以通过设置适当的线程的活跃超时时间，0 核心线程或者通过 allowCoreThreadTimeOut 方法设置核心线程是否允许超时等。</p><h2 id="构造方法" tabindex="-1"><a class="header-anchor" href="#构造方法" aria-hidden="true">#</a> 构造方法</h2><p>  线程池的构造方法有 4 个，其实都是基于一个参数最多的构造方法，只需要关注这个即可。</p><p>  构造方法中针对某些参数有些限制</p><ul><li>核心线程数不能小于 0；</li><li>最大线程数量不能小于等于 0，且不小于核心线程数；</li><li>线程超时时间不能小于 0；</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 *
 * <span class="token keyword">@param</span> <span class="token parameter">corePoolSize</span> 核心线程数
 * <span class="token keyword">@param</span> <span class="token parameter">maximumPoolSize</span> 最大线程数
 * <span class="token keyword">@param</span> <span class="token parameter">keepAliveTime</span> 线程的超时时间
 * <span class="token keyword">@param</span> <span class="token parameter">unit</span> 超时时间的单位
 * <span class="token keyword">@param</span> <span class="token parameter">workQueue</span> 存放任务的任务队列
 * <span class="token keyword">@param</span> <span class="token parameter">threadFactory</span> 创建线程的线程工厂类
 * <span class="token keyword">@param</span> <span class="token parameter">handler</span> 线程池的拒绝策略
 */</span>
<span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
                          <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>
                          <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>
                          <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 核心线程数不能小于0</span>
    <span class="token comment">// 最大线程数量不能小于等于0，且不小于核心线程数</span>
    <span class="token comment">// 超时时间不能小于0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>
        maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>
        maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>
        keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> threadFactory <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> handler <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 下面是这些参数的赋值</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>acc <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span>
            <span class="token keyword">null</span> <span class="token operator">:</span>
            <span class="token class-name">AccessController</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="线程池状态和原子变量-ctl" tabindex="-1"><a class="header-anchor" href="#线程池状态和原子变量-ctl" aria-hidden="true">#</a> 线程池状态和原子变量 ctl</h2><h3 id="原子变量-ctl" tabindex="-1"><a class="header-anchor" href="#原子变量-ctl" aria-hidden="true">#</a> 原子变量 ctl</h3><p>ThreadPoolExecutor 使用一个 AtomicInteger 的原子变量 ctl 来记录线程池的状态和当前线程池的有效线程的个数。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token constant">RUNNING</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>ctl 按照位数分隔表示了两个属性：</p><ul><li><strong>wokerCount：表明了存活的有效的线程的个数</strong>；</li><li><strong>runState：表明线程池的状态，例如正在运行，关闭等</strong>；</li></ul><p>ctl 是 int 类型的数，前面 3 位表示线程池的状态，后面 29 为表示有效线程的个数。也就说最多<code>(2 ^ 29) - 1</code> (大约5个亿)个线程。</p><blockquote><p>注意：<b>wokerCount表示正在运行没有停止的的线程的个数，该值可能暂时不等于实际的活动线程数</b>。</p></blockquote><h3 id="线程池生命周期" tabindex="-1"><a class="header-anchor" href="#线程池生命周期" aria-hidden="true">#</a> 线程池生命周期</h3><p>runState 表示线程池的生命周期的状态：</p><ul><li><p><strong>RUNNING：接受新的任务并处理队列中的任务。</strong></p></li><li><p><strong>SHUTDOWN：不接受新的任务，但是会去处理队列中的任务。</strong></p></li><li><p><strong>STOP：不接受新的任务，不处理队列中的任务，中断正在执行中的任务。</strong></p></li><li><p><strong>TIDYING：临时状态。如果所有的任务终止，wokerCount 为 0（阻塞队列为空，线程池中的工作线程数量为 0），线程池就会进入这个状态，是一个过渡状态，会在 TERMINATED 状态之前执行 terminated() 的钩子方法。</strong></p></li><li><p><strong>TERMINATED：处于 TIDYING 状态的线程池调用 terminated() 方法执行完了，就会进入这个状态</strong></p></li></ul><p>为了给这些个状态作比较，也就是判断数值的大小，所以它们的数值大小很重要，运行状态随时间增加，但不保证能够到达每个状态。</p><p>线程池的状态过度过程如下：</p><ul><li><p><code>RUNNING -&gt; SHUTDOWN</code>：<strong>调用了shutdown()方法，该方法还隐藏在finalize()方法中。</strong></p></li><li><p><code>(RUNNING or SHUTDOWN) -&gt; STOP</code>：<strong>调用了shutdownNow()方法。</strong></p></li><li><p><code>SHUTDOWN -&gt; TIDYING</code>：<strong>队列和池子都为空。</strong></p></li><li><p><code>STOP -&gt; TIDYING</code>：<strong>当池子为空时。</strong></p></li><li><p><code>TIDYING -&gt; TERMINATED</code>：<strong>当terminated()的钩子方法执行完成后。</strong></p></li></ul><p><img src="/assets/25-线程池生命周期-684ca070.png" alt="25-线程池生命周期"></p><p>当状态是TERMINATED时，在awaitTermination()方法中等待的线程将会返回。</p><p>检测从SHUTDOWN状态到TIDYING状态，没有我们想象的那么简单，因为队列可能在非空之后变为空，反之亦然。但是我们只能在看到队列为空之后终止，我们看到workerCount为0（这有时需要重新检查——见下文）</p><h3 id="原子变量-ctl-的位操作" tabindex="-1"><a class="header-anchor" href="#原子变量-ctl-的位操作" aria-hidden="true">#</a> 原子变量 ctl 的位操作</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * ctl变量，代表两个含义，高三位代表状态，低位表示线程池中线程的数量
 */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token constant">RUNNING</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * COUNT_BITS表示带代表表示线程数量的上限的位数
 * 一般来说Integer.SIZE为32，所以COUNT_BITS值为29
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">COUNT_BITS</span> <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">SIZE</span> <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 一般来说是29</span>

<span class="token doc-comment comment">/**
 * CAPACITY表示线程个数的上限 大约5亿多  (2 ^ 29) - 1
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CAPACITY</span>   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>


<span class="token comment">/* ---- runState存储在ctl的高三位 ---- */</span>

<span class="token doc-comment comment">/**
 * RUNNING：线程池RUNNING状态
 * 接受新的任务，也会去处理队列中的任务
 * -1右移29位 11100000 00000000 00000000 00000000 负数
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">RUNNING</span>    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * SHUTDOWN：线程池SHUTDOWN状态
 * 不接受新的任务，但是会去处理线程池的任务
 * 0右移29位 00000000 00000000 00000000 00000000
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SHUTDOWN</span>   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * STOP：线程池STOP状态
 * 不接受新的任务，不处理队列中的任务，中断正在执行中的任务
 * 1右移29位 00100000 00000000 00000000 00000000
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">STOP</span>       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * TIDYING：TERMINATED前的过渡状态，用于执行钩子方法
 * 2右移29位 01000000 00000000 00000000 00000000
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TIDYING</span>    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * TERMINATED：线程池TERMINATED状态，表示线程池关闭了
 * 3右移29位 01100000 00000000 00000000 00000000
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TERMINATED</span> <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>线程池运行的状态runState存储在ctl的高三位，所以上面每个状态值对应的二进制就是</p><p>RUNNING：<code>11100000 00000000 00000000 00000000</code>;</p><p>SHUTDOWN：<code>00000000 00000000 00000000 00000000</code>;</p><p>STOP：<code>00100000 00000000 00000000 00000000</code>;</p><p>TIDYING：<code>01000000 00000000 00000000 00000000</code>;</p><p>TERMINATED：<code>01100000 00000000 00000000 00000000</code>;</p><p><b>获取或组装 ctl 变量中代表线程池状态 runState 和线程个数 workCount 部分的值</b></p><p><strong>（1）获取 ctl 中表示当前线程池运行状态的值，高三位</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * ~CAPACITY为 11100000 00000000 00000000 00000000
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token constant">CAPACITY</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>（2）获取 ctl 中 worker 的数量</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * CAPACITY为 00011111 11111111 11111111 11111111
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token constant">CAPACITY</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>（3）用在重置当前线程池 ctl 值时会用到</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * rs 表示线程池状态   wc 表示当前线程池中worker（线程）数量
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> rs <span class="token operator">|</span> wc<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><b>比较线程池各个状态的值的大小的方法</b></p><p><code> RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED</code></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 比较当前线程池ctl所表示的状态c，是否小于某个状态s
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">runStateLessThan</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> c <span class="token operator">&lt;</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 比较当前线程池ctl所表示的状态c，是否大于等于某个状态s
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> c <span class="token operator">&gt;=</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 判断当前线程池是否是RUNNING状态，因为SHUTDOWN状态是0，只有RUNNING是负数
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isRunning</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> c <span class="token operator">&lt;</span> <span class="token constant">SHUTDOWN</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><b>CAS 更新线程池线程个数的方法</b></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 尝试CAS更新workerCount，线程的数量加1
 */</span>
<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> ctl<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>expect<span class="token punctuation">,</span> expect <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 尝试CAS更新workerCount，线程的数量减1
 */</span>
<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> ctl<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>expect<span class="token punctuation">,</span> expect <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 更新workerCount，线程的数量减1。
 * 只有更新成功才会返回
 */</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了上面这些个方法，还有一些判断当前状态的一些方法，比较简单，就不罗列了。</p><h2 id="其他属性" tabindex="-1"><a class="header-anchor" href="#其他属性" aria-hidden="true">#</a> 其他属性</h2><ul><li><code>BlockingQueue&lt;Runnable&gt; workQueue</code>：阻塞队列；</li><li>ReentrantLock mainLock：全局锁；</li><li><code>HashSet&lt;Worker&gt; workers</code>：所有工作线程的 set 池子（只能在 mainLock 下访问）；</li><li>Condition termination：用于线程交互，阻塞唤醒；</li><li>int largestPoolSize：线程池的曾经到达过的最大工作线程个数（只能在 mainLock 下访问）；</li><li>long completedTaskCount：线程池完成的任务总数的近似值（只能在 mainLock 下访问）；</li><li>ThreadFactory threadFactory：线程工厂；</li><li>RejectedExecutionHandler handler：拒绝策略；</li><li>long keepAliveTime：空闲线程的超时时间；</li><li>boolean allowCoreThreadTimeOut：控制 keepAliveTime 的策略是否应用到核心线程；</li><li>int corePoolSize：核心线程数；</li><li>int maximumPoolSize：最大线程数；</li></ul><h2 id="内部类-worker" tabindex="-1"><a class="header-anchor" href="#内部类-worker" aria-hidden="true">#</a> 内部类 Worker</h2><p>Worker 类继承 AbstractQueuedSynchronizer，并实现了 Runnable 接口。</p><p><strong>Worker 继承 AbstractQueuedSynchronizer，以简化获取和释放每个任务执行的锁，为了防止线程被中断</strong>。因为这些中断旨在唤醒等待任务的工作线程，而不是中断正在运行的任务。</p><p>lock 方法一旦获取了独占锁，表示当前线程正在执行任务中，有下面几个作用：</p><ul><li>如果正在执行任务，则不应该中断线程；</li><li>如果线程现在不是独占锁的状态，也就是空闲状态，说明它没有在处理任务，这时可以对线程进行中断；</li></ul><p>线程池在执行 shutdown 方法或 tryTerminate 方法时会调用 interruptIdleWorkers 方法来中断空闲的线程，interruptIdleWorkers 方法会使用 tryLock 方法来判断线程池中的线程是否是空闲状态。</p><p><strong>在运行 Worke的时候之所以没有用 ReentrantLock 作为独占锁来使用是因为这里是要求不可重入的</strong>，线程池实现了一个简单的不可重入互斥锁，而不是使用可重入锁。因为我们不希望任务在调用像setCorePoolSize这样的线程池控制方法时重新获取锁，这样会中断正在运行的线程。</p><p>此外，<strong>为了在线程实际开始运行任务之前抑制中断，我们将锁状态初始化为 -1，并在启动时将其清除（在runWorker 中）</strong>。</p><p>属性：</p><ul><li>Thread thread：Worker 封装的线程；</li><li>Runnable firstTask：Worker 封装的任务，假如此变量不为 null，则 worker 的线程就优先执行此任务；</li><li>long completedTasks：每个线程完成任务个数的计数器；</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span>
    <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span>
    <span class="token keyword">implements</span> <span class="token class-name">Runnable</span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">6138294804551838833L</span><span class="token punctuation">;</span>

    <span class="token comment">// worker 的线程，当在线程工厂创建失败的时候是 null</span>
    <span class="token keyword">final</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>
    <span class="token comment">// 不是 null 的话，当线程启动后会第一个执行这个任务</span>
    <span class="token class-name">Runnable</span> firstTask<span class="token punctuation">;</span>
    <span class="token comment">// 线程完成任务个数</span>
    <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>

    <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 防止在 runWorker 之前被中断</span>
        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// inhibit interrupts until runWorker</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>
        <span class="token comment">// 通过线程工厂创建线程，注意线程可能创建失败</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 线程执行入口</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Lock methods</span>
    <span class="token comment">//</span>
    <span class="token comment">// The value 0 represents the unlocked state.</span>
    <span class="token comment">// The value 1 represents the locked state.</span>

    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 尝试加锁
     */</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 尝试修改同步状态为 0 -&gt; 1 ，修改成功表示加锁成功</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 尝试释放锁
     */</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 加锁</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">// 尝试加锁</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">// 释放锁</span>
    <span class="token comment">// 启动worker之前会先调用unlock()这个方法,</span>
    <span class="token comment">// 会强制刷新独占线程会强制刷新独占线程ExclusiveOwnerThread为null，同步状态State为0</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前worker的独占锁lock是否被占用</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">interruptIfStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> thread<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SecurityException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="线程池提交任务流程" tabindex="-1"><a class="header-anchor" href="#线程池提交任务流程" aria-hidden="true">#</a> 线程池提交任务流程</h2><h3 id="提交任务入口-execute" tabindex="-1"><a class="header-anchor" href="#提交任务入口-execute" aria-hidden="true">#</a> 提交任务入口 execute</h3><p>提交任务入口，我们从 ThreadPoolExecutor#execute 分析</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 校验：当前线程池的存活的线程数量 小于 核心线程数吗？</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 小于核心线程数就尝试创建一个新的线程，添加成功后直接 return</span>
        <span class="token comment">// 入参 true 表示使用核心线程数 corePoolSize 来限制</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token comment">// 到这里说明添加新线程失败（并发），重新获取原子值</span>
        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 前置条件：当前线程池的线程数 &gt;= 核心线程容量，或者是 addWorker 创建线程失败了</span>
    <span class="token comment">// 校验：当前线程池是运行状态 &amp;&amp; 任务入队成功</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 重新获取原子状态 double-check</span>
        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 校验：当前线程池不是运行状态 &amp;&amp; 从队列移除任务成功，则执行拒绝策略</span>
        <span class="token comment">/*
         * CASE 1：!isRunning(recheck) 为 true 的话
         *   说明任务提交到队列之后，线程池状态被外部线程给修改 比如：shutdown() shutdownNow()
         *   此时需要用 remove 将刚刚提交的任务从队列移除
         * CASE 2：remove(command)
         *   移除成功：说明这个任务提交之后，没有线程过来处理
         *   移除失败：说明这个任务提交之后，在线程池关闭前被其他线程给处理了
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 前置条件：线程池是运行态，或者不是运行态但是移除队列失败了</span>
        <span class="token comment">// 假如线程池的线程个数是 0，那么需要创建一个 worker 线程保证这个任务执行</span>
        <span class="token comment">// 此处是保证线程池此时至少得有一个线程，防止线程池没有线程了</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 前置条件：线程池不是运行态，或者是运行态但是任务入队失败</span>
    <span class="token comment">// 此时尝试创建新 worker 线程去执行，</span>
    <span class="token comment">// 1.线程池状态不是运行态，addWorker 肯定会失败，执行拒绝策略</span>
    <span class="token comment">// 2.假如是任务入队失败，需要调用 addWorker 方法去尝试创建新线程，添加失败需要执行拒绝策略</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在线程池刚创建时，默认情况下线程池中的线程数是 0。当我们向线程池提交一个任务时，这个方法的流程：</p><ol><li>如果当前线程池的线程数小于 corePoolSize，说明线程数还未到核心线程数，这时<strong>即使是有空闲线程也会去创建一个新的线程去执行任务</strong>。具体对应代码就是调用 addWorker 方法去创建线程；</li><li><strong>如果当前线程池的线程数大于等于 corePoolSize</strong>，或者是第一步 addWorker 创建线程失败了的情况。假如此时线程池是运行状态，就会<strong>尝试将任务入队，等待线程池中有空闲线程时，就会执行任务队列中的任务</strong>。这里需要检查线程池状态，<strong>如果线程池状态是非运行状态时，需要拒绝新任务，执行拒绝策略；</strong></li><li>假如在步骤 2 中任务入队成功，其他线程可能会修改线程池的状态，需要对线程池的状态进行 double-check； <ol><li>假如线程池当前状态不再是运行态时，需要将刚刚添加的任务从阻塞队列中移除，移除成功则执行后续的拒绝策略（移除失败可能是因为已经执行了）；</li><li>假如线程池当前状态还是运行态时，需要判断线程池的线程个数是否为 0，如果线程池中没有线程了，需要新建一个线程到线程池中（保证线程池此时至少得有一个线程，防止线程池没有线程执行这个任务）；</li></ol></li><li><strong>假如在步骤 2 中任务入队失败，说明阻塞队列已经满了，则会尝试开启新的线程去执行任务。假如当前线程池的线程个数已经到达 maximumPoolSize，则执行拒绝策略</strong>；</li></ol><h3 id="addworker" tabindex="-1"><a class="header-anchor" href="#addworker" aria-hidden="true">#</a> addWorker</h3><p>前面分析的代码中，有很多地方调用了 addWorker 方法，顾名思义，就是尝试创建一个工作线程。</p><p>首先看 addWorker 方法的参数解释：</p><ul><li>Runnable firstTask：假如不为 null 的话，创建的线程会首先执行这个任务；</li><li>boolean core：true 表示使用 corePoolSize 限制线程数量，false 表示使用 maximumPoolSize 限制；</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 外部循环标记 retry</span>
    retry<span class="token operator">:</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/*
         * 判断线程池在此状态是否允许添加线程
         * 条件 1：rs &gt;= SHUTDOWN：成立则说明不是 running 状态
         * 条件 2：结果取反，注意的是当线程池是 SHOTDOWN 状态时，如果队列中还有任务未处理完
         *      这时是允许添加 Worker 的，但是不允许再次提交任务
         *
         * 那么这么说，什么时候走后面的逻辑呢？就是 if 条件返回 false 的时候
         * 1. rs 运行态
         * 2. rs 是 SHUTDOWN 且 firstTask == null 且队列不是空
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&gt;=</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span>
            <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment">// 进入这个的情况</span>
            <span class="token comment">// 1. 当前池子的状态 &gt; SHUTDOWN</span>
            <span class="token comment">// 2. 当前池子状态是 SHUTDOWN，但是 firstTask 不是 null</span>
            <span class="token comment">// 3. 当前池子状态是 SHUTDOWN，但是 firstTask 是 null 且队列是空的，也就是没任务了</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token comment">// 内部自旋，主要是为了增加线程的个数</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 假如当前线程池的线程个数已经达到了 CAPACITY 或者根据 core 变量校验线程个数</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">&gt;=</span> <span class="token constant">CAPACITY</span> <span class="token operator">||</span>
                wc <span class="token operator">&gt;=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment">// 线程个数被限制了，返回 false</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token comment">// CAS 增加 WorkerCount，增加成功退出外循环 retry</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span> retry<span class="token punctuation">;</span>
            c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Re-read ctl</span>
            <span class="token comment">// 自旋过程中，发现线程池的状态改变了，重新开始外循环，重新校验</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>
                <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>
            <span class="token comment">// else CAS failed due to workerCount change; retry inner loop</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 走到这里 workCount 已经成功 +1 了</span>

    <span class="token comment">// 表示创建的 Worker 是否已经启动</span>
    <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 表示创建的 Worker 是否添加到池子中</span>
    <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token class-name">Worker</span> w <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建新线程</span>
        w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">Thread</span> t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>
        <span class="token comment">// 判断 t != null 的原因是，线程是通过线程工厂获取的，线程工厂可能返回的是 null</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
            mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>               
                <span class="token comment">// 双重检查，如果出现ThreadFactory故障或在获取锁之前关闭，请退出。</span>
                <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">// 校验：线程池运行态 || (SHUTDOWN &amp;&amp; firstTask == null)</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">||</span>
                    <span class="token punctuation">(</span>rs <span class="token operator">==</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 校验线程是否调用了 start 方法，这是防止自己实现的 ThreadFactory 在创建线程的时候调了 start</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// precheck that t is startable</span>
                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 获取 Set 的大小，假如大于记录的最大 worker 数量 largestPoolSize，则更新</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;</span> largestPoolSize<span class="token punctuation">)</span>
                        largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>
                    <span class="token comment">// worker 添加成功标志</span>
                    workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 线程校验添加处理成功，则开启线程</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span>
            <span class="token comment">// 线程启动失败，则进入这里</span>
            <span class="token comment">// 主要就是将 Worker 数量减 1，移除刚刚保存到 set 的 worker</span>
            <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回是否成功启动线程</span>
    <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析下这个方法，大概可以分成两部分，第一步是添加线程池的 workerCount，第二步是创建并开启线程；</p><p>（1）首先开启一个外循环，外循环主要是校验线程池的状态：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">/*
 * 判断线程池在此状态是否允许添加线程
 * 条件 1：rs &gt;= SHUTDOWN：成立则说明不是 running 状态
 * 条件 2：结果取反，注意的是当线程池是 SHOTDOWN 状态时，如果队列中还有任务未处理完
 *      这时是允许添加 Worker 的，但是不允许再次提交任务
 *
 * 那么这么说，什么时候走后面的逻辑呢？就是 if 条件返回 false 的时候
 * 1. rs 运行态
 * 2. rs 是 SHUTDOWN 且 firstTask == null 且队列不是空
 */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&gt;=</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span>
    <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// 进入这个的情况</span>
    <span class="token comment">// 1. 当前池子的状态 &gt; SHUTDOWN</span>
    <span class="token comment">// 2. 当前池子状态是 SHUTDOWN，但是 firstTask 不是 null</span>
    <span class="token comment">// 3. 当前池子状态是 SHUTDOWN，但是 firstTask 是 null 且队列是空的，也就是没任务了</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2） 假如上面的状态校验通过，则进入内循环，内循环是为了增加线程池工作线程的数量。根据 core 参数控制当前是否允许创建 Worker 线程。</p><ul><li>假如增加工作线程数量成功，则退出外循环继续向后走；</li><li>假如增加工作线程数量失败，需要校验线程池是否发生改变； <ul><li>线程池发生改变，继续外循环，重新校验线程池状态；</li><li>线程池未发生改变，继续内循环尝试增加工作线程的个数；</li></ul></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 内部自旋，主要是为了增加线程的个数</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 假如当前线程池的线程个数已经达到了 CAPACITY 或者根据 core 变量校验线程个数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">&gt;=</span> <span class="token constant">CAPACITY</span> <span class="token operator">||</span>
        wc <span class="token operator">&gt;=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 线程个数被限制了，返回 false</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// CAS 增加 WorkerCount，增加成功退出外循环 retry</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span> retry<span class="token punctuation">;</span>
    c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Re-read ctl</span>
    <span class="token comment">// 自旋过程中，发现线程池的状态改变了，重新开始外循环，重新校验</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>
        <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>
    <span class="token comment">// else CAS failed due to workerCount change; retry inner loop</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（3）走完上面的步骤后，线程池的工作线程个数已经加 1 成功了，此时需要创建 Worker 线程，并开启线程。假如线程开启失败，则需要调用 addWorkerFailed 方法处理；</p><p>（4）假如线程正常创建并 start 启动成功，则结束方法。否则调用 addWorkerFailed 方法；</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span><span class="token class-name">Worker</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token comment">// 假如worker已经创建了，则移除它</span>
            workers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// worker的数量减1 因为在 addWorker 方法的循环校验阶段就增加了线程个数</span>
        <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们需要知道线程池的状态是<strong>SHUTDOWN时，线程池不接受新的任务，但是会去处理队列中的任务</strong>。这个时候是<strong>允许添加worker，但是不允许再次提交任务</strong>。</p><p><strong>那么什么时候 addWorker 方法会创建线程失败呢？</strong></p><ul><li>当前线程池状态大于 SHUTDOWN 状态，即<strong>STOP、TIDYING、TERMINATED状态</strong>；</li><li>当前线程池状态是 <strong>SHUTDOWN 状态，且参数 firstTask 不为 null</strong>；</li><li>当前线程池状态是 <strong>SHUTDOWN 状态，且参数 firstTask 为 null，且任务队列是空的，也就是没任务</strong>；</li><li>当前线程池的线<strong>程个数超过上限 5亿，基本不可能</strong>；</li><li>当前线程池的<strong>线程个数超过核心线程数或最大线程个数，具体哪一个需要根据参数 core 决定</strong>；</li><li>当前线程池的 ThreadFactory 有问题，创建的线程是 null，或者是工厂中创建线程后立马调用了 start 方法；</li><li>可能发生异常了，通常是 Thread.start() 中发生 OOM 了；</li></ul><h2 id="线程池任务的执行" tabindex="-1"><a class="header-anchor" href="#线程池任务的执行" aria-hidden="true">#</a> 线程池任务的执行</h2><h3 id="runworker-方法" tabindex="-1"><a class="header-anchor" href="#runworker-方法" aria-hidden="true">#</a> runWorker 方法</h3><p>线程创建并启动完成后就会调用 Worker 的 run 方法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 线程执行入口</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以线程运行后，就会调用 ThreadPoolExecutor#runWorker 方法。</p><p>这个方法主要就是执行 firstTask 任务和阻塞队列中的任务。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token class-name">Worker</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span> wt <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Runnable</span> task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>
    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>
    <span class="token comment">/*
     * 因为之前创建 Worker 的时候将 AQS 的 state 初始为 -1，是为了防止线程被中断
     * 而这里 unlock 方法是把 state 重置为 0，exclusiveOwnerThread ==null。
     * 意思就是已经进入到 runWorker 方法中，可以允许中断了
     */</span>
    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// allow interrupts</span>
    <span class="token comment">// 是否是正常退出标志，false 正常退出 true 字面意思突然退出，也就是有异常</span>
    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 执行 firstTask 任务，或者从阻塞队列中获取任务执行</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 设置独占锁 不是可重入锁，为了确保下面的代码不会被同一线程所重入，同时可以做到不同线程可以并发执行</span>
            <span class="token comment">// shutdown 时会判断当前 worker 状态，根据独占锁是否空闲来判断当前 worker 是否正在工作。</span>
            w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 假如线程池的状态 &gt;= STOP 需要保证线程被中断。</span>
            <span class="token comment">// 线程池的状态 &lt; STOP，需要保证线程未被中断。</span>
            <span class="token comment">// 这需要在第二种情况下重新检查，以处理 shutdownNow 争用，同时清除中断状态</span>
            <span class="token comment">// ((当前线程池的状态 &gt;= STOP) || (当前线程是否被中断 &amp;&amp; 当前线程池的状态 &gt;= STOP)) &amp;&amp; 当前线程未被中断</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">STOP</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">STOP</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment">// 中断线程</span>
                wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 执行任务前的逻辑</span>
                <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Throwable</span> thrown <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 执行任务的 run 方法</span>
                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 执行任务后执行的逻辑</span>
                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                <span class="token comment">// beforeExecute，run，afterExecute都可能会抛出异常</span>
                <span class="token comment">// 任务置null 下次循环的时候就会在阻塞队列中拿取下一个任务了</span>
                task <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token comment">// 完成任务+1</span>
                w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token comment">// 释放独占锁</span>
                w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 正常情况下，会继续进行while循环</span>
                <span class="token comment">// 异常情况下，会直接退出循环，直接跳到processWorkerExit，此时completedAbruptly为true</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 走到此处说明 Worker 和队列中都已经没有了任务</span>
        completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// 执行退出 Worker 的逻辑</span>
        <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析下上面这个方法：</p><ul><li>首先调用 unlock 方法，允许线程被中断；</li><li>开启一个 while 循环，执行 firstTask 任务或者阻塞队列中的任务；</li><li>每次执行任务让线程持有独占锁，任务执行完后释放独占锁；</li><li>获取独占锁后，需要校验线程池的状态， <ul><li>假如线程池的状态 &gt;= STOP 需要保证线程被中断；</li><li>假如线程池的状态 &lt; STOP，需要保证线程未被中断；</li></ul></li><li>任务执行前，需要执行钩子方法 ThreadPoolExecutor#beforeExecute，任务执行完后，需要执行钩子方法ThreadPoolExecutor#afterExecute；</li><li>没有任务执行或者发生异常了会退出 while 循环，最后会调用 ThreadPoolExecutor#processWorkerExit 方法退出任务线程。beforeExecute，run，afterExecute 方法都可能会抛出异常，此时入参 completedAbruptly 会是 true；</li></ul><h3 id="获取任务-gettask-方法" tabindex="-1"><a class="header-anchor" href="#获取任务-gettask-方法" aria-hidden="true">#</a> 获取任务 getTask 方法</h3><p>在 ThreadPoolExecutor#runWorker 方法中，通过 ThreadPoolExecutor#getTask 方法从阻塞队列中获取任务执行，当 getTask 方法返回 null 的时候，说明阻塞队列中没有任务了，需要 Worker 执行退出逻辑。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">Runnable</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// Did the last poll() time out?</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/*
         * Check if queue empty only if necessary.
         * 条件1：rs &gt;= SHUTDOWN 线程池的状态不是RUNNING状态
         * 条件2：rs &gt;= STOP || workQueue.isEmpty()
         *     线程池的状态为STOP，TIDYING，TERMINATED
         *  或者 线程池的状态为SHUTDOWN状态且队列中没有任务了
         * 这两种状态已经不需要获取任务了，返回null之后runWorker就退出循环了
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&gt;=</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">&gt;=</span> <span class="token constant">STOP</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 走到这里说明：1-线程池时RUNNING 2-SHUTDOWN但是阻塞队列中还有任务</span>

        <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Are workers subject to culling?</span>
        <span class="token comment">// allowCoreThreadTimeOut 是控制核心线程是否允许超时的</span>
        <span class="token comment">// timed表示当前线程是否允许超时 销毁</span>
        <span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">&gt;</span> corePoolSize<span class="token punctuation">;</span>
        <span class="token comment">/*
         * timedOut 为 true说明不是第一次循环了 上次循环中已经发生了poll的超时
         * 条件一：(wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
         * 1.1：wc &gt; maximumPoolSize  为什么会成立？setMaximumPoolSize()方法，可能外部线程将线程池最大线程数设置为比初始化时的要小
         * 1.2: (timed &amp;&amp; timedOut) 条件成立：前置条件，当前线程使用 poll方式获取task。上一次循环时  使用poll方式获取任务时，超时了
         * 条件一 为true 表示 线程可以被回收，达到回收标准，当确实需要回收时再回收。
         * 条件二：(wc &gt; 1 || workQueue.isEmpty())
         * 2.1: wc &gt; 1  条件成立，说明当前线程池中还有其他线程，当前线程可以直接回收，返回null
         * 2.2: workQueue.isEmpty() 前置条件 wc == 1， 条件成立：说明当前任务队列 已经空了，最后一个线程，也可以放心的退出。
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">&gt;</span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">/*
             * 如果 timed 为true，则通过 poll 方法进行限时拿取
             *（超过 keepAliveTime 时间没有拿取到，就直接返回 null），
             * 否则通过 take 方法进行拿取
             *（如果阻塞队列为空，take 方法在此时就会被阻塞住，也就是本线程会被阻塞住，直到阻塞队列
             * 中有数据了。也就是说如果 timed 为 false 的话，这些工作线程会一直被阻塞在这里）
             */</span>
            <span class="token class-name">Runnable</span> r <span class="token operator">=</span> timed <span class="token operator">?</span>
                workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">NANOSECONDS</span><span class="token punctuation">)</span> <span class="token operator">:</span>
                workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> r<span class="token punctuation">;</span>
            timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析下上面的方法：</p><p>getTask 方法可能会使当前线程阻塞或等待，取决于当前的配置。</p><p>getTask返回 null 是因为当前的 worker 必须退出了，退出的可能情况有下：</p><ul><li>线程池里的线程数量大于 maximumPoolSize 了，这是因为调用了 setMaximumPoolSize 方法；</li><li>线程池在 STOP 状态。此时不会接收新的任务，也不会去执行队列的任务；</li><li>线程池在 SHUTDOWN 状态，且队列中没有任务了。因为此状态不会接收新的任务，假如队列中还有任务的话，还是会去执行队列里的任务；</li><li>Worker 等待任务超时，当前的 worker 必须退出了；</li></ul><p><strong>可以看到 keepAliveTime 就是控制线程从阻塞队列中获取任务的超时时间。</strong></p><h3 id="processworkerexit-方法" tabindex="-1"><a class="header-anchor" href="#processworkerexit-方法" aria-hidden="true">#</a> processWorkerExit 方法</h3><p>当线程在运行时，在获取任务超时或者执行任务的时候发生异常了，需要 Worker 退出，就会调用 processWorkerExit 方法处理。</p><p>这个方法将要退出的线程从 WorkerSet 中移除，并尝试 tryTerminate，在下面几种情况会创建新的 Worker 添加到池中，前提都是当前线程池的状态是 RUNNING 或者 SHUTDOWN。</p><ul><li>当前线程在执行任务时发生异常，需要创建一个新 worker 到线程池；</li><li>!workQueue.isEmpty() 说明任务队列中还有任务，最起码要留一个线程；</li><li>当前线程数量小于 corePoolSize 值，此时会创建线程，维护线程池数量在corePoolSize个；</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processWorkerExit</span><span class="token punctuation">(</span><span class="token class-name">Worker</span> w<span class="token punctuation">,</span> <span class="token keyword">boolean</span> completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>completedAbruptly<span class="token punctuation">)</span> <span class="token comment">// If abrupt, then workerCount wasn&#39;t adjusted</span>
        <span class="token comment">// 如果是发生异常退出循环的，需要减少worker的数量</span>
        <span class="token comment">// 异常退出时，ctl 计数，并没有-1</span>
        <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将单个 worker 完成的任务数量累加到线程池的完成数量</span>
        completedTaskCount <span class="token operator">+=</span> w<span class="token punctuation">.</span>completedTasks<span class="token punctuation">;</span>
        <span class="token comment">/*
         * 把当前 Worker（也就是当前线程）剔除出 workers 集合中，等待GC
         * 要么是空闲的核心线程超时需要被销毁，要么是空闲的非核心线程超时需要被销毁。
         * 不管属于哪一种，当前线程都是要被销毁的
         */</span>
        workers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 尝试将线程池改为Terminate状态</span>
    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 条件成立，说明当前线程池的状态是 RUNNING 或者 SHUTDOWN</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateLessThan</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token constant">STOP</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 条件成立说明，当前线程的退出是正常退出，不是异常</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> min <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> corePoolSize<span class="token punctuation">;</span>
            <span class="token comment">// 此时如果队列里还有任务没执行（可能在执行到此处的时候，又有人提交了任务到队列中了），</span>
            <span class="token comment">// 就使 min=1，因为还需要至少留一个线程去执行task任务</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                min <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token comment">// 假如当前线程池的worker的数量大于等于min，说明线程池的worker数量足够，直接返回</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> min<span class="token punctuation">)</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// replacement not needed</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 此处前置条件：1-线程执行任务发生异常 2-正常执行任务但是workerCountOf(c) &lt; min</span>
        <span class="token comment">// 1.当前线程在执行任务时发生异常，需要创建一个新 worker 到线程池。</span>
        <span class="token comment">// 2.!workQueue.isEmpty() 说明任务队列中还有任务，最起码要留一个线程。 当前状态为 RUNNING || SHUTDOWN</span>
        <span class="token comment">// 3.当前线程数量 &lt; corePoolSize值，此时会创建线程，维护线程池数量在corePoolSize个。</span>
        <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="线程池优雅关闭" tabindex="-1"><a class="header-anchor" href="#线程池优雅关闭" aria-hidden="true">#</a> 线程池优雅关闭</h2><h3 id="shutdown-方法" tabindex="-1"><a class="header-anchor" href="#shutdown-方法" aria-hidden="true">#</a> shutdown 方法</h3><p>关闭线程池时一般调用的是 shutdown 方法，而不是 shutdownNow 方法：</p><p><strong>SHUTDOWN 状态，这个状态不会接受新的任务，但是会去执行队列中的任务</strong>。如果当前的状态已经是 SHUTDOWN状态或者之后的状态，则此次调用，没有什么额外的效果。</p><p>需要注意的是：<strong>此方法不等待先前提交的任务完成执行</strong>。我们可以用 awaitTermination 方法等待之前的任务执行完成。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 检查关闭的权限</span>
        <span class="token function">checkShutdownAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 尝试将线程池的状态改为 SHUTDOWN</span>
        <span class="token function">advanceRunState</span><span class="token punctuation">(</span><span class="token constant">SHUTDOWN</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 中断空闲线程（线程可能在阻塞等待阻塞队列中的任务）</span>
        <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// ScheduledThreadPoolExecutor 的钩子方法</span>
        <span class="token function">onShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hook for ScheduledThreadPoolExecutor</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="shutdownnow-方法" tabindex="-1"><a class="header-anchor" href="#shutdownnow-方法" aria-hidden="true">#</a> shutdownNow 方法</h3><p>**尝试停止所有正在执行的任务，停止处理等待中的任务，返回那些等待执行的任务的集合。**从该方法返回时，这些任务将从任务队列中删除。</p><p>这个方法不会等待正在执行的任务执行完毕。使用 awaitTermination 方法完成的。</p><p>除了尽最大努力尝试停止正在执行的任务之外，没有任何保证。此实现通过 interrupt 取消任务，<strong>因此任何未能响应中断的任务可能永远不会终止</strong>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> <span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> tasks<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 校验关闭线程的权限</span>
        <span class="token function">checkShutdownAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 线程池的状态改为 STOP</span>
        <span class="token function">advanceRunState</span><span class="token punctuation">(</span><span class="token constant">STOP</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 中断所有已经启动的线程</span>
        <span class="token function">interruptWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 导出未处理的任务列表</span>
        tasks <span class="token operator">=</span> <span class="token function">drainQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 根据线程池状态来判断是否应该结束线程池</span>
    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 返回当前任务队列中 未处理的任务。</span>
    <span class="token keyword">return</span> tasks<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>shutdownNow 方法和 shutdown 方法的逻辑大体相同，只是 shutdownNow 方法是将线程池状态改为 STOP，中断所有的 Worker 线程，并将任务队列中剩余未执行的任务返回给调用方法了。</p><h3 id="tryterminate-方法" tabindex="-1"><a class="header-anchor" href="#tryterminate-方法" aria-hidden="true">#</a> tryTerminate 方法</h3><p>在看 awaitTermination 方法之前，需要先看看 tryTerminate 方法。</p><p>tryTerminate 在线程池中有很多地方在调用，这个方法的作用就是尝试将线程池的状态改成 TERMINATED。</p><ul><li><strong>addWorkerFailed(Worker)</strong></li><li><strong>processWorkerExit(Worker, boolean)</strong></li><li>purge()</li><li>remove(Runnable)</li><li><strong>shutdown()</strong></li><li><strong>shutdownNow()</strong></li></ul><p>需要注意的地方：</p><ol><li>当线程池的工作线程的个数是 0 的时候，调用 interruptIdleWorkers 方法中断一个空闲的线程，相当于传播一个关闭的信号。因为这里中断是 getTask 方法中阻塞等待任务的线程，中断后 getTask 返回 null，返回 null 后，就会调用 processWorkerExit 中继续调用 tryTerminate 方法；</li><li>会调用钩子方法 terminated() 方法；</li><li>在线程池的状态被改为 TERMINATED 时，就会调用 Condition 的 await 方法唤醒可能在 方法在awaitTermination() 中阻塞的线程；</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 自旋</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/*
         * 1 当前线程池是RUNNING状态 此时无需结束线程池
         * 2 当前线程池的状态大于等于TIDYING，说明已经有其它线程在执行TIDYING -&gt; TERMINATED状态了，
         *   也就是已经走到了下面的步骤，线程池即将终结，此线程直接返回
         * 3 当前线程池是SHUTDOWN状态且任务队列不为空。说明还有任务需要处理 不能改变线程池状态
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">||</span>
            <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token constant">TIDYING</span><span class="token punctuation">)</span> <span class="token operator">||</span>
            <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token comment">/*
         * 运行到此处前提是
         * 1-线程池的状态为STOP
         * 2-线程池的状态为SHUTDOWN，但是队列为空
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Eligible to terminate</span>
            <span class="token comment">// 中断一个空闲的线程</span>
            <span class="token comment">// 这里中断是 getTask 方法中阻塞等待任务的线程，中断后 getTask 返回 null</span>
            <span class="token comment">// 返回 null 后，就会调用 processWorkerExit 中继续调用 tryTerminate 方法</span>
            <span class="token comment">// 中断一个空闲的线程，相当于传播一个关闭线程池的信号</span>
            <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token constant">ONLY_ONE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 走到这里说明当前工作线程数已经为0了，</span>
        <span class="token comment">// 也就是说当前线程是最后一个执行任务的线程，此时需要完成结束线程池的动作</span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
        mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// CAS 尝试创建 c   是 TIDYING 状态且 workcount 是 0</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token constant">TIDYING</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 终止，钩子方法，子类实现</span>
                    <span class="token function">terminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 设置 TERMINATED 状态且 workcount 是 0</span>
                    ctl<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token constant">TERMINATED</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 唤醒阻塞在termination条件的所有线程，这个变量的await()方法在awaitTermination()中调用</span>
                    termination<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// else retry on failed CAS</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="awaittermination-等待任务完成" tabindex="-1"><a class="header-anchor" href="#awaittermination-等待任务完成" aria-hidden="true">#</a> awaitTermination 等待任务完成</h3><p>该方法调用会被阻塞，直到所有任务执行完毕并且 shutdown 请求被调用，或者参数中定义的 timeout 时间到达或者当前线程被打断，</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 等待线程池的状态是 TERMINATED，才退出阻塞
 * 其实就是等待任务全部完成，具体可在 tryTerminated 方法看到
 */</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">awaitTermination</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 自旋直到线程池的状态是 TERMINATED</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">TERMINATED</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token comment">// 阻塞等待</span>
            nanos <span class="token operator">=</span> termination<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>线程池的核心方法是 execute 方法，控制着工作线程的创建和任务的执行。</p><img src="/assets/26-线程池execute方法流程图-c91af31c.png" alt="26-线程池execute方法流程图1" style="zoom:67%;"><p>关于线程池，我们需要了解的是：</p><ul><li>线程池有那些优点；</li><li>创建线程池的参数的如何设置，例如核心线程池数，最大线程数等；</li><li>线程池的执行流程；</li></ul><p>关于线程池的优点可以看文章的开头。线程池的执行流程可以看上面的图。</p><p>关于线程池的参数，JDK 的注释里面给我们的建议是</p><ul><li>CPU 密集型任务：就是任务需要 CPU 参与大量的计算，参考值可以设置为 NCPU + 1，这样可以避免很多线程在争抢资源；</li><li>IO 密集型任务：就是任务主要时间都消耗在 I/O 时，参考值可以设置为 2 * NCPU；</li></ul></div><!----><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: guosgbin@163.com">Dylan Kwok</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a href="/JDK_source/19-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-AbstractExecutorService.html" class="nav-link prev" aria-label="19-线程池体系-AbstractExecutorService"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->19-线程池体系-AbstractExecutorService</div></a><a href="/JDK_source/21-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ScheduledThreadPoolExecutor.html" class="nav-link next" aria-label="21-线程池体系-ScheduledThreadPoolExecutor"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">21-线程池体系-ScheduledThreadPoolExecutor<!----></div></a></nav><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-2523771a.js" defer></script>
  </body>
</html>
