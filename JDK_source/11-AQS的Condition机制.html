<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.62" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://blog.guosgbin.cn/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html"><meta property="og:title" content="11-AQS的Condition机制"><meta property="og:description" content="版本 内容 时间 ---- ---- ---------------------- V1 新建 2022年09月14日22:50:30 概述 Synchronized 同步锁在同步代码块中可以通过锁对象的 wait 和 notify 方法来实现线程同步。 对于 JUC 中的 Condition 接口，配合 Lock 锁也可以实现线程同步，通过 Cond..."><meta property="og:type" content="article"><meta property="og:image" content="https://blog.guosgbin.cn/"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-05-04T02:26:04.000Z"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="11-AQS的Condition机制"><meta property="article:author" content="超威蓝猫 Dylan Kwok"><meta property="article:modified_time" content="2023-05-04T02:26:04.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"11-AQS的Condition机制","image":["https://blog.guosgbin.cn/"],"dateModified":"2023-05-04T02:26:04.000Z","author":[{"@type":"Person","name":"超威蓝猫 Dylan Kwok","url":"","email":"guosgbin@163.com"}]}</script><link rel="icon" href="/小熊猫.svg"><title>11-AQS的Condition机制</title><meta name="description" content="版本 内容 时间 ---- ---- ---------------------- V1 新建 2022年09月14日22:50:30 概述 Synchronized 同步锁在同步代码块中可以通过锁对象的 wait 和 notify 方法来实现线程同步。 对于 JUC 中的 Condition 接口，配合 Lock 锁也可以实现线程同步，通过 Cond...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-542658da.css" as="style"><link rel="stylesheet" href="/assets/style-542658da.css">
    <link rel="modulepreload" href="/assets/app-0262c20c.js"><link rel="modulepreload" href="/assets/11-AQS的Condition机制.html-836364af.js"><link rel="modulepreload" href="/assets/11-AQS的Condition机制.html-63cd92f0.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-c27b6911.js"><link rel="prefetch" href="/assets/index.html-18305222.js" as="script"><link rel="prefetch" href="/assets/01-创建和销毁对象.html-98280ce1.js" as="script"><link rel="prefetch" href="/assets/index.html-c4f42206.js" as="script"><link rel="prefetch" href="/assets/SPI机制.html-a1ca3921.js" as="script"><link rel="prefetch" href="/assets/01-CAS和Unsafe的API分析.html-612c4d6a.js" as="script"><link rel="prefetch" href="/assets/02-基本类型原子类AtomicLong.html-4083b8fd.js" as="script"><link rel="prefetch" href="/assets/03-引用类型原子类AtomicReference.html-8442553d.js" as="script"><link rel="prefetch" href="/assets/04-原子数组类AtomicLongArray.html-74e4c741.js" as="script"><link rel="prefetch" href="/assets/05-原子操作类AtomicReferenceFieldUpdater.html-d0310b2a.js" as="script"><link rel="prefetch" href="/assets/06-高性能原子类LongAdder.html-d6e3da8b.js" as="script"><link rel="prefetch" href="/assets/07-LockSupport分析.html-8117dd17.js" as="script"><link rel="prefetch" href="/assets/08-AQS简单介绍.html-30b6ef5b.js" as="script"><link rel="prefetch" href="/assets/09-基于ReentrantLock分析AQS的独占模式.html-2423c430.js" as="script"><link rel="prefetch" href="/assets/10-基于CountDownLatch分析AQS的共享模式.html-91ef4833.js" as="script"><link rel="prefetch" href="/assets/12-信号量Semaphore.html-3509682c.js" as="script"><link rel="prefetch" href="/assets/13-循环栏栅CyclicBarrier.html-812d137d.js" as="script"><link rel="prefetch" href="/assets/14-阶段Phaser.html-d684f4a1.js" as="script"><link rel="prefetch" href="/assets/15-交换Exchanger.html-b9bf24f3.js" as="script"><link rel="prefetch" href="/assets/16-读写锁ReentrantReadWriteLock.html-de44a1d3.js" as="script"><link rel="prefetch" href="/assets/17-Future模式-FutureTask.html-641c6250.js" as="script"><link rel="prefetch" href="/assets/18-线程池体系概述.html-dbcc52e5.js" as="script"><link rel="prefetch" href="/assets/19-线程池体系-AbstractExecutorService.html-fbd70afb.js" as="script"><link rel="prefetch" href="/assets/20-线程池体系-ThreadPoolExecutor.html-a274637a.js" as="script"><link rel="prefetch" href="/assets/21-线程池体系-ScheduledThreadPoolExecutor.html-707ffd40.js" as="script"><link rel="prefetch" href="/assets/22-CopyOnWriteArrayList写时复制.html-914977b9.js" as="script"><link rel="prefetch" href="/assets/23-CopyOnWriteArraySet写时复制.html-6c9c3cf6.js" as="script"><link rel="prefetch" href="/assets/24-ConcurrentSkipListMap跳表.html-6cff54bf.js" as="script"><link rel="prefetch" href="/assets/25-ConcurrentSkipListSet跳表.html-36cf4f7d.js" as="script"><link rel="prefetch" href="/assets/26-ConcurrentHashMap源码分析.html-a3bba8a9.js" as="script"><link rel="prefetch" href="/assets/27-阻塞队列ArrayBlockingQueue.html-cd091357.js" as="script"><link rel="prefetch" href="/assets/28-阻塞队列LinkedBlockingQueue.html-d3579ee7.js" as="script"><link rel="prefetch" href="/assets/29-阻塞队列LinkedBlockingDeque.html-32c13680.js" as="script"><link rel="prefetch" href="/assets/30-阻塞队列PriorityBlockingQueue.html-b5455c77.js" as="script"><link rel="prefetch" href="/assets/31-阻塞队列DelayQueue.html-7759c195.js" as="script"><link rel="prefetch" href="/assets/32-阻塞队列SynchronousQueue.html-97ed879a.js" as="script"><link rel="prefetch" href="/assets/33-阻塞队列LinkedTransferQueue.html-3281c1b4.js" as="script"><link rel="prefetch" href="/assets/index.html-f5239cf3.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis01：myabtis的整体架构.html-f25c0705.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis02：入门案例.html-30e68cd3.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis03：解析全局配置文件.html-2db85266.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis04：解析Mapper映射文件.html-60756a5b.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis05：解析Statement操作节点.html-31e11b60.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis06：解析SQL语句.html-a9181b56.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis07：Java方法和SQL语句绑定.html-9bfa3db6.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis08：获得SqlSession.html-e2a92940.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis09：Executor执行器.html-ad701715.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis10：缓存机制.html-f2daa10c.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis11：StatementHandler.html-95b30d9b.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis12：参数解析和赋值.html-5778c0ea.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis13：结果集处理.html-2ff72779.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis14：插件.html-76cc6bf8.js" as="script"><link rel="prefetch" href="/assets/01-服务端启动流程.html-d2fc1f19.js" as="script"><link rel="prefetch" href="/assets/02-服务端启动添加ChannelInitializer到管道.html-86cb5d6a.js" as="script"><link rel="prefetch" href="/assets/03-客户端启动流程.html-becc83be.js" as="script"><link rel="prefetch" href="/assets/04-线程体系-NioEventLoopGroup.html-700e797e.js" as="script"><link rel="prefetch" href="/assets/05-线程体系-NioEventLoop相关父接口分析.html-754320bc.js" as="script"><link rel="prefetch" href="/assets/06-线程体系-AbstractEventExecutor.html-5250cd42.js" as="script"><link rel="prefetch" href="/assets/07-线程体系-AbstractScheduledEventExecutor-优先队列.html-e7bbaf32.js" as="script"><link rel="prefetch" href="/assets/08-线程体系-NioEventLoop概述.html-fce3fb2c.js" as="script"><link rel="prefetch" href="/assets/09-线程体系-NioEventLoop开启Selector及优化.html-6d8230cf.js" as="script"><link rel="prefetch" href="/assets/10-线程体系-NioEventLoop绑定线程.html-db947821.js" as="script"><link rel="prefetch" href="/assets/11-线程体系-NioEventLoop的run方法.html-def4cc31.js" as="script"><link rel="prefetch" href="/assets/12-线程体系-NioEventLoop规避JDK的NIO空循环bug.html-16ecaf4e.js" as="script"><link rel="prefetch" href="/assets/13-线程体系-NioEventLoop的优雅关闭.html-912d668d.js" as="script"><link rel="prefetch" href="/assets/14-服务端处理客户端的连接(ACCEPT).html-63afdec1.js" as="script"><link rel="prefetch" href="/assets/15-客户端处理READ事件概述.html-b35daeb8.js" as="script"><link rel="prefetch" href="/assets/16-客户端处理READ事件详解及RecvByteBufAllocator.html-a9faccfa.js" as="script"><link rel="prefetch" href="/assets/17-Netty管道机制.html-ba70b238.js" as="script"><link rel="prefetch" href="/assets/18-Netty发送数据流程及出站缓冲区.html-223d04a7.js" as="script"><link rel="prefetch" href="/assets/index.html-b475d8b0.js" as="script"><link rel="prefetch" href="/assets/Redis_Benchmark基准测试.html-dbf21951.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群和槽管理命令.html-2b4a1244.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群基本特性和集群搭建.html-42be726b.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群管理工具redis-cli.html-fc4f1503.js" as="script"><link rel="prefetch" href="/assets/Redis_Pipeline优化RTT.html-8a4aa041.js" as="script"><link rel="prefetch" href="/assets/Redis_Sentinel高可用.html-6bcdb34a.js" as="script"><link rel="prefetch" href="/assets/Redis_key设计规范.html-ab90a7dc.js" as="script"><link rel="prefetch" href="/assets/Redis事务.html-e43061e1.js" as="script"><link rel="prefetch" href="/assets/Redis内存淘汰策略.html-feabd314.js" as="script"><link rel="prefetch" href="/assets/Redis发布订阅.html-68771977.js" as="script"><link rel="prefetch" href="/assets/Redis复制.html-33b20d6f.js" as="script"><link rel="prefetch" href="/assets/Redis大key和热key问题.html-394d194e.js" as="script"><link rel="prefetch" href="/assets/Redis慢查询日志.html-7fb06db0.js" as="script"><link rel="prefetch" href="/assets/Redis持久化机制.html-53af3f7a.js" as="script"><link rel="prefetch" href="/assets/Redis键空间通知(keyspace notification).html-012bd277.js" as="script"><link rel="prefetch" href="/assets/redis-cli 使用.html-f7ab22db.js" as="script"><link rel="prefetch" href="/assets/01-RocketMQ概述.html-25463efe.js" as="script"><link rel="prefetch" href="/assets/02-NameServer启动流程.html-a514999f.js" as="script"><link rel="prefetch" href="/assets/03-Broker启动流程.html-43c84806.js" as="script"><link rel="prefetch" href="/assets/04-RocketMQ网络通信原理.html-ac88de8d.js" as="script"><link rel="prefetch" href="/assets/05-RocketMQ 服务端和客户端的启动.html-ef7f1888.js" as="script"><link rel="prefetch" href="/assets/06-RocketMQ网络通信源码.html-b8e0bf43.js" as="script"><link rel="prefetch" href="/assets/07-NameServer作用和路由元信息.html-82a23869.js" as="script"><link rel="prefetch" href="/assets/08-NameServer路由管理源码分析.html-8da2bd72.js" as="script"><link rel="prefetch" href="/assets/09-生产者相关类分析.html-08f6e840.js" as="script"><link rel="prefetch" href="/assets/10-生产者启动流程.html-d761cf07.js" as="script"><link rel="prefetch" href="/assets/11-生产者发送消息.html-743328bc.js" as="script"><link rel="prefetch" href="/assets/12-Broker存储机制概述.html-5e7ed491.js" as="script"><link rel="prefetch" href="/assets/13-MappedFile和MappedFileQueue分析.html-5b9afaf2.js" as="script"><link rel="prefetch" href="/assets/14-CommitLog原理分析.html-93362aa2.js" as="script"><link rel="prefetch" href="/assets/15-broker的刷盘机制.html-21e2029f.js" as="script"><link rel="prefetch" href="/assets/16-ConsumeQueue和Index原理分析.html-ff18bade.js" as="script"><link rel="prefetch" href="/assets/17-broker过期文件删除机制.html-89f05919.js" as="script"><link rel="prefetch" href="/assets/18-消费者启动流程(TODO).html-988c43b3.js" as="script"><link rel="prefetch" href="/assets/19-消息拉取入口和消息队列负载均衡.html-7e4e20d4.js" as="script"><link rel="prefetch" href="/assets/20-消费者发送消息拉取请求流程.html-19825069.js" as="script"><link rel="prefetch" href="/assets/21-broker处理消息拉取请求-1-主流程.html-d9ca6fa4.js" as="script"><link rel="prefetch" href="/assets/22-broker处理消息拉取请求-2-长轮询.html-0aba4f38.js" as="script"><link rel="prefetch" href="/assets/23-broker处理消息拉取请求-3-读取消息.html-729d741b.js" as="script"><link rel="prefetch" href="/assets/24-消费者处理从broker拉取的消息.html-dcfb7d07.js" as="script"><link rel="prefetch" href="/assets/25-并发消费原理.html-5ef206ec.js" as="script"><link rel="prefetch" href="/assets/JUC相关问题.html-9dc4b717.js" as="script"><link rel="prefetch" href="/assets/index.html-8f5e683a.js" as="script"><link rel="prefetch" href="/assets/HowToSayResume.html-11d8bbca.js" as="script"><link rel="prefetch" href="/assets/resume.html-3b3f8934.js" as="script"><link rel="prefetch" href="/assets/404.html-f3795607.js" as="script"><link rel="prefetch" href="/assets/index.html-1f3390c0.js" as="script"><link rel="prefetch" href="/assets/index.html-10b45510.js" as="script"><link rel="prefetch" href="/assets/index.html-dfd17ea5.js" as="script"><link rel="prefetch" href="/assets/index.html-2f392b9e.js" as="script"><link rel="prefetch" href="/assets/index.html-0efbdc5e.js" as="script"><link rel="prefetch" href="/assets/index.html-b282f468.js" as="script"><link rel="prefetch" href="/assets/01-创建和销毁对象.html-5d498d8f.js" as="script"><link rel="prefetch" href="/assets/index.html-29c2b931.js" as="script"><link rel="prefetch" href="/assets/SPI机制.html-ff5f4483.js" as="script"><link rel="prefetch" href="/assets/01-CAS和Unsafe的API分析.html-580b37e3.js" as="script"><link rel="prefetch" href="/assets/02-基本类型原子类AtomicLong.html-26412115.js" as="script"><link rel="prefetch" href="/assets/03-引用类型原子类AtomicReference.html-7e8fe23f.js" as="script"><link rel="prefetch" href="/assets/04-原子数组类AtomicLongArray.html-06d74730.js" as="script"><link rel="prefetch" href="/assets/05-原子操作类AtomicReferenceFieldUpdater.html-6a586b6b.js" as="script"><link rel="prefetch" href="/assets/06-高性能原子类LongAdder.html-2c688ebf.js" as="script"><link rel="prefetch" href="/assets/07-LockSupport分析.html-28862160.js" as="script"><link rel="prefetch" href="/assets/08-AQS简单介绍.html-2751d080.js" as="script"><link rel="prefetch" href="/assets/09-基于ReentrantLock分析AQS的独占模式.html-a01a3271.js" as="script"><link rel="prefetch" href="/assets/10-基于CountDownLatch分析AQS的共享模式.html-1f3d2de8.js" as="script"><link rel="prefetch" href="/assets/12-信号量Semaphore.html-630164a5.js" as="script"><link rel="prefetch" href="/assets/13-循环栏栅CyclicBarrier.html-f126cb2d.js" as="script"><link rel="prefetch" href="/assets/14-阶段Phaser.html-f7fa7885.js" as="script"><link rel="prefetch" href="/assets/15-交换Exchanger.html-92e848a9.js" as="script"><link rel="prefetch" href="/assets/16-读写锁ReentrantReadWriteLock.html-69e351a4.js" as="script"><link rel="prefetch" href="/assets/17-Future模式-FutureTask.html-ef310293.js" as="script"><link rel="prefetch" href="/assets/18-线程池体系概述.html-7534cdfd.js" as="script"><link rel="prefetch" href="/assets/19-线程池体系-AbstractExecutorService.html-fc0a000d.js" as="script"><link rel="prefetch" href="/assets/20-线程池体系-ThreadPoolExecutor.html-818a63b3.js" as="script"><link rel="prefetch" href="/assets/21-线程池体系-ScheduledThreadPoolExecutor.html-cfba9db8.js" as="script"><link rel="prefetch" href="/assets/22-CopyOnWriteArrayList写时复制.html-8b4453a7.js" as="script"><link rel="prefetch" href="/assets/23-CopyOnWriteArraySet写时复制.html-1d0df573.js" as="script"><link rel="prefetch" href="/assets/24-ConcurrentSkipListMap跳表.html-16dc3933.js" as="script"><link rel="prefetch" href="/assets/25-ConcurrentSkipListSet跳表.html-525da6fa.js" as="script"><link rel="prefetch" href="/assets/26-ConcurrentHashMap源码分析.html-37e7186f.js" as="script"><link rel="prefetch" href="/assets/27-阻塞队列ArrayBlockingQueue.html-88565cb6.js" as="script"><link rel="prefetch" href="/assets/28-阻塞队列LinkedBlockingQueue.html-b6eb451a.js" as="script"><link rel="prefetch" href="/assets/29-阻塞队列LinkedBlockingDeque.html-f4989ac8.js" as="script"><link rel="prefetch" href="/assets/30-阻塞队列PriorityBlockingQueue.html-489904b6.js" as="script"><link rel="prefetch" href="/assets/31-阻塞队列DelayQueue.html-d32bb70d.js" as="script"><link rel="prefetch" href="/assets/32-阻塞队列SynchronousQueue.html-01321dea.js" as="script"><link rel="prefetch" href="/assets/33-阻塞队列LinkedTransferQueue.html-ee724298.js" as="script"><link rel="prefetch" href="/assets/index.html-559a0b08.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis01：myabtis的整体架构.html-b4a28204.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis02：入门案例.html-bfaa03c6.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis03：解析全局配置文件.html-398e1d03.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis04：解析Mapper映射文件.html-1ae72bd1.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis05：解析Statement操作节点.html-0fd20e80.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis06：解析SQL语句.html-069ab5be.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis07：Java方法和SQL语句绑定.html-68d0b9b2.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis08：获得SqlSession.html-b93c1d99.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis09：Executor执行器.html-0251e8fc.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis10：缓存机制.html-f62e6d62.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis11：StatementHandler.html-c724d821.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis12：参数解析和赋值.html-7dbdc929.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis13：结果集处理.html-492cea85.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis14：插件.html-5ef58ff7.js" as="script"><link rel="prefetch" href="/assets/01-服务端启动流程.html-6ccb9793.js" as="script"><link rel="prefetch" href="/assets/02-服务端启动添加ChannelInitializer到管道.html-daa8e76b.js" as="script"><link rel="prefetch" href="/assets/03-客户端启动流程.html-cb51b8a9.js" as="script"><link rel="prefetch" href="/assets/04-线程体系-NioEventLoopGroup.html-33d259ac.js" as="script"><link rel="prefetch" href="/assets/05-线程体系-NioEventLoop相关父接口分析.html-dce9cd38.js" as="script"><link rel="prefetch" href="/assets/06-线程体系-AbstractEventExecutor.html-0f28c505.js" as="script"><link rel="prefetch" href="/assets/07-线程体系-AbstractScheduledEventExecutor-优先队列.html-dfb9f1bd.js" as="script"><link rel="prefetch" href="/assets/08-线程体系-NioEventLoop概述.html-ab8a8c06.js" as="script"><link rel="prefetch" href="/assets/09-线程体系-NioEventLoop开启Selector及优化.html-679941d4.js" as="script"><link rel="prefetch" href="/assets/10-线程体系-NioEventLoop绑定线程.html-f0aed49b.js" as="script"><link rel="prefetch" href="/assets/11-线程体系-NioEventLoop的run方法.html-72afff85.js" as="script"><link rel="prefetch" href="/assets/12-线程体系-NioEventLoop规避JDK的NIO空循环bug.html-01c8bca9.js" as="script"><link rel="prefetch" href="/assets/13-线程体系-NioEventLoop的优雅关闭.html-4b1cf167.js" as="script"><link rel="prefetch" href="/assets/14-服务端处理客户端的连接(ACCEPT).html-99087da9.js" as="script"><link rel="prefetch" href="/assets/15-客户端处理READ事件概述.html-076042be.js" as="script"><link rel="prefetch" href="/assets/16-客户端处理READ事件详解及RecvByteBufAllocator.html-c36f9a99.js" as="script"><link rel="prefetch" href="/assets/17-Netty管道机制.html-edfd6d68.js" as="script"><link rel="prefetch" href="/assets/18-Netty发送数据流程及出站缓冲区.html-2dfccf9b.js" as="script"><link rel="prefetch" href="/assets/index.html-b3a0ade1.js" as="script"><link rel="prefetch" href="/assets/Redis_Benchmark基准测试.html-e5e86c7d.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群和槽管理命令.html-18cd68ca.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群基本特性和集群搭建.html-d88777c7.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群管理工具redis-cli.html-92228526.js" as="script"><link rel="prefetch" href="/assets/Redis_Pipeline优化RTT.html-6a632594.js" as="script"><link rel="prefetch" href="/assets/Redis_Sentinel高可用.html-91c04722.js" as="script"><link rel="prefetch" href="/assets/Redis_key设计规范.html-f8b59902.js" as="script"><link rel="prefetch" href="/assets/Redis事务.html-61fbd588.js" as="script"><link rel="prefetch" href="/assets/Redis内存淘汰策略.html-f481a734.js" as="script"><link rel="prefetch" href="/assets/Redis发布订阅.html-25d39845.js" as="script"><link rel="prefetch" href="/assets/Redis复制.html-115841bc.js" as="script"><link rel="prefetch" href="/assets/Redis大key和热key问题.html-30588184.js" as="script"><link rel="prefetch" href="/assets/Redis慢查询日志.html-bf68d34b.js" as="script"><link rel="prefetch" href="/assets/Redis持久化机制.html-f573b755.js" as="script"><link rel="prefetch" href="/assets/Redis键空间通知(keyspace notification).html-adefcf64.js" as="script"><link rel="prefetch" href="/assets/redis-cli 使用.html-3955a086.js" as="script"><link rel="prefetch" href="/assets/01-RocketMQ概述.html-ded97431.js" as="script"><link rel="prefetch" href="/assets/02-NameServer启动流程.html-2efe761b.js" as="script"><link rel="prefetch" href="/assets/03-Broker启动流程.html-0130bc71.js" as="script"><link rel="prefetch" href="/assets/04-RocketMQ网络通信原理.html-ff4009c7.js" as="script"><link rel="prefetch" href="/assets/05-RocketMQ 服务端和客户端的启动.html-b44c3fb2.js" as="script"><link rel="prefetch" href="/assets/06-RocketMQ网络通信源码.html-02fdf3d4.js" as="script"><link rel="prefetch" href="/assets/07-NameServer作用和路由元信息.html-4972bb98.js" as="script"><link rel="prefetch" href="/assets/08-NameServer路由管理源码分析.html-d84ed8e6.js" as="script"><link rel="prefetch" href="/assets/09-生产者相关类分析.html-301f2587.js" as="script"><link rel="prefetch" href="/assets/10-生产者启动流程.html-eb36da0c.js" as="script"><link rel="prefetch" href="/assets/11-生产者发送消息.html-b7c924e1.js" as="script"><link rel="prefetch" href="/assets/12-Broker存储机制概述.html-a1f659b4.js" as="script"><link rel="prefetch" href="/assets/13-MappedFile和MappedFileQueue分析.html-469d9861.js" as="script"><link rel="prefetch" href="/assets/14-CommitLog原理分析.html-bba103fa.js" as="script"><link rel="prefetch" href="/assets/15-broker的刷盘机制.html-920642b2.js" as="script"><link rel="prefetch" href="/assets/16-ConsumeQueue和Index原理分析.html-61bd3a36.js" as="script"><link rel="prefetch" href="/assets/17-broker过期文件删除机制.html-48ee44a8.js" as="script"><link rel="prefetch" href="/assets/18-消费者启动流程(TODO).html-99f22d04.js" as="script"><link rel="prefetch" href="/assets/19-消息拉取入口和消息队列负载均衡.html-edafeba0.js" as="script"><link rel="prefetch" href="/assets/20-消费者发送消息拉取请求流程.html-ddf71906.js" as="script"><link rel="prefetch" href="/assets/21-broker处理消息拉取请求-1-主流程.html-0db6ef39.js" as="script"><link rel="prefetch" href="/assets/22-broker处理消息拉取请求-2-长轮询.html-6fe411b2.js" as="script"><link rel="prefetch" href="/assets/23-broker处理消息拉取请求-3-读取消息.html-f68fdbed.js" as="script"><link rel="prefetch" href="/assets/24-消费者处理从broker拉取的消息.html-b4476210.js" as="script"><link rel="prefetch" href="/assets/25-并发消费原理.html-be95ce3f.js" as="script"><link rel="prefetch" href="/assets/JUC相关问题.html-8860e766.js" as="script"><link rel="prefetch" href="/assets/index.html-86c16254.js" as="script"><link rel="prefetch" href="/assets/HowToSayResume.html-c7d54e74.js" as="script"><link rel="prefetch" href="/assets/resume.html-d0cebefd.js" as="script"><link rel="prefetch" href="/assets/404.html-c2265374.js" as="script"><link rel="prefetch" href="/assets/index.html-d81a9533.js" as="script"><link rel="prefetch" href="/assets/index.html-2a73a6d7.js" as="script"><link rel="prefetch" href="/assets/index.html-63a8d443.js" as="script"><link rel="prefetch" href="/assets/index.html-26fcb60a.js" as="script"><link rel="prefetch" href="/assets/index.html-b56ba0e0.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-2450701e.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a href="/" class="vp-brand"><img class="vp-nav-logo" src="/小熊猫.png" alt><!----><!----></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><!----><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><!----><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><!--[--><a href="/JDK_source/" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="JUC包源码分析"><!---->JUC包源码分析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/01-CAS%E5%92%8CUnsafe%E7%9A%84API%E5%88%86%E6%9E%90.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="01-CAS和Unsafe的API分析"><!---->01-CAS和Unsafe的API分析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/02-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicLong.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="02-基本类型原子类AtomicLong"><!---->02-基本类型原子类AtomicLong<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/03-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicReference.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="03-引用类型原子类AtomicReference"><!---->03-引用类型原子类AtomicReference<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/04-%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84%E7%B1%BBAtomicLongArray.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="04-原子数组类AtomicLongArray"><!---->04-原子数组类AtomicLongArray<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/05-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BBAtomicReferenceFieldUpdater.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="05-原子操作类AtomicReferenceFieldUpdater"><!---->05-原子操作类AtomicReferenceFieldUpdater<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/06-%E9%AB%98%E6%80%A7%E8%83%BD%E5%8E%9F%E5%AD%90%E7%B1%BBLongAdder.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="06-高性能原子类LongAdder"><!---->06-高性能原子类LongAdder<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/07-LockSupport%E5%88%86%E6%9E%90.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="07-LockSupport分析"><!---->07-LockSupport分析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/08-AQS%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="08-AQS简单介绍"><!---->08-AQS简单介绍<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/09-%E5%9F%BA%E4%BA%8EReentrantLock%E5%88%86%E6%9E%90AQS%E7%9A%84%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="09-基于ReentrantLock分析AQS的独占模式"><!---->09-基于ReentrantLock分析AQS的独占模式<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/10-%E5%9F%BA%E4%BA%8ECountDownLatch%E5%88%86%E6%9E%90AQS%E7%9A%84%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="10-基于CountDownLatch分析AQS的共享模式"><!---->10-基于CountDownLatch分析AQS的共享模式<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html" class="router-link-active router-link-exact-active nav-link active vp-sidebar-link vp-sidebar-page active" aria-label="11-AQS的Condition机制"><!---->11-AQS的Condition机制<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#概述" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="概述"><!---->概述<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#condition-接口介绍" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="Condition 接口介绍"><!---->Condition 接口介绍<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#condition-官方案例" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="Condition 官方案例"><!---->Condition 官方案例<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#condition-源码分析" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="Condition 源码分析"><!---->Condition 源码分析<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#conditionobject-的创建" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="ConditionObject 的创建"><!---->ConditionObject 的创建<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#条件队列介绍" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="条件队列介绍"><!---->条件队列介绍<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#conditionobject-的属性" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="ConditionObject 的属性"><!---->ConditionObject 的属性<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#await-方法阻塞前代码分析" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="await 方法阻塞前代码分析"><!---->await 方法阻塞前代码分析<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#signal-唤醒线程" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="signal 唤醒线程"><!---->signal 唤醒线程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#await-方法里被唤醒后的代码分析" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="await 方法里被唤醒后的代码分析"><!---->await 方法里被唤醒后的代码分析<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#小结" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="小结"><!---->小结<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/JDK_source/12-%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="12-信号量Semaphore"><!---->12-信号量Semaphore<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/13-%E5%BE%AA%E7%8E%AF%E6%A0%8F%E6%A0%85CyclicBarrier.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="13-循环栏栅CyclicBarrier"><!---->13-循环栏栅CyclicBarrier<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/14-%E9%98%B6%E6%AE%B5Phaser.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="14-阶段Phaser"><!---->14-阶段Phaser<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/15-%E4%BA%A4%E6%8D%A2Exchanger.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="15-交换Exchanger"><!---->15-交换Exchanger<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="16-读写锁ReentrantReadWriteLock"><!---->16-读写锁ReentrantReadWriteLock<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/17-Future%E6%A8%A1%E5%BC%8F-FutureTask.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="17-Future模式-FutureTask"><!---->17-Future模式-FutureTask<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/18-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB%E6%A6%82%E8%BF%B0.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="18-线程池体系概述"><!---->18-线程池体系概述<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/19-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-AbstractExecutorService.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="19-线程池体系-AbstractExecutorService"><!---->19-线程池体系-AbstractExecutorService<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="20-线程池体系-ThreadPoolExecutor"><!---->20-线程池体系-ThreadPoolExecutor<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/21-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ScheduledThreadPoolExecutor.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="21-线程池体系-ScheduledThreadPoolExecutor"><!---->21-线程池体系-ScheduledThreadPoolExecutor<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/22-CopyOnWriteArrayList%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="22-CopyOnWriteArrayList写时复制"><!---->22-CopyOnWriteArrayList写时复制<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/23-CopyOnWriteArraySet%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="23-CopyOnWriteArraySet写时复制"><!---->23-CopyOnWriteArraySet写时复制<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/24-ConcurrentSkipListMap%E8%B7%B3%E8%A1%A8.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="24-ConcurrentSkipListMap跳表"><!---->24-ConcurrentSkipListMap跳表<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/25-ConcurrentSkipListSet%E8%B7%B3%E8%A1%A8.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="25-ConcurrentSkipListSet跳表"><!---->25-ConcurrentSkipListSet跳表<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="26-ConcurrentHashMap源码分析"><!---->26-ConcurrentHashMap源码分析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/27-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97ArrayBlockingQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="27-阻塞队列ArrayBlockingQueue"><!---->27-阻塞队列ArrayBlockingQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/28-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97LinkedBlockingQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="28-阻塞队列LinkedBlockingQueue"><!---->28-阻塞队列LinkedBlockingQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/29-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97LinkedBlockingDeque.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="29-阻塞队列LinkedBlockingDeque"><!---->29-阻塞队列LinkedBlockingDeque<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/30-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97PriorityBlockingQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="30-阻塞队列PriorityBlockingQueue"><!---->30-阻塞队列PriorityBlockingQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/31-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97DelayQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="31-阻塞队列DelayQueue"><!---->31-阻塞队列DelayQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/32-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97SynchronousQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="32-阻塞队列SynchronousQueue"><!---->32-阻塞队列SynchronousQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/33-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97LinkedTransferQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="33-阻塞队列LinkedTransferQueue"><!---->33-阻塞队列LinkedTransferQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->11-AQS的Condition机制</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="page-author-item">超威蓝猫 Dylan Kwok</span></span><span property="author" content="超威蓝猫 Dylan Kwok"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-05-04T02:26:04.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 12 分钟</span><meta property="timeRequired" content="PT12M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#概述" class="router-link-active router-link-exact-active toc-link level2">概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#condition-接口介绍" class="router-link-active router-link-exact-active toc-link level2">Condition 接口介绍</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#condition-官方案例" class="router-link-active router-link-exact-active toc-link level2">Condition 官方案例</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#condition-源码分析" class="router-link-active router-link-exact-active toc-link level2">Condition 源码分析</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#conditionobject-的创建" class="router-link-active router-link-exact-active toc-link level3">ConditionObject 的创建</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#条件队列介绍" class="router-link-active router-link-exact-active toc-link level3">条件队列介绍</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#conditionobject-的属性" class="router-link-active router-link-exact-active toc-link level3">ConditionObject 的属性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#await-方法阻塞前代码分析" class="router-link-active router-link-exact-active toc-link level3">await 方法阻塞前代码分析</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#signal-唤醒线程" class="router-link-active router-link-exact-active toc-link level3">signal 唤醒线程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#await-方法里被唤醒后的代码分析" class="router-link-active router-link-exact-active toc-link level3">await 方法里被唤醒后的代码分析</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html#小结" class="router-link-active router-link-exact-active toc-link level2">小结</a></li><!----><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><table><thead><tr><th>版本</th><th>内容</th><th>时间</th></tr></thead><tbody><tr><td>V1</td><td>新建</td><td>2022年09月14日22:50:30</td></tr></tbody></table><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>Synchronized 同步锁在同步代码块中可以通过锁对象的 wait 和 notify 方法来实现线程同步。</p><p>对于 JUC 中的 Condition 接口，配合 Lock 锁也可以实现线程同步，通过 Condition 接口中的 await 和 signal 方法实现。</p><p>一个 Synchronized 锁只能有一个共享的变量锁对象的 wait 和 notify 来实现线程同步，而一个 Lock 锁可配合多个 Condition 实例使用。</p><p>Condition 必须和 Lock 配合使用，这和 Synchronized 的使用要求是一样的。</p><blockquote><p>注意：Condition 就是一个普通的对象，它也是可以配合 Synchronized 使用的，例如把它当成一个锁对象，但是防止混淆最好不要这样做。</p></blockquote><h2 id="condition-接口介绍" tabindex="-1"><a class="header-anchor" href="#condition-接口介绍" aria-hidden="true">#</a> Condition 接口介绍</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Condition</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">awaitUninterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token function">awaitNanos</span><span class="token punctuation">(</span><span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> <span class="token function">awaitUntil</span><span class="token punctuation">(</span><span class="token class-name">Date</span> deadline<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提供的 api 分为两类，一种是阻塞线程的，另外是唤醒线程的。</p><ul><li>提供的阻塞线程的 await 系列方法，支持中断和超时机制；</li><li>唤醒方法支持唤醒一个和所有；</li></ul><h2 id="condition-官方案例" tabindex="-1"><a class="header-anchor" href="#condition-官方案例" aria-hidden="true">#</a> Condition 官方案例</h2><p>SimpleBlockingQueue 是一个支持 put 和 take 方法的有界缓冲区。如果在空缓冲区上调用 take 方法，则线程将阻塞直到缓冲区中有数据；如果在缓冲区满了的时候调用 put 放，则线程将阻塞直到缓冲区未满。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">BlockingQueue</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Condition</span> notFull <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Condition</span> notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 队列大小</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>

    <span class="token comment">// 底层数组</span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> queues<span class="token punctuation">;</span>

    <span class="token comment">// 当前队列中的数据量</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>

    <span class="token comment">// 记录生产者存放数据的下一次位置，每个生产者生产完一个数据后，将 putPtr++</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> putPtr<span class="token punctuation">;</span>

    <span class="token comment">// 记录消费者消费数据的下一次位置，每个消费者消费完一个数据后，将 takePtr++</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> takePtr<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">SimpleBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>queues <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Object</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 队列是满的，需要睡眠，等待消费者去唤醒</span>
                notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            queues<span class="token punctuation">[</span>putPtr<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
            putPtr<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>putPtr <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                putPtr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token comment">// 这里因为添加了一个数据，需要唤醒消费者线程</span>
            notEmpty<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 队列是空的，需要睡眠，等待生产者去唤醒</span>
                notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token class-name">Object</span> element <span class="token operator">=</span> queues<span class="token punctuation">[</span>takePtr<span class="token punctuation">]</span><span class="token punctuation">;</span>
            takePtr<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>takePtr <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                takePtr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            count<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token comment">// 这里因为添加了一个数据，需要唤醒消费者线程</span>
            notFull<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> element<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="condition-源码分析" tabindex="-1"><a class="header-anchor" href="#condition-源码分析" aria-hidden="true">#</a> Condition 源码分析</h2><p>AQS 的内部类 ConditionObject 实现了 Condition 接口，本次也是主要分析这个实现类。</p><h3 id="conditionobject-的创建" tabindex="-1"><a class="header-anchor" href="#conditionobject-的创建" aria-hidden="true">#</a> ConditionObject 的创建</h3><p>Condition 的创建是通过 Lock#newCondition 创建的，看下 ReentrantLock 中的实现：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>继续跟下去：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">ConditionObject</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConditionObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，就是 new 了一个 ConditionObject 对象出来。</p><h3 id="条件队列介绍" tabindex="-1"><a class="header-anchor" href="#条件队列介绍" aria-hidden="true">#</a> 条件队列介绍</h3><p>在 AbstractQueuedSynchronizer.Node 的属性中有个 nextWaiter 属性前面没有分析过，这个 nextWaiter 的含义是指向条件队列中当前节点的后驱节点。</p><p>条件队列是一个单向链表，通过 nextWaiter 连接。</p><p>当我们调用 await 方法后，当前线程就会被封装成一个节点加入到条件队列中去。因为 Lock 可以配合多个 Condition 使用，每个 Condition 都有自己的条件队列。</p><p>当调用指定 Condition 的 signal 方法后，就会将它的条件队列中的节点迁移到等待队列中，等待唤醒。当唤醒之前就会尝试重新获取锁，当获取到锁之后就可以执行自己的业务代码了。</p><p>条件队列示意图：</p><img src="/assets/09-Condition队列和等待队列-cdfedb6b.png" alt="09-Condition队列和等待队列" style="zoom:67%;"><h3 id="conditionobject-的属性" tabindex="-1"><a class="header-anchor" href="#conditionobject-的属性" aria-hidden="true">#</a> ConditionObject 的属性</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// Condition 队列首结点指针</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Node</span> firstWaiter<span class="token punctuation">;</span>
<span class="token comment">// Condition 队列尾结点指针</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Node</span> lastWaiter<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ConditionObject 主要就是两个指针，一个指向条件队列的头结点，一个指向了条件队列的尾结点。</p><h3 id="await-方法阻塞前代码分析" tabindex="-1"><a class="header-anchor" href="#await-方法阻塞前代码分析" aria-hidden="true">#</a> await 方法阻塞前代码分析</h3><p>分析下 ConditionObject#await() 阻塞线程的方法，本小结只会分析阻塞前的代码</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 将当前线程封装成 CONDITION 节点加入到条件队列中</span>
    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 完全释放锁，使用临时变量 savedState 保存释放前的同步状态</span>
    <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 0 在条件队列挂起期间未发生过中断</span>
    <span class="token comment">// -1 在条件队列挂起期间接收到中断信号了</span>
    <span class="token comment">// 1 在条件队列挂起期间未接收到中断信号，但是迁移到&quot;等待队列&quot;之后，接收过中断信号</span>
    <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// isOnSyncQueue 返回 true 表示当前线程对应的节点已经迁移到等待队列了</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 因为当前 node 仍然还在条件队列中，需要继续 park</span>
        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> <span class="token constant">THROW_IE</span><span class="token punctuation">)</span>
        interruptMode <span class="token operator">=</span> <span class="token constant">REINTERRUPT</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// clean up if cancelled</span>
        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先是将当前线程封装成一个 CONDITION 状态的节点，并将其添加到条件队列（单向链表），具体体现在ConditionObject#addConditionWaiter 方法，这个方法里面完全就是链表的操作，可自行查看。</p><p>然后调用 AbstractQueuedSynchronizer#fullyRelease 完全释放锁，并唤醒在等待队列中等待的线程（如果有的话），最后会将释放锁前的 state 状态保存到临时变量 savedState 中，用于唤醒后的恢复操作。</p><p>看下 AbstractQueuedSynchronizer#fullyRelease 方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">/*
 * 完全释放锁，并返回之前的持锁次数
 */</span>
<span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">release</span><span class="token punctuation">(</span>savedState<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 释放锁成功</span>
            failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> savedState<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 释放锁失败</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>
            node<span class="token punctuation">.</span>waitStatus <span class="token operator">=</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">CANCELLED</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ß然后进入到一个 while 循环的判断， AbstractQueuedSynchronizer#isOnSyncQueue 方法，这个方法的含义是：</p><ol><li>返回 false 表示当前线程的节点还在队列中，这是就会进入到循环体中，当前线程就会被阻塞；</li><li>返回 true 表示当前线程的节点已经到等待队列中去了；</li></ol><p>这个方法具体源码后面分析。</p><h3 id="signal-唤醒线程" tabindex="-1"><a class="header-anchor" href="#signal-唤醒线程" aria-hidden="true">#</a> signal 唤醒线程</h3><p>ConditionObject#signal 和 ConditionObject#doSignal</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 当前线程未持有锁，抛异常</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Node</span> first <span class="token operator">=</span> firstWaiter<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token comment">// 将条件队列的节点迁移到等待队列</span>
        <span class="token function">doSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 将节点从条件队列转移到等待队列</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里的逻辑就是从头往后遍历Condition链表</span>
        <span class="token comment">// 找到一个节点不是null的，然后调用唤醒，就那么简单</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>firstWaiter <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            lastWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

        <span class="token comment">// 当前first节点出队，断开和下一个节点的关系</span>
        first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

        <span class="token comment">// transferForSignal(first) true 表示当前 first 节点迁移到等待队列成功</span>
        <span class="token comment">// 直至迁移某个节点成功，或者条件队列为 null 为止</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
             <span class="token punctuation">(</span>first <span class="token operator">=</span> firstWaiter<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在迁移之前会将条件队列的队首节点出队，然后尝试将该队首节点迁移到等待队列中去。</p><p>真正的迁移方法在 AbstractQueuedSynchronizer#transferForSignal 方法中，假如这个队首节点迁移失败了，则会尝试迁移下一个节点。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">transferForSignal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将节点的状态从 CONDTION 改为 0</span>
    <span class="token comment">// 因为后面唤醒之后还要进入等待队列去争抢锁，所以改为 0 也就是等待队列的初始状态</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">CONDITION</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// 将节点插入到等待队列，返回的 p 是节点的前驱节点</span>
    <span class="token class-name">Node</span> p <span class="token operator">=</span> <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> ws <span class="token operator">=</span> p<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>
    <span class="token comment">// 如果上一个节点是取消状态，或者尝试设置上一个节点的状态为 SIGNAL 失败了，就立即唤醒 await 的线程</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">SIGNAL</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实 signal 方法的作用就是将条件队列的队首节点迁移到等待队列中，等待前驱结点唤醒它。</p><p>首先 CAS 尝试将节点的状态从 CONDITION 改为 0，CAS 失败则说明当前节点在条件队列中不正常，不正常的情况有两种：</p><ol><li>一种是当前节点被取消了；</li><li>一种是当前节点因为被中断了，节点已经被迁移到等待队列且状态被改为 0 了；</li></ol><p>节点不正常返回 false 让外层的 do...while 循环处理，其实就是尝试迁移下一个节点。</p><p>假如节点正常的话，此时节点的状态被改为 0，调用 AbstractQueuedSynchronizer#enq 插入等待队列的尾部，并尝试将前驱节点的状态改为 SIGNAL。</p><p>根据前驱节点的状态来确定是否立即唤醒 await 的线程，在下面两种情况会立即唤醒：</p><ul><li>如果上一个节点是取消状态，或者尝试设置上一个节点的状态为 SIGNAL 失败了。</li></ul><p>那么正常情况下的节点是怎么唤醒的呢？</p><p>其实就是在等待队列中等待它的前驱节点释放锁后唤醒它。</p><p>OK，这里已经分析完了 signal 方法了，其实就是将节点从条件队列转移到等待队列。</p><h3 id="await-方法里被唤醒后的代码分析" tabindex="-1"><a class="header-anchor" href="#await-方法里被唤醒后的代码分析" aria-hidden="true">#</a> await 方法里被唤醒后的代码分析</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// isOnSyncQueue 返回 true 表示当前线程对应的节点已经迁移到等待队列了</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 因为当前 node 仍然还在条件队列中，需要继续 park</span>
        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token comment">// != 0 说明发生中断了，需要跳出循环</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

	<span class="token comment">// 节点一定是被迁移到了等待队列中</span>
    <span class="token comment">// 重新获取锁，acquireQueued 会阻塞直到获取到锁</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> <span class="token constant">THROW_IE</span><span class="token punctuation">)</span>
        interruptMode <span class="token operator">=</span> <span class="token constant">REINTERRUPT</span><span class="token punctuation">;</span>

    <span class="token comment">// 什么时候会 node.nextWaiter != null ？</span>
    <span class="token comment">// 其实是因为 node 在条件队列内被外部线程中断唤醒时，会加入到等待队列，但是并未设置 nextWaiter = null</span>
    <span class="token comment">// 被信号唤醒或信号后中断唤醒的节点，将首先移出条件队列，再进行状态转换并迁移到等待队列。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// clean up if cancelled</span>
        <span class="token comment">// 这里就是删除一下无效的条件队列节点</span>
        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果之前发生了中断，则根据中断模式重放中断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先看线程被唤醒后的第一个方法 ConditionObject#checkInterruptWhileWaiting</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span>
        <span class="token punctuation">(</span><span class="token function">transferAfterCancelledWait</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">THROW_IE</span> <span class="token operator">:</span> <span class="token constant">REINTERRUPT</span><span class="token punctuation">)</span> <span class="token operator">:</span>
    <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">// 返回 true 表示节点是在条件队列中被中断的</span>
<span class="token comment">// 返回 false 表示节点是在条件队列外被中断的，是收到信号后发生的中断</span>
<span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">transferAfterCancelledWait</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">CONDITION</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 说明当前节点是在条件队列里的，因为 signal 时迁移节点到等待队列时，需要将节点的状态修改为 0</span>
        <span class="token comment">// 被中断唤醒的节点也会入到同步队列</span>
        <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 返回 true 表示在条件队列内被中断的</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*
         * If we lost out to a signal(), then we can&#39;t proceed
         * until it finishes its enq().  Cancelling during an
         * incomplete transfer is both rare and transient, so just
         * spin.
         */</span>
    <span class="token comment">// 到这里的情况</span>
    <span class="token comment">// 1.当前 node 已经被外部线程调用 signal 方法将其迁移到等待队列了</span>
    <span class="token comment">// 2.当前 node 已经被外部线程调用 signal 方法将其迁移到等待队列进行中的状态</span>
    <span class="token comment">// 一定是在收到信号后发生了中断，但可能 AQS#transferForSignal() node未完成入队，因此，空等待至node完成入队，然后返回false，</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 表示当前节点被中断唤醒时，不在条件队列了</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如当前线程被中断了，这个方法主要就是为了确定是在什么时候发送中断的。</p><ol><li>没有发生中断返回 0；</li><li>节点在条件队列中发生的中断返回 THROW_IE；</li><li>节点不是在条件队列中发送的中断返回 REINTERRUPT，这个时机可能是再在等待队列中，也可能是迁移到等待队列的操作一半的时候；</li></ol><p>在代码中可以看到，假如是在条件队列中的时候被中断了，是会调用 enq 方法将当前节点迁移到等待队列中。</p><p>OK 反正当退出 await 方法的 while 循环后，当前节点一定是从条件队列中迁移到了等待队列中去了。</p><p><strong>重点是要恢复当前线程在 await 之前的持锁状态，那么会调用 AbstractQueuedSynchronizer#acquireQueued 方法尝试获取锁，这里也可能会被阻塞，直到获取锁。</strong></p><p>最后的两个 if 判断很简单：</p><p>第一个</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// clean up if cancelled</span>
    <span class="token comment">// 这里就是删除一下无效的条件队列节点</span>
    <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里是因为线程在条件队列中被中断的时候，是没有断开 nextWaiter 的指针，这里是给他擦屁股，其实就是删除条件队列中的取消状态的节点。</p><p>第二个</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 如果之前发生了中断，则根据中断模式重放中断</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如线程被中断过了，则根据中断模式重放中断。这个为什么这么设计，其实这是 JSR 中规定的，按照 Doug Lea 的 AQS 论文原文说的</p><p>As revised in JSR133, these require that if an interrupt occurs before a signal, then the await method must, after re-acquiring the lock, throw InterruptedException. But if it is interrupted after a signal, then the method must return without throwing an exception, but with its thread interrupt status set.</p><p>意思就是 在 JSR133 修订之后，规范要求如果中断先于 signal 发生，那么 await 在重新获取锁之后必须抛出 InterruptedException 异常。但如果中断比 signal 发生得晚，那么 await 必须不抛异常返回，然后设置当前线程的中断标志。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>当线程在指定 Condition 对象上等待的时候，其实就是将线程包装成节点并添加到了条件队列，然后阻塞。</p><p>当线程被通知唤醒时，则是将条件队列中的节点转换成等待队列中的节点，之后的处理就和独占功能完全一样。</p><p>Condition 的接口中还支持非中断等待和带潮湿的等待，代码其实都比较相似，可以自行查看。</p><p>await 和 signal 方法的流程图</p><p><img src="/assets/08-Condition流程图-221ddd2f.png" alt="08-Condition流程图"></p></div><!----><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: guosgbin@163.com">Dylan Kwok</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a href="/JDK_source/10-%E5%9F%BA%E4%BA%8ECountDownLatch%E5%88%86%E6%9E%90AQS%E7%9A%84%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F.html" class="nav-link prev" aria-label="10-基于CountDownLatch分析AQS的共享模式"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->10-基于CountDownLatch分析AQS的共享模式</div></a><a href="/JDK_source/12-%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore.html" class="nav-link next" aria-label="12-信号量Semaphore"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">12-信号量Semaphore<!----></div></a></nav><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-0262c20c.js" defer></script>
  </body>
</html>
