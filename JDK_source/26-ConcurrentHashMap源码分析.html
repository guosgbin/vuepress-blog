<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.62" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://blog.guosgbin.cn/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"><meta property="og:title" content="26-ConcurrentHashMap源码分析"><meta property="og:description" content="版本 内容 时间 ---- ---- ---------------------- V1 新建 2022年12月02日00:23:46 概述 我们知道 HashMap 不是线程安全的，在 JDK1.5 之前JDK 提供的同步的 Map 有 Hashtable 和使用 Collections. synchronizedMap 返回一个同步代理类 Sync..."><meta property="og:type" content="article"><meta property="og:image" content="https://blog.guosgbin.cn/"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-05-04T03:52:42.000Z"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="26-ConcurrentHashMap源码分析"><meta property="article:author" content="超威蓝猫 Dylan Kwok"><meta property="article:modified_time" content="2023-05-04T03:52:42.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"26-ConcurrentHashMap源码分析","image":["https://blog.guosgbin.cn/"],"dateModified":"2023-05-04T03:52:42.000Z","author":[{"@type":"Person","name":"超威蓝猫 Dylan Kwok","url":"","email":"guosgbin@163.com"}]}</script><link rel="icon" href="/小熊猫.svg"><title>26-ConcurrentHashMap源码分析</title><meta name="description" content="版本 内容 时间 ---- ---- ---------------------- V1 新建 2022年12月02日00:23:46 概述 我们知道 HashMap 不是线程安全的，在 JDK1.5 之前JDK 提供的同步的 Map 有 Hashtable 和使用 Collections. synchronizedMap 返回一个同步代理类 Sync...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-542658da.css" as="style"><link rel="stylesheet" href="/assets/style-542658da.css">
    <link rel="modulepreload" href="/assets/app-ecfdc732.js"><link rel="modulepreload" href="/assets/26-ConcurrentHashMap源码分析.html-cd802369.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-c27b6911.js"><link rel="modulepreload" href="/assets/26-ConcurrentHashMap源码分析.html-a3bba8a9.js"><link rel="prefetch" href="/assets/index.html-d93d8c2f.js" as="script"><link rel="prefetch" href="/assets/01-创建和销毁对象.html-98280ce1.js" as="script"><link rel="prefetch" href="/assets/index.html-c4f42206.js" as="script"><link rel="prefetch" href="/assets/SPI机制.html-a1ca3921.js" as="script"><link rel="prefetch" href="/assets/01-CAS和Unsafe的API分析.html-612c4d6a.js" as="script"><link rel="prefetch" href="/assets/02-基本类型原子类AtomicLong.html-4083b8fd.js" as="script"><link rel="prefetch" href="/assets/03-引用类型原子类AtomicReference.html-8442553d.js" as="script"><link rel="prefetch" href="/assets/04-原子数组类AtomicLongArray.html-74e4c741.js" as="script"><link rel="prefetch" href="/assets/05-原子操作类AtomicReferenceFieldUpdater.html-d0310b2a.js" as="script"><link rel="prefetch" href="/assets/06-高性能原子类LongAdder.html-d6e3da8b.js" as="script"><link rel="prefetch" href="/assets/07-LockSupport分析.html-8117dd17.js" as="script"><link rel="prefetch" href="/assets/08-AQS简单介绍.html-30b6ef5b.js" as="script"><link rel="prefetch" href="/assets/09-基于ReentrantLock分析AQS的独占模式.html-2423c430.js" as="script"><link rel="prefetch" href="/assets/10-基于CountDownLatch分析AQS的共享模式.html-91ef4833.js" as="script"><link rel="prefetch" href="/assets/11-AQS的Condition机制.html-836364af.js" as="script"><link rel="prefetch" href="/assets/12-信号量Semaphore.html-3509682c.js" as="script"><link rel="prefetch" href="/assets/13-循环栏栅CyclicBarrier.html-812d137d.js" as="script"><link rel="prefetch" href="/assets/14-阶段Phaser.html-d684f4a1.js" as="script"><link rel="prefetch" href="/assets/15-交换Exchanger.html-b9bf24f3.js" as="script"><link rel="prefetch" href="/assets/16-读写锁ReentrantReadWriteLock.html-de44a1d3.js" as="script"><link rel="prefetch" href="/assets/17-Future模式-FutureTask.html-641c6250.js" as="script"><link rel="prefetch" href="/assets/18-线程池体系概述.html-dbcc52e5.js" as="script"><link rel="prefetch" href="/assets/19-线程池体系-AbstractExecutorService.html-fbd70afb.js" as="script"><link rel="prefetch" href="/assets/20-线程池体系-ThreadPoolExecutor.html-a274637a.js" as="script"><link rel="prefetch" href="/assets/21-线程池体系-ScheduledThreadPoolExecutor.html-707ffd40.js" as="script"><link rel="prefetch" href="/assets/22-CopyOnWriteArrayList写时复制.html-914977b9.js" as="script"><link rel="prefetch" href="/assets/23-CopyOnWriteArraySet写时复制.html-6c9c3cf6.js" as="script"><link rel="prefetch" href="/assets/24-ConcurrentSkipListMap跳表.html-6cff54bf.js" as="script"><link rel="prefetch" href="/assets/25-ConcurrentSkipListSet跳表.html-36cf4f7d.js" as="script"><link rel="prefetch" href="/assets/27-阻塞队列ArrayBlockingQueue.html-cd091357.js" as="script"><link rel="prefetch" href="/assets/28-阻塞队列LinkedBlockingQueue.html-d3579ee7.js" as="script"><link rel="prefetch" href="/assets/29-阻塞队列LinkedBlockingDeque.html-32c13680.js" as="script"><link rel="prefetch" href="/assets/30-阻塞队列PriorityBlockingQueue.html-b5455c77.js" as="script"><link rel="prefetch" href="/assets/31-阻塞队列DelayQueue.html-7759c195.js" as="script"><link rel="prefetch" href="/assets/32-阻塞队列SynchronousQueue.html-97ed879a.js" as="script"><link rel="prefetch" href="/assets/33-阻塞队列LinkedTransferQueue.html-3281c1b4.js" as="script"><link rel="prefetch" href="/assets/index.html-f5239cf3.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis01：myabtis的整体架构.html-f25c0705.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis02：入门案例.html-30e68cd3.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis03：解析全局配置文件.html-2db85266.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis04：解析Mapper映射文件.html-60756a5b.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis05：解析Statement操作节点.html-31e11b60.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis06：解析SQL语句.html-a9181b56.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis07：Java方法和SQL语句绑定.html-9bfa3db6.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis08：获得SqlSession.html-e2a92940.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis09：Executor执行器.html-ad701715.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis10：缓存机制.html-f2daa10c.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis11：StatementHandler.html-95b30d9b.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis12：参数解析和赋值.html-5778c0ea.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis13：结果集处理.html-2ff72779.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis14：插件.html-76cc6bf8.js" as="script"><link rel="prefetch" href="/assets/01-服务端启动流程.html-d2fc1f19.js" as="script"><link rel="prefetch" href="/assets/02-服务端启动添加ChannelInitializer到管道.html-86cb5d6a.js" as="script"><link rel="prefetch" href="/assets/03-客户端启动流程.html-becc83be.js" as="script"><link rel="prefetch" href="/assets/04-线程体系-NioEventLoopGroup.html-700e797e.js" as="script"><link rel="prefetch" href="/assets/05-线程体系-NioEventLoop相关父接口分析.html-754320bc.js" as="script"><link rel="prefetch" href="/assets/06-线程体系-AbstractEventExecutor.html-5250cd42.js" as="script"><link rel="prefetch" href="/assets/07-线程体系-AbstractScheduledEventExecutor-优先队列.html-e7bbaf32.js" as="script"><link rel="prefetch" href="/assets/08-线程体系-NioEventLoop概述.html-fce3fb2c.js" as="script"><link rel="prefetch" href="/assets/09-线程体系-NioEventLoop开启Selector及优化.html-6d8230cf.js" as="script"><link rel="prefetch" href="/assets/10-线程体系-NioEventLoop绑定线程.html-db947821.js" as="script"><link rel="prefetch" href="/assets/11-线程体系-NioEventLoop的run方法.html-def4cc31.js" as="script"><link rel="prefetch" href="/assets/12-线程体系-NioEventLoop规避JDK的NIO空循环bug.html-16ecaf4e.js" as="script"><link rel="prefetch" href="/assets/13-线程体系-NioEventLoop的优雅关闭.html-912d668d.js" as="script"><link rel="prefetch" href="/assets/14-服务端处理客户端的连接(ACCEPT).html-63afdec1.js" as="script"><link rel="prefetch" href="/assets/15-客户端处理READ事件概述.html-b35daeb8.js" as="script"><link rel="prefetch" href="/assets/16-客户端处理READ事件详解及RecvByteBufAllocator.html-a9faccfa.js" as="script"><link rel="prefetch" href="/assets/17-Netty管道机制.html-ba70b238.js" as="script"><link rel="prefetch" href="/assets/18-Netty发送数据流程及出站缓冲区.html-223d04a7.js" as="script"><link rel="prefetch" href="/assets/index.html-b475d8b0.js" as="script"><link rel="prefetch" href="/assets/Redis_Benchmark基准测试.html-dbf21951.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群和槽管理命令.html-2b4a1244.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群基本特性和集群搭建.html-42be726b.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群管理工具redis-cli.html-fc4f1503.js" as="script"><link rel="prefetch" href="/assets/Redis_Pipeline优化RTT.html-8a4aa041.js" as="script"><link rel="prefetch" href="/assets/Redis_Sentinel高可用.html-6bcdb34a.js" as="script"><link rel="prefetch" href="/assets/Redis_key设计规范.html-ab90a7dc.js" as="script"><link rel="prefetch" href="/assets/Redis事务.html-e43061e1.js" as="script"><link rel="prefetch" href="/assets/Redis内存淘汰策略.html-feabd314.js" as="script"><link rel="prefetch" href="/assets/Redis发布订阅.html-68771977.js" as="script"><link rel="prefetch" href="/assets/Redis复制.html-33b20d6f.js" as="script"><link rel="prefetch" href="/assets/Redis大key和热key问题.html-394d194e.js" as="script"><link rel="prefetch" href="/assets/Redis慢查询日志.html-7fb06db0.js" as="script"><link rel="prefetch" href="/assets/Redis持久化机制.html-53af3f7a.js" as="script"><link rel="prefetch" href="/assets/Redis键空间通知(keyspace notification).html-012bd277.js" as="script"><link rel="prefetch" href="/assets/redis-cli 使用.html-f7ab22db.js" as="script"><link rel="prefetch" href="/assets/01-RocketMQ概述.html-25463efe.js" as="script"><link rel="prefetch" href="/assets/02-NameServer启动流程.html-a514999f.js" as="script"><link rel="prefetch" href="/assets/03-Broker启动流程.html-43c84806.js" as="script"><link rel="prefetch" href="/assets/04-RocketMQ网络通信原理.html-ac88de8d.js" as="script"><link rel="prefetch" href="/assets/05-RocketMQ 服务端和客户端的启动.html-ef7f1888.js" as="script"><link rel="prefetch" href="/assets/06-RocketMQ网络通信源码.html-b8e0bf43.js" as="script"><link rel="prefetch" href="/assets/07-NameServer作用和路由元信息.html-82a23869.js" as="script"><link rel="prefetch" href="/assets/08-NameServer路由管理源码分析.html-8da2bd72.js" as="script"><link rel="prefetch" href="/assets/09-生产者相关类分析.html-08f6e840.js" as="script"><link rel="prefetch" href="/assets/10-生产者启动流程.html-d761cf07.js" as="script"><link rel="prefetch" href="/assets/11-生产者发送消息.html-743328bc.js" as="script"><link rel="prefetch" href="/assets/12-Broker存储机制概述.html-5e7ed491.js" as="script"><link rel="prefetch" href="/assets/13-MappedFile和MappedFileQueue分析.html-5b9afaf2.js" as="script"><link rel="prefetch" href="/assets/14-CommitLog原理分析.html-93362aa2.js" as="script"><link rel="prefetch" href="/assets/15-broker的刷盘机制.html-21e2029f.js" as="script"><link rel="prefetch" href="/assets/16-ConsumeQueue和Index原理分析.html-ff18bade.js" as="script"><link rel="prefetch" href="/assets/17-broker过期文件删除机制.html-89f05919.js" as="script"><link rel="prefetch" href="/assets/18-消费者启动流程(TODO).html-988c43b3.js" as="script"><link rel="prefetch" href="/assets/19-消息拉取入口和消息队列负载均衡.html-7e4e20d4.js" as="script"><link rel="prefetch" href="/assets/20-消费者发送消息拉取请求流程.html-19825069.js" as="script"><link rel="prefetch" href="/assets/21-broker处理消息拉取请求-1-主流程.html-d9ca6fa4.js" as="script"><link rel="prefetch" href="/assets/22-broker处理消息拉取请求-2-长轮询.html-0aba4f38.js" as="script"><link rel="prefetch" href="/assets/23-broker处理消息拉取请求-3-读取消息.html-729d741b.js" as="script"><link rel="prefetch" href="/assets/24-消费者处理从broker拉取的消息.html-dcfb7d07.js" as="script"><link rel="prefetch" href="/assets/25-并发消费原理.html-5ef206ec.js" as="script"><link rel="prefetch" href="/assets/Test.html-8ac87e1e.js" as="script"><link rel="prefetch" href="/assets/JUC相关问题.html-9dc4b717.js" as="script"><link rel="prefetch" href="/assets/JVM问题.html-17300c49.js" as="script"><link rel="prefetch" href="/assets/MySQL相关问题.html-a6c2cd41.js" as="script"><link rel="prefetch" href="/assets/index.html-8f5e683a.js" as="script"><link rel="prefetch" href="/assets/Redis相关问题.html-575f1ee1.js" as="script"><link rel="prefetch" href="/assets/HowToSayResume.html-11d8bbca.js" as="script"><link rel="prefetch" href="/assets/resume.html-3b3f8934.js" as="script"><link rel="prefetch" href="/assets/404.html-f3795607.js" as="script"><link rel="prefetch" href="/assets/index.html-1f3390c0.js" as="script"><link rel="prefetch" href="/assets/index.html-10b45510.js" as="script"><link rel="prefetch" href="/assets/index.html-dfd17ea5.js" as="script"><link rel="prefetch" href="/assets/index.html-2f392b9e.js" as="script"><link rel="prefetch" href="/assets/index.html-4060f68d.js" as="script"><link rel="prefetch" href="/assets/index.html-0efbdc5e.js" as="script"><link rel="prefetch" href="/assets/index.html-9784a76b.js" as="script"><link rel="prefetch" href="/assets/01-创建和销毁对象.html-b84cc6a4.js" as="script"><link rel="prefetch" href="/assets/index.html-d1b39c8b.js" as="script"><link rel="prefetch" href="/assets/SPI机制.html-4b9dc94b.js" as="script"><link rel="prefetch" href="/assets/01-CAS和Unsafe的API分析.html-908b75e4.js" as="script"><link rel="prefetch" href="/assets/02-基本类型原子类AtomicLong.html-69cdfa47.js" as="script"><link rel="prefetch" href="/assets/03-引用类型原子类AtomicReference.html-06de544a.js" as="script"><link rel="prefetch" href="/assets/04-原子数组类AtomicLongArray.html-d919420a.js" as="script"><link rel="prefetch" href="/assets/05-原子操作类AtomicReferenceFieldUpdater.html-30468688.js" as="script"><link rel="prefetch" href="/assets/06-高性能原子类LongAdder.html-35899fc6.js" as="script"><link rel="prefetch" href="/assets/07-LockSupport分析.html-341251b9.js" as="script"><link rel="prefetch" href="/assets/08-AQS简单介绍.html-a91aea5d.js" as="script"><link rel="prefetch" href="/assets/09-基于ReentrantLock分析AQS的独占模式.html-df7cc8d0.js" as="script"><link rel="prefetch" href="/assets/10-基于CountDownLatch分析AQS的共享模式.html-aaa5b92f.js" as="script"><link rel="prefetch" href="/assets/11-AQS的Condition机制.html-d981cb75.js" as="script"><link rel="prefetch" href="/assets/12-信号量Semaphore.html-d5ee2b12.js" as="script"><link rel="prefetch" href="/assets/13-循环栏栅CyclicBarrier.html-8c24a69e.js" as="script"><link rel="prefetch" href="/assets/14-阶段Phaser.html-6932e273.js" as="script"><link rel="prefetch" href="/assets/15-交换Exchanger.html-8f9972a5.js" as="script"><link rel="prefetch" href="/assets/16-读写锁ReentrantReadWriteLock.html-c73d70ac.js" as="script"><link rel="prefetch" href="/assets/17-Future模式-FutureTask.html-857ed2cf.js" as="script"><link rel="prefetch" href="/assets/18-线程池体系概述.html-870e03ae.js" as="script"><link rel="prefetch" href="/assets/19-线程池体系-AbstractExecutorService.html-5bc7bff3.js" as="script"><link rel="prefetch" href="/assets/20-线程池体系-ThreadPoolExecutor.html-baed85aa.js" as="script"><link rel="prefetch" href="/assets/21-线程池体系-ScheduledThreadPoolExecutor.html-ceaefbe9.js" as="script"><link rel="prefetch" href="/assets/22-CopyOnWriteArrayList写时复制.html-b0a181f3.js" as="script"><link rel="prefetch" href="/assets/23-CopyOnWriteArraySet写时复制.html-ee7ac583.js" as="script"><link rel="prefetch" href="/assets/24-ConcurrentSkipListMap跳表.html-055cfd2a.js" as="script"><link rel="prefetch" href="/assets/25-ConcurrentSkipListSet跳表.html-5e9a36a7.js" as="script"><link rel="prefetch" href="/assets/27-阻塞队列ArrayBlockingQueue.html-258ed076.js" as="script"><link rel="prefetch" href="/assets/28-阻塞队列LinkedBlockingQueue.html-c201fb0b.js" as="script"><link rel="prefetch" href="/assets/29-阻塞队列LinkedBlockingDeque.html-ea81fa87.js" as="script"><link rel="prefetch" href="/assets/30-阻塞队列PriorityBlockingQueue.html-0e8b2424.js" as="script"><link rel="prefetch" href="/assets/31-阻塞队列DelayQueue.html-16ddd445.js" as="script"><link rel="prefetch" href="/assets/32-阻塞队列SynchronousQueue.html-633a1293.js" as="script"><link rel="prefetch" href="/assets/33-阻塞队列LinkedTransferQueue.html-a56a0969.js" as="script"><link rel="prefetch" href="/assets/index.html-1c7602c0.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis01：myabtis的整体架构.html-51f539b0.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis02：入门案例.html-947b1f8f.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis03：解析全局配置文件.html-f845751b.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis04：解析Mapper映射文件.html-9afa6faa.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis05：解析Statement操作节点.html-a9b4c7a5.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis06：解析SQL语句.html-33b35ec7.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis07：Java方法和SQL语句绑定.html-c6d20029.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis08：获得SqlSession.html-ccbc6a00.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis09：Executor执行器.html-4b5a76d0.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis10：缓存机制.html-8e767408.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis11：StatementHandler.html-b743a66f.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis12：参数解析和赋值.html-a08cdeb9.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis13：结果集处理.html-2cf6010a.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis14：插件.html-ef59dc9d.js" as="script"><link rel="prefetch" href="/assets/01-服务端启动流程.html-6ee7b9a2.js" as="script"><link rel="prefetch" href="/assets/02-服务端启动添加ChannelInitializer到管道.html-0a549e89.js" as="script"><link rel="prefetch" href="/assets/03-客户端启动流程.html-03ea2d09.js" as="script"><link rel="prefetch" href="/assets/04-线程体系-NioEventLoopGroup.html-5880d5dd.js" as="script"><link rel="prefetch" href="/assets/05-线程体系-NioEventLoop相关父接口分析.html-985d3848.js" as="script"><link rel="prefetch" href="/assets/06-线程体系-AbstractEventExecutor.html-7c4c8730.js" as="script"><link rel="prefetch" href="/assets/07-线程体系-AbstractScheduledEventExecutor-优先队列.html-46b9f2e7.js" as="script"><link rel="prefetch" href="/assets/08-线程体系-NioEventLoop概述.html-6afc9474.js" as="script"><link rel="prefetch" href="/assets/09-线程体系-NioEventLoop开启Selector及优化.html-10923ea1.js" as="script"><link rel="prefetch" href="/assets/10-线程体系-NioEventLoop绑定线程.html-de1677bf.js" as="script"><link rel="prefetch" href="/assets/11-线程体系-NioEventLoop的run方法.html-fb1d6035.js" as="script"><link rel="prefetch" href="/assets/12-线程体系-NioEventLoop规避JDK的NIO空循环bug.html-01f114fd.js" as="script"><link rel="prefetch" href="/assets/13-线程体系-NioEventLoop的优雅关闭.html-ae11fb2e.js" as="script"><link rel="prefetch" href="/assets/14-服务端处理客户端的连接(ACCEPT).html-c6ca116d.js" as="script"><link rel="prefetch" href="/assets/15-客户端处理READ事件概述.html-4a9fc02c.js" as="script"><link rel="prefetch" href="/assets/16-客户端处理READ事件详解及RecvByteBufAllocator.html-d901fd26.js" as="script"><link rel="prefetch" href="/assets/17-Netty管道机制.html-6809a475.js" as="script"><link rel="prefetch" href="/assets/18-Netty发送数据流程及出站缓冲区.html-0f2349b8.js" as="script"><link rel="prefetch" href="/assets/index.html-75a82bf4.js" as="script"><link rel="prefetch" href="/assets/Redis_Benchmark基准测试.html-6bf7a606.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群和槽管理命令.html-8f38e285.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群基本特性和集群搭建.html-a1fa51e7.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群管理工具redis-cli.html-9aadc41f.js" as="script"><link rel="prefetch" href="/assets/Redis_Pipeline优化RTT.html-a3b81191.js" as="script"><link rel="prefetch" href="/assets/Redis_Sentinel高可用.html-11b436fd.js" as="script"><link rel="prefetch" href="/assets/Redis_key设计规范.html-ab5d4cf1.js" as="script"><link rel="prefetch" href="/assets/Redis事务.html-f1de2ae5.js" as="script"><link rel="prefetch" href="/assets/Redis内存淘汰策略.html-1009bb67.js" as="script"><link rel="prefetch" href="/assets/Redis发布订阅.html-48cd5f93.js" as="script"><link rel="prefetch" href="/assets/Redis复制.html-4e1dc834.js" as="script"><link rel="prefetch" href="/assets/Redis大key和热key问题.html-f11ae339.js" as="script"><link rel="prefetch" href="/assets/Redis慢查询日志.html-4cb400c3.js" as="script"><link rel="prefetch" href="/assets/Redis持久化机制.html-d08f249e.js" as="script"><link rel="prefetch" href="/assets/Redis键空间通知(keyspace notification).html-1f78b78f.js" as="script"><link rel="prefetch" href="/assets/redis-cli 使用.html-b02457bc.js" as="script"><link rel="prefetch" href="/assets/01-RocketMQ概述.html-8e4ffa50.js" as="script"><link rel="prefetch" href="/assets/02-NameServer启动流程.html-dad1c474.js" as="script"><link rel="prefetch" href="/assets/03-Broker启动流程.html-f4b7c80d.js" as="script"><link rel="prefetch" href="/assets/04-RocketMQ网络通信原理.html-bcf737f2.js" as="script"><link rel="prefetch" href="/assets/05-RocketMQ 服务端和客户端的启动.html-862fa716.js" as="script"><link rel="prefetch" href="/assets/06-RocketMQ网络通信源码.html-09c101c8.js" as="script"><link rel="prefetch" href="/assets/07-NameServer作用和路由元信息.html-6ab8c72a.js" as="script"><link rel="prefetch" href="/assets/08-NameServer路由管理源码分析.html-961626f6.js" as="script"><link rel="prefetch" href="/assets/09-生产者相关类分析.html-c7093050.js" as="script"><link rel="prefetch" href="/assets/10-生产者启动流程.html-15038ac7.js" as="script"><link rel="prefetch" href="/assets/11-生产者发送消息.html-98164fb2.js" as="script"><link rel="prefetch" href="/assets/12-Broker存储机制概述.html-75e0b6f8.js" as="script"><link rel="prefetch" href="/assets/13-MappedFile和MappedFileQueue分析.html-1c0831f4.js" as="script"><link rel="prefetch" href="/assets/14-CommitLog原理分析.html-e3946cad.js" as="script"><link rel="prefetch" href="/assets/15-broker的刷盘机制.html-5fbcc24e.js" as="script"><link rel="prefetch" href="/assets/16-ConsumeQueue和Index原理分析.html-fd7bbb03.js" as="script"><link rel="prefetch" href="/assets/17-broker过期文件删除机制.html-abaad10c.js" as="script"><link rel="prefetch" href="/assets/18-消费者启动流程(TODO).html-b4721ecb.js" as="script"><link rel="prefetch" href="/assets/19-消息拉取入口和消息队列负载均衡.html-7d5e34b1.js" as="script"><link rel="prefetch" href="/assets/20-消费者发送消息拉取请求流程.html-928e828c.js" as="script"><link rel="prefetch" href="/assets/21-broker处理消息拉取请求-1-主流程.html-9c500247.js" as="script"><link rel="prefetch" href="/assets/22-broker处理消息拉取请求-2-长轮询.html-a69b102b.js" as="script"><link rel="prefetch" href="/assets/23-broker处理消息拉取请求-3-读取消息.html-330c1784.js" as="script"><link rel="prefetch" href="/assets/24-消费者处理从broker拉取的消息.html-ed5fb28a.js" as="script"><link rel="prefetch" href="/assets/25-并发消费原理.html-7a296875.js" as="script"><link rel="prefetch" href="/assets/Test.html-806da57f.js" as="script"><link rel="prefetch" href="/assets/JUC相关问题.html-7e14b457.js" as="script"><link rel="prefetch" href="/assets/JVM问题.html-171f0cc4.js" as="script"><link rel="prefetch" href="/assets/MySQL相关问题.html-ddf23070.js" as="script"><link rel="prefetch" href="/assets/index.html-e0070464.js" as="script"><link rel="prefetch" href="/assets/Redis相关问题.html-6f6e0d2f.js" as="script"><link rel="prefetch" href="/assets/HowToSayResume.html-998ba8a9.js" as="script"><link rel="prefetch" href="/assets/resume.html-d0b30503.js" as="script"><link rel="prefetch" href="/assets/404.html-0e7f810a.js" as="script"><link rel="prefetch" href="/assets/index.html-999ddfc0.js" as="script"><link rel="prefetch" href="/assets/index.html-423a081f.js" as="script"><link rel="prefetch" href="/assets/index.html-b7837fd9.js" as="script"><link rel="prefetch" href="/assets/index.html-4f4f1e47.js" as="script"><link rel="prefetch" href="/assets/index.html-35d818e0.js" as="script"><link rel="prefetch" href="/assets/index.html-2f6dab8b.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-2450701e.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a href="/" class="vp-brand"><img class="vp-nav-logo" src="/小熊猫.png" alt><!----><!----></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><!----><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><!----><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><!--[--><a href="/JDK_source/" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="JUC包源码分析"><!---->JUC包源码分析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/01-CAS%E5%92%8CUnsafe%E7%9A%84API%E5%88%86%E6%9E%90.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="01-CAS和Unsafe的API分析"><!---->01-CAS和Unsafe的API分析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/02-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicLong.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="02-基本类型原子类AtomicLong"><!---->02-基本类型原子类AtomicLong<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/03-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicReference.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="03-引用类型原子类AtomicReference"><!---->03-引用类型原子类AtomicReference<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/04-%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84%E7%B1%BBAtomicLongArray.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="04-原子数组类AtomicLongArray"><!---->04-原子数组类AtomicLongArray<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/05-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BBAtomicReferenceFieldUpdater.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="05-原子操作类AtomicReferenceFieldUpdater"><!---->05-原子操作类AtomicReferenceFieldUpdater<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/06-%E9%AB%98%E6%80%A7%E8%83%BD%E5%8E%9F%E5%AD%90%E7%B1%BBLongAdder.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="06-高性能原子类LongAdder"><!---->06-高性能原子类LongAdder<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/07-LockSupport%E5%88%86%E6%9E%90.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="07-LockSupport分析"><!---->07-LockSupport分析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/08-AQS%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="08-AQS简单介绍"><!---->08-AQS简单介绍<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/09-%E5%9F%BA%E4%BA%8EReentrantLock%E5%88%86%E6%9E%90AQS%E7%9A%84%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="09-基于ReentrantLock分析AQS的独占模式"><!---->09-基于ReentrantLock分析AQS的独占模式<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/10-%E5%9F%BA%E4%BA%8ECountDownLatch%E5%88%86%E6%9E%90AQS%E7%9A%84%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="10-基于CountDownLatch分析AQS的共享模式"><!---->10-基于CountDownLatch分析AQS的共享模式<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/11-AQS%E7%9A%84Condition%E6%9C%BA%E5%88%B6.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="11-AQS的Condition机制"><!---->11-AQS的Condition机制<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/12-%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="12-信号量Semaphore"><!---->12-信号量Semaphore<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/13-%E5%BE%AA%E7%8E%AF%E6%A0%8F%E6%A0%85CyclicBarrier.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="13-循环栏栅CyclicBarrier"><!---->13-循环栏栅CyclicBarrier<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/14-%E9%98%B6%E6%AE%B5Phaser.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="14-阶段Phaser"><!---->14-阶段Phaser<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/15-%E4%BA%A4%E6%8D%A2Exchanger.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="15-交换Exchanger"><!---->15-交换Exchanger<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/16-%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="16-读写锁ReentrantReadWriteLock"><!---->16-读写锁ReentrantReadWriteLock<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/17-Future%E6%A8%A1%E5%BC%8F-FutureTask.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="17-Future模式-FutureTask"><!---->17-Future模式-FutureTask<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/18-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB%E6%A6%82%E8%BF%B0.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="18-线程池体系概述"><!---->18-线程池体系概述<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/19-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-AbstractExecutorService.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="19-线程池体系-AbstractExecutorService"><!---->19-线程池体系-AbstractExecutorService<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ThreadPoolExecutor.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="20-线程池体系-ThreadPoolExecutor"><!---->20-线程池体系-ThreadPoolExecutor<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/21-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB-ScheduledThreadPoolExecutor.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="21-线程池体系-ScheduledThreadPoolExecutor"><!---->21-线程池体系-ScheduledThreadPoolExecutor<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/22-CopyOnWriteArrayList%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="22-CopyOnWriteArrayList写时复制"><!---->22-CopyOnWriteArrayList写时复制<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/23-CopyOnWriteArraySet%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="23-CopyOnWriteArraySet写时复制"><!---->23-CopyOnWriteArraySet写时复制<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/24-ConcurrentSkipListMap%E8%B7%B3%E8%A1%A8.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="24-ConcurrentSkipListMap跳表"><!---->24-ConcurrentSkipListMap跳表<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/25-ConcurrentSkipListSet%E8%B7%B3%E8%A1%A8.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="25-ConcurrentSkipListSet跳表"><!---->25-ConcurrentSkipListSet跳表<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html" class="router-link-active router-link-exact-active nav-link active vp-sidebar-link vp-sidebar-page active" aria-label="26-ConcurrentHashMap源码分析"><!---->26-ConcurrentHashMap源码分析<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#概述" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="概述"><!---->概述<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#继承关系" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="继承关系"><!---->继承关系<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-的内部结构" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="ConcurrentHashMap 的内部结构"><!---->ConcurrentHashMap 的内部结构<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#各个节点的继承关系" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="各个节点的继承关系"><!---->各个节点的继承关系<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#节点的作用" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="节点的作用"><!---->节点的作用<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#节点的定义" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="节点的定义"><!---->节点的定义<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-构造方法" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="ConcurrentHashMap 构造方法"><!---->ConcurrentHashMap 构造方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-属性" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="ConcurrentHashMap 属性"><!---->ConcurrentHashMap 属性<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-的-put-操作" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="ConcurrentHashMap 的 put 操作"><!---->ConcurrentHashMap 的 put 操作<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#懒加载-初始化-table" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="懒加载-初始化 table"><!---->懒加载-初始化 table<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#哈希寻址到的桶位为空" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="哈希寻址到的桶位为空"><!---->哈希寻址到的桶位为空<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#找到-forwardingnode-节点" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="找到 ForwardingNode 节点"><!---->找到 ForwardingNode 节点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#发送哈希冲突了且并未在扩容" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="发送哈希冲突了且并未在扩容"><!---->发送哈希冲突了且并未在扩容<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-树化操作" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="ConcurrentHashMap 树化操作"><!---->ConcurrentHashMap 树化操作<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#putval-操作的整体流程图" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="putVal 操作的整体流程图"><!---->putVal 操作的整体流程图<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-的计数操作" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="ConcurrentHashMap 的计数操作"><!---->ConcurrentHashMap 的计数操作<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-的扩容操作" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="ConcurrentHashMap 的扩容操作"><!---->ConcurrentHashMap 的扩容操作<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#扩容的基本原理" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="扩容的基本原理"><!---->扩容的基本原理<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#触发扩容的时机" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="触发扩容的时机"><!---->触发扩容的时机<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#迁移数据的操作" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="迁移数据的操作"><!---->迁移数据的操作<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#迁移数据的流程示例" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="迁移数据的流程示例"><!---->迁移数据的流程示例<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-的-get-操作" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="ConcurrentHashMap 的 get 操作"><!---->ConcurrentHashMap 的 get 操作<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#treebin-的-get-方法" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="TreeBin 的 get 方法"><!---->TreeBin 的 get 方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#forwardingnode-的-get-方法" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="ForwardingNode 的 get 方法"><!---->ForwardingNode 的 get 方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-的-remove-方法" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="ConcurrentHashMap 的 remove 方法"><!---->ConcurrentHashMap 的 remove 方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-小结" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="ConcurrentHashMap 小结"><!---->ConcurrentHashMap 小结<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/JDK_source/27-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97ArrayBlockingQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="27-阻塞队列ArrayBlockingQueue"><!---->27-阻塞队列ArrayBlockingQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/28-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97LinkedBlockingQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="28-阻塞队列LinkedBlockingQueue"><!---->28-阻塞队列LinkedBlockingQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/29-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97LinkedBlockingDeque.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="29-阻塞队列LinkedBlockingDeque"><!---->29-阻塞队列LinkedBlockingDeque<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/30-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97PriorityBlockingQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="30-阻塞队列PriorityBlockingQueue"><!---->30-阻塞队列PriorityBlockingQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/31-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97DelayQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="31-阻塞队列DelayQueue"><!---->31-阻塞队列DelayQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/32-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97SynchronousQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="32-阻塞队列SynchronousQueue"><!---->32-阻塞队列SynchronousQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/JDK_source/33-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97LinkedTransferQueue.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="33-阻塞队列LinkedTransferQueue"><!---->33-阻塞队列LinkedTransferQueue<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->26-ConcurrentHashMap源码分析</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="page-author-item">超威蓝猫 Dylan Kwok</span></span><span property="author" content="超威蓝猫 Dylan Kwok"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-05-04T02:26:04.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 40 分钟</span><meta property="timeRequired" content="PT40M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#概述" class="router-link-active router-link-exact-active toc-link level2">概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#继承关系" class="router-link-active router-link-exact-active toc-link level2">继承关系</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-的内部结构" class="router-link-active router-link-exact-active toc-link level2">ConcurrentHashMap 的内部结构</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#各个节点的继承关系" class="router-link-active router-link-exact-active toc-link level3">各个节点的继承关系</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#节点的作用" class="router-link-active router-link-exact-active toc-link level3">节点的作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#节点的定义" class="router-link-active router-link-exact-active toc-link level3">节点的定义</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-构造方法" class="router-link-active router-link-exact-active toc-link level2">ConcurrentHashMap 构造方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-属性" class="router-link-active router-link-exact-active toc-link level2">ConcurrentHashMap 属性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-的-put-操作" class="router-link-active router-link-exact-active toc-link level2">ConcurrentHashMap 的 put 操作</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#懒加载-初始化-table" class="router-link-active router-link-exact-active toc-link level3">懒加载-初始化 table</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#哈希寻址到的桶位为空" class="router-link-active router-link-exact-active toc-link level3">哈希寻址到的桶位为空</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#找到-forwardingnode-节点" class="router-link-active router-link-exact-active toc-link level3">找到 ForwardingNode 节点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#发送哈希冲突了且并未在扩容" class="router-link-active router-link-exact-active toc-link level3">发送哈希冲突了且并未在扩容</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-树化操作" class="router-link-active router-link-exact-active toc-link level3">ConcurrentHashMap 树化操作</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#putval-操作的整体流程图" class="router-link-active router-link-exact-active toc-link level3">putVal 操作的整体流程图</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-的计数操作" class="router-link-active router-link-exact-active toc-link level2">ConcurrentHashMap 的计数操作</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-的扩容操作" class="router-link-active router-link-exact-active toc-link level2">ConcurrentHashMap 的扩容操作</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#扩容的基本原理" class="router-link-active router-link-exact-active toc-link level3">扩容的基本原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#触发扩容的时机" class="router-link-active router-link-exact-active toc-link level3">触发扩容的时机</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#迁移数据的操作" class="router-link-active router-link-exact-active toc-link level3">迁移数据的操作</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#迁移数据的流程示例" class="router-link-active router-link-exact-active toc-link level3">迁移数据的流程示例</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-的-get-操作" class="router-link-active router-link-exact-active toc-link level2">ConcurrentHashMap 的 get 操作</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#treebin-的-get-方法" class="router-link-active router-link-exact-active toc-link level3">TreeBin 的 get 方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#forwardingnode-的-get-方法" class="router-link-active router-link-exact-active toc-link level3">ForwardingNode 的 get 方法</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-的-remove-方法" class="router-link-active router-link-exact-active toc-link level2">ConcurrentHashMap 的 remove 方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/JDK_source/26-ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#concurrenthashmap-小结" class="router-link-active router-link-exact-active toc-link level2">ConcurrentHashMap 小结</a></li><!----><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><table><thead><tr><th>版本</th><th>内容</th><th>时间</th></tr></thead><tbody><tr><td>V1</td><td>新建</td><td>2022年12月02日00:23:46</td></tr></tbody></table><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>我们知道 HashMap 不是线程安全的，在 JDK1.5 之前JDK 提供的同步的 Map 有 Hashtable 和使用 Collections. synchronizedMap 返回一个同步代理类 SynchronizedMap，这两种方式都是在 Map 的每个方法添加一个 Synchronized 关键字实现同步的。</p><p>JDK1.5 的时候出现了 ConcurrentHashMap，由于每个版本的 JDK 的 ConcurrentHashMap 的实现方式不同，本次分析的是 JDK8。</p><p>JDK1.6 的时候出现了 ConcurrentSkipListSet，跳表结构，前面已经分析了。</p><h2 id="继承关系" tabindex="-1"><a class="header-anchor" href="#继承关系" aria-hidden="true">#</a> 继承关系</h2><p>首先看下 ConcurrentHashMap 的类的继承关系：</p><p><img src="/assets/38-ConcurrentHashMap类继承关系-82252565.png" alt="38-ConcurrentHashMap类继承关系"></p><p>在 ConcurrentHashMap 中有很多内部类，先看下它们的类关系，再看下他们代表什么含义。</p><h2 id="concurrenthashmap-的内部结构" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-的内部结构" aria-hidden="true">#</a> ConcurrentHashMap 的内部结构</h2><h3 id="各个节点的继承关系" tabindex="-1"><a class="header-anchor" href="#各个节点的继承关系" aria-hidden="true">#</a> 各个节点的继承关系</h3><p><img src="/assets/39-ConcurrentHashMap内部类类图-7e5dc36c.png" alt="39-ConcurrentHashMap内部类类图"></p><p>ConcurrentHashMap 和 HashMap 一样都有一个数组 table，ConcurrentHashMap 这个 table 上有四种类型的节点，分别是 Node、ForwardingNode、TreeBin、TreeNode、ReservationNode。</p><h3 id="节点的作用" tabindex="-1"><a class="header-anchor" href="#节点的作用" aria-hidden="true">#</a> 节点的作用</h3><p><img src="/assets/40-ConcurrentHashMap各个节点结构-ab0e9659.png" alt="40-ConcurrentHashMap各个节点结构"></p><p>下面分别说下它们都有什么用处：</p><ul><li><strong>Node</strong>：Node 节点存放在数组的一个桶位中，当发生哈希冲突的时候会以 Node 链表的形式存储。(当满足一定条件的时候会变成红黑树)；</li><li><strong>ForwardingNode</strong>：临时节点，哈希值固定为 -1，只会在扩容的时候出现。当哈希表中的元素个数超过阈值后会进行扩容，扩容会将旧数组高位索引处开始迁移每个桶位的节点到新数组 nextTable 中，某个桶位迁移完成后，就会给旧数组的该桶位放一个 ForwardingNode 节点。其他线程在扩容期间访问数据的时候，假如发现桶位是 ForwardingNode 节点，就需要去新数组里去查询了；</li><li><strong>TreeBin</strong>：哈希值固定为 -2。TreeBin 指向红黑树的根节点。当某个桶位满足了转变红黑树的条件，会在桶位处放置一个 TreeBin 节点，桶位之前的链表数据会转变成一个 TreeNode 节点的红黑树，挂在 TreeBin 节点下；</li><li><strong>TreeNode</strong>：红黑树节点；</li><li><strong>ReservationNode</strong>：保留节点，哈希值固定为 -3。在ConcurrentHashMap中就相当于一个占位符，不存储实际的数据，正常情况不会出现。在 computeIfAbsent 和 compute 这两个函数在加锁时会使用 ReservationNode 作占位符；</li></ul><h3 id="节点的定义" tabindex="-1"><a class="header-anchor" href="#节点的定义" aria-hidden="true">#</a> 节点的定义</h3><p><strong>单链表链表 Node 节点</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>             <span class="token comment">// 哈希值</span>
    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>                <span class="token comment">// key</span>
    <span class="token keyword">volatile</span> <span class="token class-name">V</span> val<span class="token punctuation">;</span>             <span class="token comment">// value</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>    <span class="token comment">// next 指针</span>
    
    <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>TreeBin 节点</strong></p><ul><li>root：指向红黑树的根节点；</li><li>first：链表结构的根节点，红黑树中也维护了链表结构；</li><li>waiter：最近的一个设置 WAITER 标志位的线程，当前 lockstate 是读锁状态；</li><li>lockState：整体的锁状态标志位，写是独占状态（同一个 TreeBin 对象），读是共享的；</li></ul><p>TreeBin 节点用一个 int 数表示读写锁的状态</p><table><thead><tr><th>常量</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>WRITER</td><td>1</td><td>二进制 001，红黑树的写锁状态</td></tr><tr><td>WAITER</td><td>2</td><td>二进制 010，红黑树的等待获取写锁状态</td></tr><tr><td>READER</td><td>4</td><td>二进制 100，红黑树的读锁状态，读可以并发，每多一个读线程，lockState 都就上一个 READER 值</td></tr></tbody></table><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> root<span class="token punctuation">;</span>                
    <span class="token keyword">volatile</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Thread</span> waiter<span class="token punctuation">;</span>             
    <span class="token keyword">volatile</span> <span class="token keyword">int</span> lockState<span class="token punctuation">;</span>    
    <span class="token comment">// values for lockState</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">WRITER</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// set while holding write lock             </span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">WAITER</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">// set when waiting for write lock          </span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">READER</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">// increment value for setting read lock</span>
    
    
	<span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Q：为什么要用一个 TreeBin 节点指向红黑树的根节点呢？</strong></p><p>因为 ConcurrentHashMap 中处理某个的桶位的一些节点的时候是需要给在数组桶位上的节点加同步锁的，而红黑树的插入、删除这些操作时，平衡过程中的左旋右旋操作可能旧的根节点不再是根节点，这样同步就比较麻烦了。但是新加一个 TreeBin 节点，就可以在这个节点上做同步操作了。</p><p><strong>红黑树的 TreeNode 节点</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> parent<span class="token punctuation">;</span>  <span class="token comment">// red-black tree links</span>
    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> left<span class="token punctuation">;</span>    <span class="token comment">// 左子节点</span>
    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> right<span class="token punctuation">;</span>   <span class="token comment">// 右子节点</span>
    <span class="token comment">/*
     * prev指针是为了方便删除.
     * 删除链表的非头结点时，需要知道它的前驱结点才能删除，所以直接提供一个prev指针
     */</span>
    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">;</span>    <span class="token comment">// needed to unlink next upon deletion</span>
    <span class="token keyword">boolean</span> red<span class="token punctuation">;</span>

	<span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>扩容临时节点 ForwardingNode</strong></p><p>可以看到有个 nextTable 属性，这个属性就是指向扩容后的新的数组。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ForwardingNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTable<span class="token punctuation">;</span>

    <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>占位节点 ReservationNode</strong>，没什么新的属性，和 Node 的一样。</p><h2 id="concurrenthashmap-构造方法" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-构造方法" aria-hidden="true">#</a> ConcurrentHashMap 构造方法</h2><p>ConcurrentHashMap 的数组一定是 2 的 n 次幂。</p><p><strong>一个原因是可以使用位运算高效的计算索引值，让 key 均匀分布，减少哈希冲突；</strong></p><p><strong>另一个原因就是扩容迁移的便捷及高效，可以实现多线程并发协作完成数据迁移。</strong></p><p><strong>（1）空构造</strong></p><p>数组的默认初始容量是 16。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>（2）设置初始容量的构造函数</strong></p><p>根据入参计算出数组的初始容量，<code>initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)</code>的最小 2 的次幂值。</p><blockquote><p>sizeCtl 在不同的情况下存的值的含义不同，这个情况表示的是创建数组时的初始容量。</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> cap <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span>
                   <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">:</span>
                   <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 这个时候存的是数组的初始长度</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>sizeCtl <span class="token operator">=</span> cap<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>（3）通过已有的 Map 构造</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>sizeCtl <span class="token operator">=</span> <span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">;</span>
    <span class="token function">putAll</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>（4）初始容量和加载因子</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>（5）初始容量，加载因子和并发级别</strong></p><blockquote><p>loadFactor 并不是真正的加载因子，仅仅在构造函数中计算了下初始容量，失去了原来的意义，JDK8 的 ConcurrentHashMap 的加载因子固定 0.75。</p><p>concurrencyLevel 只是为了兼容 JDK8 之前的版本，在 JDK8 中也不代表并发级别了，这里只是做了点校验，没有实际的作用。</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span>
                         <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">int</span> concurrencyLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>loadFactor <span class="token operator">&gt;</span> <span class="token number">0.0f</span><span class="token punctuation">)</span> <span class="token operator">||</span> initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> concurrencyLevel <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> concurrencyLevel<span class="token punctuation">)</span>   <span class="token comment">// Use at least as many bins</span>
        initialCapacity <span class="token operator">=</span> concurrencyLevel<span class="token punctuation">;</span>   <span class="token comment">// as estimated threads</span>
    <span class="token keyword">long</span> size <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>initialCapacity <span class="token operator">/</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> cap <span class="token operator">=</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token operator">?</span>
        <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">:</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>sizeCtl <span class="token operator">=</span> cap<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="concurrenthashmap-属性" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-属性" aria-hidden="true">#</a> ConcurrentHashMap 属性</h2><p>首先是两个数组相关的属性：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 哈希表的底层桶的数组，在第一次新增元素的时候初始化</span>
<span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>

<span class="token comment">// 扩容后的新 Node 数组，只有在扩容时才非空。</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTable<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于计数相关的属性，就是 LongAdder 类里的属性，只是把 LongAdder 的实现方式搬到 ConcurrentHashMap 里面来了。</p><p>关于这几个属性不理解的，可以去看 LongAdder 的实现方式。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 类似 LongAdder 的 base</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> baseCount<span class="token punctuation">;</span>

<span class="token comment">// 类似 LongAdder 的 cellsBusy，锁，在扩容和创建 cell 时使用，1-有锁状态， 0-无锁状态</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> cellsBusy<span class="token punctuation">;</span>

<span class="token comment">//  类似 LongAdder 的 Cell[] 数组</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">CounterCell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> counterCells<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>线程扩容用到的转移桶位的索引。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 扩容时需要用到的一个下标变量</span>
<span class="token comment">// table[transferIndex-stride, transferIndex-1]就是当前线程要进行数据迁移的桶区间：</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> transferIndex<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>sizeCtl 变量，这个属性的值在不同的场景下的取值表示的含义不同。</p><ul><li><strong>sizeCtl 等于 0</strong>： 表示在初始化数组的时候，使用默认的初始容量；</li><li><strong>sizeCtl 大于 0</strong>：两种情况 <ol><li>数组初始化时使用的容量；</li><li>初始化或者扩容完成后，下次扩容的阈值，其实就是 0.75n（n 是数组长度）；</li></ol></li><li><strong>sizeCtl 等于 -1</strong>：表示数组正在被某个线程初始化；</li><li><strong>sizeCtl 低位等于 -(1 + nThreads)</strong>：记录正在执行扩容任务的线程数；高 16 位保存着扩容戳，低 16 位保存着并发扩容的线程总数；</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * Table initialization and resizing control.  When negative, the
 * table is being initialized or resized: -1 for initialization,
 * else -(1 + the number of active resizing threads).  Otherwise,
 * when table is null, holds the initial table size to use upon
 * creation, or 0 for default. After initialization, holds the
 * next element count value upon which to resize the table.
 */</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> sizeCtl<span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="concurrenthashmap-的-put-操作" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-的-put-操作" aria-hidden="true">#</a> ConcurrentHashMap 的 put 操作</h2><p>ConcurrentHashMap 的 key 和 value 都不能为 null，否则会报错。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>put 操作的流程有点长，接下来会分几个步骤去分析。</p><p>先看下 ConcurrentHashMap#spread 方法，<code>(h ^ (h &gt;&gt;&gt; 16))</code>操作是将 h 的高 16 位和低 16 位做异或操作，这样得到的数就具有高位和低位的特性了，最后与上 <code>0x7fffffff</code>是为了将最高位强制设为 0（正数）。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">HASH_BITS</span> <span class="token operator">=</span> <span class="token number">0x7fffffff</span><span class="token punctuation">;</span> <span class="token comment">// usable bits of normal node hash</span>

<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">spread</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token constant">HASH_BITS</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看下 put 的完整代码</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> value <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 再次计算 key 的哈希值</span>
    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/*
     * 使用链表保存时，binCount 记录 table[i] 这个桶中所保存的结点数；
     * 使用红黑树保存时，binCount == 2，保证 put 后更改计数值时能够进行扩容检查，同时不触发红黑树化操作
     */</span>
    <span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 开启自旋，插入结点，直到成功</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/*
             * f:   根据哈希路由寻址得到的数组的索引的元素，可能是 null
             * n:   底层数组的长度
             * i:   根据哈希路由寻址得到的数组的索引
             * fh:  f 的哈希值
             */</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fh<span class="token punctuation">;</span>
        <span class="token comment">// CASE 1：底层数组未初始化，需要初始化数组</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            tab <span class="token operator">=</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// CASE 2：前提是底层数组已经初始化了，下面这个条件成立，</span>
        <span class="token comment">// 说明哈希寻址的位置还未被占用，其实就是未发生哈希冲突</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// CAS 尝试将 i 位置的元素由 null 改为新建的节点 Node</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment">// 修改成功，则直接退出自旋</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>                   <span class="token comment">// no lock when adding to empty bin</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// CASE 3：前置条件是数组已经初始化了，且哈希寻址的位置被占用了，也就是哈希冲突了</span>
        <span class="token comment">// 发现 ForwardingNode 结点，哈希是 MOVED 的时候，说明此时数组正在扩容，当前线程需要去帮助扩容</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">MOVED</span><span class="token punctuation">)</span>
            tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// CASE 4：前置条件是数组已经初始化了，也就是哈希冲突，且当前数组未正在扩容</span>
        <span class="token comment">// 这是需要新建节点挂载链表，或者红黑树上</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token class-name">V</span> oldVal <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token comment">// 给 table[i] 桶节点加锁</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 二次检查，防止其它线程的写修改</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 判断 table[i] 是链表结点</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">// 这个桶位的元素个数，初始值是 1，</span>
                        binCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                        <span class="token comment">// 处理链表</span>
                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token class-name">K</span> ek<span class="token punctuation">;</span>
                            <span class="token comment">// 找到“相等”的结点，根据 onlyIfAbsent 参数决定是否需要替换 value，并退出循环</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                oldVal <span class="token operator">=</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>
                                    e<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
                                <span class="token keyword">break</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>

                            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> pred <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token comment">// e 每次后移一个节点</span>
                            <span class="token comment">// 直到到达了最后一个节点，就创建一个新节点将元素插到链表最后（尾插法）</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token keyword">break</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 说明 tablep[i] 位置的元素是红黑树节点 TreeBin</span>
                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span>
                        binCount <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            oldVal <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>
                                p<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// binCount != 0 说明发送哈希冲突了</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 当链表长度大于等于 8 的时候尝试树化</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span><span class="token punctuation">)</span>
                    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    <span class="token comment">// 表明本次 put 操作只是替换了旧值，不用更改计数值</span>
                    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">,</span> binCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>第一步就是开启一个自旋，直到插入元素或者替换元素成功。</li><li>第二步就是调用 ConcurrentHashMap#addCount 方法，增加计数和判断是否需要扩容。（计数部分下节分析）</li></ul><h3 id="懒加载-初始化-table" tabindex="-1"><a class="header-anchor" href="#懒加载-初始化-table" aria-hidden="true">#</a> 懒加载-初始化 table</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    tab <span class="token operator">=</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>添加元素时，假如数组还未初始化，需要调用 ConcurrentHashMap#initTable 方法去初始化数组。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 初始化底层数组，使用 sizeCtl 作为初始化容量</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token keyword">int</span> sc<span class="token punctuation">;</span>
    <span class="token comment">// 自旋直到数组初始化成功</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// sizeCtl 小于 0，说明此时数组正在被其他线程初始化或者扩容，在这个场景下就是初始化了，需要当前线程需要让步</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lost initialization race; just spin</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 进入这里，说明 CAS 将 SIZECTL 改为 -1 了，让当前线程去做初始化数组的操作</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 二次检查</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// n 初始容量，2 的 n 次幂</span>
                    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span>sc <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> sc <span class="token operator">:</span> <span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">;</span>
                    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    table <span class="token operator">=</span> tab <span class="token operator">=</span> nt<span class="token punctuation">;</span>
                    <span class="token comment">// 得到的 sc 就是 0.75n, loadFactor 已在 JDK8 废弃，固定就是 0.75</span>
                    sc <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                <span class="token comment">// 设置下次扩容阈值 0.75 * table.length</span>
                <span class="token comment">// 也有可能是上面的二次检查不通过，这里需要将 sizeCtl 从 -1 改为之前的值</span>
                sizeCtl <span class="token operator">=</span> sc<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> tab<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初始化的流程很简单，</p><ol><li>就是尝试 CAS 将 sizeCtl 改为 -1，表示线程正在初始化数组，修改成功后进行二次检查；</li><li>然后根据 sizeCtl 的值来决定数组的初始长度。sizeCtl 大于 0 则创建 sizeCtl 大小的数组，否则使用默认的 16 作为数组长度；</li><li>最后计算 Map 的下次扩容阈值，<code>n - (n &gt;&gt;&gt; 2)</code>，就是 0.75n；</li></ol><h3 id="哈希寻址到的桶位为空" tabindex="-1"><a class="header-anchor" href="#哈希寻址到的桶位为空" aria-hidden="true">#</a> 哈希寻址到的桶位为空</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// CAS 尝试将 i 位置的元素由 null 改为新建的节点 Node</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 修改成功，则直接退出自旋</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>                   <span class="token comment">// no lock when adding to empty bin</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为 ConcurrentHashMap 的数组的长度已经限制为 2 的 n 次幂了，所以 <code>(n - 1) &amp; hash)</code> 就是等于是取余运算了。</p><p>假如哈希寻址得到的桶位 table[i] 的位置是空的，那么尝试 CAS 去设置该位置的值，假如设置成功了，那就是 put 元素成功了，直接退出循环。假如设置失败了，那么就说明发生竞争了，重新开始自旋操作。</p><h3 id="找到-forwardingnode-节点" tabindex="-1"><a class="header-anchor" href="#找到-forwardingnode-节点" aria-hidden="true">#</a> 找到 ForwardingNode 节点</h3><p>ForwardingNode 节点的哈希值默认就是 MOVED（-1），说明 ConcurrentHashMap 正在进行扩容操作，<strong>当前线程需要尝试协助扩容。</strong></p><p>关于扩容操作后面分析，这里先不讲了。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">MOVED</span><span class="token punctuation">)</span>
    tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="发送哈希冲突了且并未在扩容" tabindex="-1"><a class="header-anchor" href="#发送哈希冲突了且并未在扩容" aria-hidden="true">#</a> 发送哈希冲突了且并未在扩容</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token class-name">V</span> oldVal <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 给 table[i] 桶节点加锁</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 二次检查，防止其它线程的写修改</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 判断 table[i] 是链表结点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 这个桶位的元素个数，初始值是 1，</span>
                binCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token comment">// 处理链表</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">K</span> ek<span class="token punctuation">;</span>
                    <span class="token comment">// 找到“相等”的结点，根据 onlyIfAbsent 参数决定是否需要替换 value，并退出循环</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        oldVal <span class="token operator">=</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>
                            e<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>

                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> pred <span class="token operator">=</span> e<span class="token punctuation">;</span>
                    <span class="token comment">// e 每次后移一个节点</span>
                    <span class="token comment">// 直到到达了最后一个节点，就创建一个新节点将元素插到链表最后（尾插法）</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 说明 tablep[i] 位置的元素是红黑树节点 TreeBin</span>
                <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span>
                binCount <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    oldVal <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>
                        p<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// binCount != 0 说明发送哈希冲突了</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当链表长度大于等于 8 的时候尝试树化</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span><span class="token punctuation">)</span>
            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token comment">// 表明本次 put 操作只是替换了旧值，不用更改计数值</span>
            <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>处理哈希冲突的代码比较长，但是逻辑还是比较清楚的。主要分为两部分来处理，一种是链表一种是红黑树。</p><ol><li>首先将 table[i] 桶位节点当做锁对象给代码块加锁，加锁成功后还需要进行二次检查桶位节点是否有改变；</li><li>处理插入操作，分为链表和红黑树不同的情况： <ol><li>链表：使用 binCount 记录链表的元素个数，使用尾插法将新添加的元素插入到链表中；</li><li>红黑树：binCount 固定为 2，调用 TreeBin#putTreeVal 的方法将元素插入到红黑树中，然后平衡红黑树；</li></ol></li><li>最后，判断链表的长度是否大于等于 8，如果大于登录则尝试树化链表；</li></ol><h3 id="concurrenthashmap-树化操作" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-树化操作" aria-hidden="true">#</a> ConcurrentHashMap 树化操作</h3><p><strong>假如链表的长度大于等于 8，则尝试树化链表，但是这并不是树化链表的唯一条件。</strong></p><p><strong>还需要满足数组长度至少是 64 才会去树化链表，小于 64 则会去尝试将数组扩容一倍。</strong></p><p><strong>Q：为什么还要满足 64 才去触发树化链表呢？</strong></p><p>因为当数组的长度比较小的时候，很容易发生哈希冲突，出于性能考虑，为了减少哈希冲突和避免频繁的扩容迁移，除了需要满足链表的长度大于等于 8，还需满足数组的长度至少是 64，才会去进行树化操作。</p><p>treeifyBin 方法是尝试树化链表的操作。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeifyBin</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> b<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> sc<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MIN_TREEIFY_CAPACITY</span><span class="token punctuation">)</span>
            <span class="token comment">// 说明数组的长度小于 64，需要进行扩容数组一倍，而不是树化</span>
            <span class="token comment">// 因为数组长度小的时候，容易发生哈希碰撞</span>
            <span class="token function">tryPresize</span><span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 进行链表树化的操作</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">.</span>hash <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hd <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> tl <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token comment">// 遍历链表，建立红黑树，TreeNode是一个双向链表</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> b<span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> e<span class="token punctuation">.</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span>val<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> tl<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                            hd <span class="token operator">=</span> p<span class="token punctuation">;</span>
                        <span class="token keyword">else</span>
                            tl<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
                        tl <span class="token operator">=</span> p<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment">// 用 TreeBin 节点包装，并存到 table[index] 中</span>
                    <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="putval-操作的整体流程图" tabindex="-1"><a class="header-anchor" href="#putval-操作的整体流程图" aria-hidden="true">#</a> putVal 操作的整体流程图</h3><p><img src="/assets/41-ConcurrentHashMap的putVal流程图-77b37c7f.png" alt="41-ConcurrentHashMap的putVal流程图"></p><h2 id="concurrenthashmap-的计数操作" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-的计数操作" aria-hidden="true">#</a> ConcurrentHashMap 的计数操作</h2><p>前面分析 ConcurrentHashMap 的 put 的操作时，没有分析 ConcurrentHashMap#addCount 方法，现在来分析下 ConcurrentHashMap 计数功能。</p><p>前面说了 ConcurrentHashMap 的 计数功能就是将 LongAdder 的实现的代码照搬过来了。</p><p>这里大概说明下原理。</p><p><strong>LongAdder 使用分段锁的思想，在线程没有发生竞争的时候针对 base 字段进行累加。在线程发生竞争时，将这些线程按照哈希路由寻址的路由到 cell 数组的某个索引处，每个线程针对对应的 cell 数组的元素进行 CAS 操作，这样就将一个热点分散成了多个热点，发生竞争的概率就会小很多。</strong></p><p>LongAdder 的 sum 方法返回的并不是一个准确的值，这也是 LongAdder 不能替代 AtomicLong 的一个原因。</p><p>下面是 ConcurrentHashMap#sumCount 的代码。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">sumCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">CounterCell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> as <span class="token operator">=</span> counterCells<span class="token punctuation">;</span> <span class="token class-name">CounterCell</span> a<span class="token punctuation">;</span>
    <span class="token keyword">long</span> sum <span class="token operator">=</span> baseCount<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>as <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> as<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                sum <span class="token operator">+=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么来看下 ConcurrentHashMap#addCount 方法，主要分为两个部分：</p><ol><li>增加计数；（这里不再分析，不懂的可以去看我的 LongAdder 分析）</li><li>判断是否需要扩容；（这里不分析，后面章节分析扩容的时候分析）</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> check<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">CounterCell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> as<span class="token punctuation">;</span> <span class="token keyword">long</span> b<span class="token punctuation">,</span> s<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>as <span class="token operator">=</span> counterCells<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span>
            <span class="token operator">||</span> <span class="token operator">!</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">BASECOUNT</span><span class="token punctuation">,</span> b <span class="token operator">=</span> baseCount<span class="token punctuation">,</span> s <span class="token operator">=</span> b <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">/</span>
        <span class="token class-name">CounterCell</span> a<span class="token punctuation">;</span> <span class="token keyword">long</span> v<span class="token punctuation">;</span> <span class="token keyword">int</span> m<span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> uncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>as <span class="token operator">==</span> <span class="token keyword">null</span>
                <span class="token operator">||</span> <span class="token punctuation">(</span>m <span class="token operator">=</span> as<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span>
                <span class="token operator">||</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span><span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span>
                <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>uncontended <span class="token operator">=</span> <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token constant">CELLVALUE</span><span class="token punctuation">,</span> v <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">,</span> v <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 增加 count 值</span>
            <span class="token function">fullAddCount</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> uncontended<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 这里直接 return 的原因，我猜是因为多运行了 fullAddCount 方法，多了些耗时，</span>
            <span class="token comment">// 为了 put 的效率，就不检查扩容了</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// check &lt;= 1 不检查扩容，仅检查是否发生竞争</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>check <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取 count 的个数，并不是实时性的</span>
        s <span class="token operator">=</span> <span class="token function">sumCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 检查是否扩容</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>check <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> nt<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> sc<span class="token punctuation">;</span>
        <span class="token comment">// while 条件成立，说明已经到了扩容阈值了(或者是已经有线程在扩容了，需要去帮忙)，需要去尝试扩容</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
               <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 计算一个戳，相同的数组长度 n 计算出来的戳是一样的</span>
            <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// CASE 1 : 表示正在扩容，此时 sizeCtl 的组成就是  -(1 + nThreads)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>sc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">/*
                 * sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs 校验扩容的戳
                 * (nt = nextTable) == null         成立则说明 nextTable 还未创建，还扩个锤子
                 */</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">&gt;&gt;&gt;</span> <span class="token constant">RESIZE_STAMP_SHIFT</span><span class="token punctuation">)</span> <span class="token operator">!=</span> rs
                        <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token number">1</span>
                        <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token constant">MAX_RESIZERS</span>
                        <span class="token operator">||</span> <span class="token punctuation">(</span>nt <span class="token operator">=</span> nextTable<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span>
                        <span class="token operator">||</span> transferIndex <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc<span class="token punctuation">,</span> sc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> nt<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">/*
             * CASE 2 : 说明是首次进行扩容操作的线程，尝试 CAS 修改 sizeCtl
             * 因为 sizeCtl 扩容的时候 -(1 + nThreads) : 记录正在执行扩容任务的线程数
             * 最后 +2，就是 -(1 + 1)，表示有一个线程在扩容，
             * 高 16 位是戳，低 16 位记录正在执行扩容任务的线程数
             */</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;&lt;</span> <span class="token constant">RESIZE_STAMP_SHIFT</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            s <span class="token operator">=</span> <span class="token function">sumCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="concurrenthashmap-的扩容操作" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-的扩容操作" aria-hidden="true">#</a> ConcurrentHashMap 的扩容操作</h2><h3 id="扩容的基本原理" tabindex="-1"><a class="header-anchor" href="#扩容的基本原理" aria-hidden="true">#</a> 扩容的基本原理</h3><p>ConcurrentHashMap 的扩容操作分为两个步骤：</p><ol><li><strong>创建一个新的 2 倍于原来的数组长度的新数组</strong>（这个操作只能一个线程完成）；</li><li><strong>将旧数组的每个桶位的节点迁移到新数组对应桶位处</strong>；</li></ol><p>那么如何计算旧的节点在新数组的位置呢？索引位置的计算公式就是 <code>key.hash &amp; (table.length - 1)</code>。</p><p>ConcurrentHashMap 在处理 rehash 的时候并不会重新计算 key 的哈希值，因为数组的长度必定是 2 的 n 次幂，根据这一特性，通过 <code>key.hash &amp; (table.length - 1)</code>计算出来的索引 i，<strong>当数组 table 扩容一倍后，在数组的位置要么是 i，要么是 i + n。</strong></p><p>举个例子看：</p><p>假如数组的长度是 16，假如 key1 的哈希是 1010 1010， key2 的哈希是 1011 1010。</p><p>旧数组长度 16 - 1 是 15，二进制就是 00001111。</p><p>在旧的数组中通过公式计算出来的索引是</p><ol><li>00001111 &amp; 1010 1010 = 0000 1010 = 10</li><li>00001111 &amp; 1011 1010 = 0000 1010 = 10</li></ol><p>新数组长度是 32，32 -1 = 31，二进制就是 00011111。</p><p>在新的数组中通过公式计算出来的索引是</p><ol><li>00011111 &amp; 1010 1010 = 0000 1010 = 10</li><li>00011111 &amp; 1011 1010 = 0001 1010 = 26</li></ol><p>从这个例子可以看出 key1 在扩容后的位置是 10 不变，key2 在扩容后的位置是 10 + 16 = 26。</p><p>扩容原理小结：</p><p>因为数组长度是 2 的 n 次幂值，假如目前 key 键在旧数组的索引位置为i，当数组扩容一倍后，key 键在新数组的索引的规律是：</p><ol><li>如果 key 的哈希值<code>hash &amp; table.length==0</code>，说明哈希二进制的从右向左的第 n 个 bit 位为 0，迁移后 key 在新数组中索引值不变，仍为 i。</li><li>如果key的哈希值<code>hash &amp; table.length＞0</code>，说明哈希二进制的从右向左的第 n 个bit位为 1，迁移后 key 在新数组中索引值为 i + table.length。</li></ol><p>另外如果两个不同的键值在旧数组中索引位置就已经不同了，那么这两个键值映射到新数组的位置肯定也是不同的。所以数组中每个桶节点的迁移不会相互影响，利用这个特性在数据迁移时，可以多线程并发迁移不同桶的元素。<strong>所以在扩容的时候需要给每个线程在数组上划分一个区间，让某个线程负责给这个区间的桶位节点的迁移。</strong></p><h3 id="触发扩容的时机" tabindex="-1"><a class="header-anchor" href="#触发扩容的时机" aria-hidden="true">#</a> 触发扩容的时机</h3><p>前面在分析 ConcurrentHashMap 的计数操作的时候，ConcurrentHashMap#addCount 方法最后会检查是否需要扩容。下面分析下 ConcurrentHashMap#addCount 中检查扩容的部分代码。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> check<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 省略计数逻辑的代码.....</span>

        <span class="token comment">// 检查是否扩容</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>check <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> nt<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> sc<span class="token punctuation">;</span>
            <span class="token comment">// while 条件成立，说明已经到了扩容阈值了(或者是已经有线程在扩容了，需要去帮忙)，需要去尝试扩容</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
                   <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 计算一个戳，相同的数组长度 n 计算出来的戳是一样的</span>
                <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// CASE 1 : 表示正在扩容，此时 sizeCtl 的组成就是  -(1 + nThreads)</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>sc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">/*
                     * sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs 校验扩容的戳
                     * (nt = nextTable) == null         成立则说明 nextTable 还未创建，还扩个锤子
                     */</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">&gt;&gt;&gt;</span> <span class="token constant">RESIZE_STAMP_SHIFT</span><span class="token punctuation">)</span> <span class="token operator">!=</span> rs
                            <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token number">1</span>
                            <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token constant">MAX_RESIZERS</span>
                            <span class="token operator">||</span> <span class="token punctuation">(</span>nt <span class="token operator">=</span> nextTable<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span>
                            <span class="token operator">||</span> transferIndex <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc<span class="token punctuation">,</span> sc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> nt<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">/*
                 * CASE 2 : 说明是首次进行扩容操作的线程，尝试 CAS 修改 sizeCtl
                 * 因为 sizeCtl 扩容的时候 -(1 + nThreads) : 记录正在执行扩容任务的线程数
                 * 最后 +2，就是 -(1 + 1)，表示有一个线程在扩容，
                 * 高 16 位是戳，低 16 位记录正在执行扩容任务的线程数
                 */</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;&lt;</span> <span class="token constant">RESIZE_STAMP_SHIFT</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                s <span class="token operator">=</span> <span class="token function">sumCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要重点看 while 循环部分的代码</p><p>（1）首先看 while 条件，这个 s 是 ConcurrentHashMap 中元素的个数（期望值，因为计数用的是 LongAdder 的实现），sizeCtl 是正数且数组已经初始化的情况下表示的是下次扩容的阈值。假如 <code>s &gt;= (long)(sc = sizeCtl)</code> 成立，则说明需要扩容了；</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
       <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// ...</span>
       <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）根据旧数组的长度，计算出一个扩容的戳出来。在扩容的时候，sizeCtl 表示扩容状态，高 16 位保存着扩容戳，低 16 位保存着并发扩容的线程总数；</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（3）根据此时 sizeCtl 的取值去走不同的逻辑，协助扩容还是初始化扩容逻辑。</p><p>先看初始化扩容的逻辑。走到 else if 的前提是 <code>sc &gt;= 0</code>，说明是首次进行扩容的操作，尝试 CAS 修改 sizeCtl 的值，因为 sizeCtl 扩容的时候 -(1 + nThreads) ，记录正在执行扩容任务的线程数，最后 +2，就是 -(1 + 1)，表示有一个线程在扩容。最后调用了 ConcurrentHashMap#transfer 方法。</p><p>为什么第一个线程尝试扩容时是 +2，而不是 +1 呢？这是因为 <code>rs &lt;&lt; 16 +1</code>有其他含义，表示扩容结束。当第一个线程扩容结束后，会将 sizeCtl 减 1，即：<code>rs &lt;&lt; 16 +1</code>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">/*
 * CASE 2 : 说明是首次进行扩容操作的线程，尝试 CAS 修改 sizeCtl
 * 因为 sizeCtl 扩容的时候 -(1 + nThreads) : 记录正在执行扩容任务的线程数
 * 最后 +2，就是 -(1 + 1)，表示有一个线程在扩容，
 * 高 16 位是戳，低 16 位记录正在执行扩容任务的线程数
 */</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;&lt;</span> <span class="token constant">RESIZE_STAMP_SHIFT</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如 <code>sc &lt; 0</code>，说明 ConcurrentHashMap 已经在扩容进行中了，此时线程需要协助扩容。</p><p>首先有一个 if 判断，这里面 JDK8 是有 bug 的，下面依次分析这几个条件：</p><ol><li><code>(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</code>：这是检验扩容戳是否一致，相同数组长度扩容的扩容戳一致；</li><li><code>sc == rs + 1</code>：JDK8 的 Bug，本意是<code>sc == (rs &gt;&gt;&gt; 16) + 1</code>，表示本次扩容已经完了，没有线程在扩容了；</li><li><code>sc == rs + MAX_RESIZERS</code>：JDK8 的 Bug，本意是<code>sc == (rs &gt;&gt;&gt; 16) + MAX_RESIZERS</code>，表示本次扩容的线程个数已经超限了；</li><li><code>(nt = nextTable) == null</code>：nextTable 为 null 说明已经扩容完毕了，或者根本没扩容的意思；</li><li><code>transferIndex &lt;= 0</code>：扩容过程中 transferIndex 的是大于 0 的，因为扩容是从数组的高索引向 0 迁移数组的；</li></ol><p>校验通过后会调用 ConcurrentHashMap#transfer 方法去进行扩容和迁移数据。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// CASE 1 : 表示正在扩容，此时 sizeCtl 的组成就是  -(1 + nThreads)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>sc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
     * sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs 校验扩容的戳
     * (nt = nextTable) == null         成立则说明 nextTable 还未创建，还扩个锤子
     */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">&gt;&gt;&gt;</span> <span class="token constant">RESIZE_STAMP_SHIFT</span><span class="token punctuation">)</span> <span class="token operator">!=</span> rs
            <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token constant">MAX_RESIZERS</span>
            <span class="token operator">||</span> <span class="token punctuation">(</span>nt <span class="token operator">=</span> nextTable<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span>
            <span class="token operator">||</span> transferIndex <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc<span class="token punctuation">,</span> sc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> nt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="迁移数据的操作" tabindex="-1"><a class="header-anchor" href="#迁移数据的操作" aria-hidden="true">#</a> 迁移数据的操作</h3><p>数据迁移的操作在 ConcurrentHashMap#transfer 方法中处理。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTab<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看下 ConcurrentHashMap#transfer 的入参：</p><ol><li>tab：扩容前的旧的数组；</li><li>nextTab：扩容中的新的数组，其他线程协助扩容的时候才会传这个参数；</li></ol><p>数据迁移的代码非常长，这里也是分段分析。</p><p>（1）首先需要计算步长 stride，就是扩容时单个线程负责多少个桶位的数据迁移。</p><ul><li>当机器的核心数是 1 的时候，步长是 n，也就是最多只允许单个线程进行数据迁移；</li><li>步长的最小值是 16，也就说单个线程最少负责 16 个桶位的数据迁移；</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>stride <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">NCPU</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token constant">NCPU</span> <span class="token operator">:</span> n<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MIN_TRANSFER_STRIDE</span><span class="token punctuation">)</span>
    stride <span class="token operator">=</span> <span class="token constant">MIN_TRANSFER_STRIDE</span><span class="token punctuation">;</span> <span class="token comment">// subdivide range</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）假如是第一个到 transfer 方法里面来做数据迁移的线程，那么此时 nextTable 一定是 null，所以此时需要初始化一个 nextTable 数组。并初始化 transferIndex 的值为旧数组的长度。</p><p>这里给 transferIndex 赋值为 n 说明是按照索引的大到小的顺序转移的，范围<code>[transferIndex-stride, transferIndex-1]</code>表示当前线程要进行数据迁移的桶区间。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>nextTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// initiating</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        nextTab <span class="token operator">=</span> nt<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// try to cope with OOME</span>
        sizeCtl <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    nextTable <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>
    <span class="token comment">// [transferIndex-stride, transferIndex-1] 表示当前线程要进行数据迁移的桶区间</span>
    transferIndex <span class="token operator">=</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（3）接下来就是开启一个自旋来进行数据迁移了，分为三个步骤：</p><ul><li>第一步就是确认线程负责迁移那些桶位的数据（定位）；</li><li>第二步就是依次迁移数据（迁移）；</li><li>第三步是在所有桶位迁移完后，再次检查一遍所有桶位是否迁移完毕（检查）;</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 新数组的长度</span>
<span class="token keyword">int</span> nextn <span class="token operator">=</span> nextTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token comment">// 创建 ForwardingNode 结点，当旧数组的某个桶中的所有结点都迁移完后，用该结点占据这个桶</span>
<span class="token class-name">ForwardingNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> fwd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForwardingNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>nextTab<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 标识一个桶的迁移工作是否完成，advance == true 表示可以进行下一个位置的迁移</span>
<span class="token keyword">boolean</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token comment">// 最后一个数据迁移的线程将该值置为 true，并进行本轮扩容的收尾工作</span>
<span class="token keyword">boolean</span> finishing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// to ensure sweep before committing nextTab</span>
<span class="token comment">// 开启自旋，i 标识桶索引, bound 标识边界</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bound <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> fh<span class="token punctuation">;</span>
    <span class="token comment">// 每一次自旋前的预处理，主要是定位本轮处理的桶区间</span>
    <span class="token comment">// 正常情况下，预处理完成后：i == transferIndex-1，bound == transferIndex-stride</span>
    <span class="token comment">// 1.给当前线程分配任务区间</span>
    <span class="token comment">// 2.维护当前线程任务进度（i 表示当前处理的桶位）</span>
    <span class="token comment">// 3.维护 map 对象的全局范围内的进度 transferIndex</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>advance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// nextIndex 分配任务的开始下标，nextBound 分配任务的结束下标</span>
        <span class="token keyword">int</span> nextIndex<span class="token punctuation">,</span> nextBound<span class="token punctuation">;</span>
        <span class="token comment">// CASE1: --i &gt;= bound，成立表示当前线的任务任务尚未完成，还有相应的桶位需要处理，--i 就是让当前线程处理下一个桶位</span>
        <span class="token comment">// 不成立则说明当前线程任务已完成，或者未分配</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>i <span class="token operator">&gt;=</span> bound <span class="token operator">||</span> finishing<span class="token punctuation">)</span>
            advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token comment">// CASE2: 说明数组的桶位已经分配完了，则设置当前线程的 i 变量为 -1，执行退出迁移任务相关的逻辑</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nextIndex <span class="token operator">=</span> transferIndex<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// CASE3: 将 transferIndex 由 nextIndex 改为 nextBound，修改成功后修改 bound 和 i 为新值</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">TRANSFERINDEX</span><span class="token punctuation">,</span> nextIndex<span class="token punctuation">,</span>
                nextBound <span class="token operator">=</span> <span class="token punctuation">(</span>nextIndex <span class="token operator">&gt;</span> stride <span class="token operator">?</span> nextIndex <span class="token operator">-</span> stride <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            bound <span class="token operator">=</span> nextBound<span class="token punctuation">;</span>
            i <span class="token operator">=</span> nextIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// CASE1：当前是处理最后一个 tranfer 任务的线程或出现扩容冲突</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">&gt;=</span> n <span class="token operator">||</span> i <span class="token operator">+</span> n <span class="token operator">&gt;=</span> nextn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> sc<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>finishing<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 所有桶迁移均已完成</span>
            nextTable <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            table <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>
            <span class="token comment">// 2n - 0.5n = 1.5n = 0.75 * 2n 也就是下次扩容的阈值</span>
            sizeCtl <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 扩容线程数减1，表示当前线程已完成自己的 transfer 任务</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">,</span> sc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 判断当前线程是否是本轮扩容中的最后一个线程，如果不是，则直接退出</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">RESIZE_STAMP_SHIFT</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token comment">/*
             * 最后一个数据迁移线程要重新检查一次旧table中的所有桶，看是否都被正确迁移到新table了：
             * ①正常情况下，重新检查时，旧table的所有桶都应该是ForwardingNode;
             * ②特殊情况下，比如扩容冲突(多个线程申请到了同一个transfer任务)，此时当前线程领取的任务会作废，那么最后检查时，
             * 还要处理因为作废而没有被迁移的桶，把它们正确迁移到新table中
             */</span>
            finishing <span class="token operator">=</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token comment">// 旧表的长度</span>
            i <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// recheck before commit</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// CASE2：旧桶本身为null，不用迁移，直接尝试放一个ForwardingNode</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        advance <span class="token operator">=</span> <span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// CASE3：该旧桶已经迁移完成，直接跳过</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">MOVED</span><span class="token punctuation">)</span>
        advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// already processed</span>
    <span class="token comment">// CASE4：该旧桶未迁移完成，进行数据迁移，链表迁移、红黑树迁移</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// ln 低位链表引用，hn 高位链表引用</span>
                <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> ln<span class="token punctuation">,</span> hn<span class="token punctuation">;</span>
                <span class="token comment">// CASE4.1：桶的hash&gt;0，说明是链表迁移</span>
                <span class="token comment">/*
                 * 既然是在同一个桶位里，那么就是说明发送哈希碰撞了
                 *
                 * 下面的过程会将旧桶中的链表分成两部分：ln链和hn链
                 * ln链会插入到新table的槽i中，hn链会插入到新table的槽i+n中
                 */</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">/*
                     * n 是 2 的次幂， eg. 1000，fh &amp; n 就结果就两种，n 或者 0
                     * eg.
                     *   .... 1011 0100
                     * &amp; .... 0001 0000   这种出来就是 1000，也就是 n
                     *
                     *   .... 1010 1010
                     * &amp; .... 0001 0000   这种出来就是 0
                     */</span>
                    <span class="token keyword">int</span> runBit <span class="token operator">=</span> fh <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>
                    <span class="token comment">// 获取当前链表末尾连续高位不变的 node</span>
                    <span class="token comment">// lastRun 指向最后一个相邻 runBit 不同的结点</span>
                    <span class="token comment">// 1 - 1 - 1 - 0 -1 -0 - 1-0 -0</span>
                    <span class="token comment">//                       lastrun</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> lastRun <span class="token operator">=</span> f<span class="token punctuation">;</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">int</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> runBit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            runBit <span class="token operator">=</span> b<span class="token punctuation">;</span>
                            lastRun <span class="token operator">=</span> p<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>runBit <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        ln <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>
                        hn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">else</span> <span class="token punctuation">{</span>
                        hn <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>
                        ln <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment">// 以lastRun所指向的结点为分界，将链表拆成2个子链表ln、hn</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> f<span class="token punctuation">;</span> p <span class="token operator">!=</span> lastRun<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">int</span> ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">;</span> <span class="token class-name">K</span> pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span> <span class="token class-name">V</span> pv <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                            ln <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">else</span>
                            hn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment">// ln链表存入新桶的索引i位置</span>
                    <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// hn链表存入新桶的索引i+n位置</span>
                    <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 设置ForwardingNode占位</span>
                    <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 表示当前旧桶的结点已迁移完毕</span>
                    advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 红黑树</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">/*
                     * 下面的过程会先以链表方式遍历，复制所有结点，然后根据高低位组装成两个链表；
                     * 然后看下是否需要进行红黑树转换，最后放到新table对应的桶中
                     *
                     * t     : 用作链表遍历的指针，这里把红黑树当成链表遍历
                     * lo    : 低桶位链表的头指针
                     * loTail: 低桶位链表的尾指针
                     * hi    : 高桶位链表的头指针
                     * hiTail: 高桶位链表的尾指针
                     * lc    : 低桶位节点个数
                     * hc    : 高桶位节点个数
                     */</span>
                    <span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>f<span class="token punctuation">;</span>
                    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> lo <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hi <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token keyword">int</span> lc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> hc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> t<span class="token punctuation">.</span>first<span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">int</span> h <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>
                        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> e<span class="token punctuation">.</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span>val<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token comment">// (h &amp; n) == 0 说明是要放在低位桶的</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> loTail<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                lo <span class="token operator">=</span> p<span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
                            loTail <span class="token operator">=</span> p<span class="token punctuation">;</span>
                            <span class="token operator">++</span>lc<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token comment">// else 分支说明是要放高位桶的</span>
                        <span class="token keyword">else</span> <span class="token punctuation">{</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> hiTail<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                hi <span class="token operator">=</span> p<span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
                            hiTail <span class="token operator">=</span> p<span class="token punctuation">;</span>
                            <span class="token operator">++</span>hc<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment">// 判断是否需要取消树化，退为链表</span>
                    ln <span class="token operator">=</span> <span class="token punctuation">(</span>lc <span class="token operator">&lt;=</span> <span class="token constant">UNTREEIFY_THRESHOLD</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>lo<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>hc <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>lo<span class="token punctuation">)</span> <span class="token operator">:</span> t<span class="token punctuation">;</span>
                    hn <span class="token operator">=</span> <span class="token punctuation">(</span>hc <span class="token operator">&lt;=</span> <span class="token constant">UNTREEIFY_THRESHOLD</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>hi<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>lc <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hi<span class="token punctuation">)</span> <span class="token operator">:</span> t<span class="token punctuation">;</span>
                    <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="迁移数据的流程示例" tabindex="-1"><a class="header-anchor" href="#迁移数据的流程示例" aria-hidden="true">#</a> 迁移数据的流程示例</h3><p>假如当前旧的数组 table 的长度是 64，线程每次负责的桶位个数是 16（即步长）。</p><p>此时第一个扩容的线程进来需要创建一个长度为 128 的 nextTable，然后将 transferIndex 指针赋值为 table 的长度。此时的状态如下。</p><img src="/assets/42-ConcurrentHashMap扩容-初始状态-2824494-f5d8b4de.png" alt="42-ConcurrentHashMap扩容-初始状态" style="zoom:67%;"><p>创建好 nextTable 数组后就开始分配线程负责的迁移桶位区间，假如此次步长是 16，那么分的区间如下：</p><img src="/assets/43-ConcurrentHashMap扩容-划分迁移区间-ef3be68e.png" alt="43-ConcurrentHashMap扩容-划分迁移区间" style="zoom:67%;"><p>这里并不是一次性全部分配完毕，会从高至低每次给线程分配 16 个桶位，当一个线程分配到一个桶位区间时，就回去迁移数据。</p><p>在遍历桶位区间的节点时，可能会遇到三种情况：</p><ol><li>Node 节点：需要迁移节点到新数组中去，然后再旧数组中插入 ForwardingNode；</li><li>TreeBin 节点：需要迁移红黑树的节点到新数组中去，需要考虑迁移后红黑树是否需要退化为链表，然后再旧数组中插入 ForwardingNode；</li><li>null：没有元素了不用迁移，然后再旧数组中插入 ForwardingNode；</li></ol><p><img src="/assets/44-ConcurrentHashMap扩容-迁移节点-74680b1e.png" alt="44-ConcurrentHashMap扩容-迁移节点"></p><p>最后迁移完后，旧数组的所有位置的节点都是 ForwardingNode 对象。</p><p>迁移完后依次将 sizeCtl 的值减 1 表示正在扩容的线程数减 1，假如是最后一个退出扩容的线程，需要将 finishing 和 advance 都置为 true，将 i 置为 n，这样做的目的是重新从 table 数组的高位开始遍历，依次检查是不是所有桶位节点都是 ForwardingNode 节点了，如果不是继续迁移节点。</p><p>如果所有的桶位都是 ForwardingNode 节点了，那么需要将 table 指针指向 nextTable， nextTable 置为 null，并把 sizeCtl 设置为下次扩容的阈值。</p><h2 id="concurrenthashmap-的-get-操作" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-的-get-操作" aria-hidden="true">#</a> ConcurrentHashMap 的 get 操作</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 获取 key 对应的元素</span>
<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">,</span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> eh<span class="token punctuation">;</span> <span class="token class-name">K</span> ek<span class="token punctuation">;</span>
    <span class="token comment">// 再次计算 key 的哈希值</span>
    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 条件成立：说明哈希路由到的 table[i] 位置有元素</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>eh <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment">// hash 和 key 都&quot;相等&quot;，说明找到元素了，直接返回</span>
                <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// eh &lt; 0 说明命中的 table[i] 的元素，不是 Node 节点，非链表结点</span>
        <span class="token comment">// 可能是 TreeBin 节点，也可能是 ForwardingNode 节点，需要调用对应的 find 方法去查找</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>eh <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> p<span class="token punctuation">.</span>val <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// 这里是遍历链表操作，直到找到元素</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法的流程很简单：</p><ol><li>计算哈希值，路由寻址到 table[i] 位置，假如不存在元素则直接返回 null，否则继续查找；</li><li>继续查找有多种情况，最简单的一种情况是遍历链表。假如计算出来的哈希值小于 0，说明当前 table[i] 可能是 TreeBin 节点，也可能是 ForwardingNode 或者 ReservationNode节点，需要调用对应的 find 方法去查找元素。</li></ol><p>当哈希寻址到的 table[i] 节点是 Node 节点时，那就是依次遍历链表找到 key-value 即可。其他情况下面分析。</p><h3 id="treebin-的-get-方法" tabindex="-1"><a class="header-anchor" href="#treebin-的-get-方法" aria-hidden="true">#</a> TreeBin 的 get 方法</h3><p>从根结点开始遍历查找，找到&quot;相等&quot;的结点就返回它，没找到就返回 null。</p><p>由于红黑树的插入、删除会涉及整个结构的调整，所以通常存在读写并发操作的时候，是需要加锁的。当存在写锁时，会以链表方式进行查找。因为 ConcurrentHashMap 的红黑树也维护了链表的指针。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token class-name">Object</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> first<span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> s<span class="token punctuation">;</span> <span class="token class-name">K</span> ek<span class="token punctuation">;</span>
            <span class="token comment">/*
             * 两种特殊情况下以链表的方式进行查找:
             * 1 有线程正持有写锁，这样做能够不阻塞读线程
             * 2 有线程等待获取写锁，不再继续加读锁，类似于写优先
             */</span>
            <span class="token comment">// lockstate &amp; 0011 != 0 成立说明当前 TreeBin 有等待着线程，或者目前有写操作线程正在加锁</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> lockState<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token constant">WAITER</span><span class="token operator">|</span><span class="token constant">WRITER</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> k <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> k<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>
                e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 说明当前 lockState 不是  等待写锁状态和写状态</span>
            <span class="token comment">// 尝试将 lockState 的值加一个读计数，READER，就是尝试获取读锁</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">LOCKSTATE</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> s <span class="token operator">+</span> <span class="token constant">READER</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> r<span class="token punctuation">,</span> p<span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 调用 TreeNode 的红黑树节点的查找方法，查找 key</span>
                    p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> root<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> r<span class="token punctuation">.</span><span class="token function">findTreeNode</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 表示等待者线程</span>
                    <span class="token class-name">Thread</span> w<span class="token punctuation">;</span>
                    <span class="token comment">// READER|WAITER 0110，表示当前只有一个线程在读，且有一个线程在等待</span>
                    <span class="token comment">// 第一步尝试将 lockState 减去一个 READER 值（释放读锁），getAndAddInt 是先获取 previous 值，再加上指定值，</span>
                    <span class="token comment">// 如果当前线程是最后一个读线程，且有写线程因为读锁而阻塞，则写线程，告诉它可以尝试获取写锁了</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">LOCKSTATE</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token constant">READER</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token constant">READER</span><span class="token operator">|</span><span class="token constant">WAITER</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>w <span class="token operator">=</span> waiter<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> p<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要说下 finally 代码块的逻辑：</p><p>假如 lockState 在减 READER 的值之前的值是 (READER|WAITER)，也就是 0110，说明当前只有一个线程在读，且有一个线程在等待。</p><p>在减去 READER 之后就是，哦 0010 了，说明有一个等待线程在等待获取写锁而阻塞，这里需要将其唤醒。</p><p><strong>这里分析下是在哪里加锁的</strong></p><p>前面在分析 put 操作时，TreeBin#putTreeVal 给红黑树添加节点时最下面有这些代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 表示当前新插入节点后，新插入节点与父节点形成&quot;红红相连&quot;</span>
<span class="token function">lockRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 平衡红黑树</span>
    root <span class="token operator">=</span> <span class="token function">balanceInsertion</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token function">unlockRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对红黑树的根节点加写锁</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lockRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 条件成立，说明 lockstate 并不是 0，说明有其他读线程在 treebin 的红黑树中读数据</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">LOCKSTATE</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">WRITER</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">contendedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// offload to separate method</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>尝试将 TreeBin 的 lockstate 从 0 改到 WRITER 状态加写锁。假如加锁失败了，说明已经有写锁了，需要在 contendedLock 方法中竞争锁。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * Possibly blocks awaiting root lock.
 */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">contendedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> waiting <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> lockState<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token constant">WAITER</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 说明没有treebin 中没有读线程在访问红黑树</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">LOCKSTATE</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token constant">WRITER</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>waiting<span class="token punctuation">)</span>
                    waiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 前置条件是有线程在读红黑树</span>
        <span class="token comment">// 说明 waiter 标志位位 0，可以将当前线程设置到 waiter 中了</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">&amp;</span> <span class="token constant">WAITER</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">LOCKSTATE</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> s <span class="token operator">|</span> <span class="token constant">WAITER</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                waiting <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                waiter <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>waiting<span class="token punctuation">)</span>
            <span class="token comment">// 挂起</span>
            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>contendedLock 方法里面有个自旋操作，直到获取到了写锁才会退出，所以里面可能会阻塞线程。</p><h3 id="forwardingnode-的-get-方法" tabindex="-1"><a class="header-anchor" href="#forwardingnode-的-get-方法" aria-hidden="true">#</a> ForwardingNode 的 get 方法</h3><p>前面说了 ForwardingNode 是一个临时节点，会在 ConcurrentHashMap 扩容的过程中出现。当哈希寻址得到的 table[i] 桶位的节点是 ForwardingNode 节点，说明当前桶位的节点已经迁移到新的数组 nextTable 里了，这里需要去 nextTable 数组中去查找元素了。</p><p>ForwardingNode 节点的 find 方法做的就是去新数组里查找元素。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token class-name">Object</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// loop to avoid arbitrarily deep recursion on forwarding nodes</span>
    <span class="token comment">// 循环以避免转发节点上的任意深度递归</span>
    outer<span class="token operator">:</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> nextTable<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span>
                <span class="token operator">||</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token comment">// 哈希寻址到的桶位没有元素，直接返回 null</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> eh<span class="token punctuation">;</span> <span class="token class-name">K</span> ek<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>eh <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> k <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> k<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment">// 找到元素了</span>
                <span class="token keyword">return</span> e<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>eh <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 又遇到了 ForwardingNode 节点</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">ForwardingNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    tab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ForwardingNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span>nextTable<span class="token punctuation">;</span>
                    <span class="token keyword">continue</span> outer<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// else 是 TreeBin 节点</span>
                <span class="token keyword">else</span>
                    <span class="token keyword">return</span> e<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 链表指针后移</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="concurrenthashmap-的-remove-方法" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-的-remove-方法" aria-hidden="true">#</a> ConcurrentHashMap 的 remove 方法</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">replaceNode</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">replaceNode</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Object</span> cv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/*
             * f : 哈希寻址到的桶位的元素
             * n : 数组的长度
             * i : 桶位索引
             * fh: 桶位元素的哈希值
             */</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fh<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span>
            <span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">MOVED</span><span class="token punctuation">)</span>
            <span class="token comment">// 帮助扩容</span>
            tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token class-name">V</span> oldVal <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">boolean</span> validated <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 二次检查</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 链表节点</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        validated <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                        <span class="token comment">// f 是指向 ， pred 是 f 的前驱</span>
                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> f<span class="token punctuation">,</span> pred <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token class-name">K</span> ek<span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash
                                <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                <span class="token comment">// 进入这个条件说明找到了要删除的元素</span>
                                <span class="token class-name">V</span> ev <span class="token operator">=</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>cv <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> cv <span class="token operator">==</span> ev <span class="token operator">||</span>
                                    <span class="token punctuation">(</span>ev <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> cv<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                    <span class="token comment">// 删除或者替换</span>
                                    oldVal <span class="token operator">=</span> ev<span class="token punctuation">;</span>
                                    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                        <span class="token comment">// 说明是替换操作</span>
                                        e<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
                                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                        <span class="token comment">// 说明是在链表中间，需要通过前驱 pred 来删除元素</span>
                                        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                                    <span class="token keyword">else</span>
                                        <span class="token comment">// 说明是链表的头节点，也就是桶位，直接 cas 设置</span>
                                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token punctuation">}</span>
                                <span class="token keyword">break</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                            pred <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token comment">// 指针后移</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment">// 红黑树节点</span>
                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        validated <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                        <span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>f<span class="token punctuation">;</span>
                        <span class="token comment">/*
                             * r: 红黑树的根节点
                             * p: 红黑树中查找到对应的 key，哈希一致的 node
                             */</span>
                        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> r<span class="token punctuation">,</span> p<span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> t<span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
                            <span class="token punctuation">(</span>p <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">findTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token class-name">V</span> pv <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                            <span class="token comment">// cv == null 成立则说明不需要比对 value，就做替换或者删除操作</span>
                            <span class="token comment">// cv == pv || (pv != null &amp;&amp; cv.equals(pv) 成立则说明&quot;对比值&quot;与当前 p 节点的值一致</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>cv <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> cv <span class="token operator">==</span> pv <span class="token operator">||</span> <span class="token punctuation">(</span>pv <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> cv<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>pv<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                oldVal <span class="token operator">=</span> pv<span class="token punctuation">;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                    p<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
                                <span class="token comment">// 删除 p 节点</span>
                                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">removeTreeNode</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>
                                    <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>validated<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                        <span class="token comment">// 减少计数</span>
                        <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1L</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>删除操作主要也分为三种情况：</p><ol><li>哈希路由寻址到的 table[i] 位置的元素是 null，直接退出自旋并返回 null；</li><li>哈希路由寻址到的 table[i] 位置的元素 ForwardingNode，需要调用 helpTransfer 方法协助扩容；</li><li>删除元素， <ol><li>将 table[i] 元素当做锁对象同步代码块，根据是否是链表和红黑树做不同的删除操作；</li><li>红黑树的删除操作需要校验是否需要将红黑树退化成链表；</li><li>最后减少计数；</li></ol></li></ol><h2 id="concurrenthashmap-小结" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-小结" aria-hidden="true">#</a> ConcurrentHashMap 小结</h2><p>ConcurrentHashMap 通过 <strong>CAS + Synchronized</strong> 方式实现并发安全，通过<strong>多线程进行扩容</strong>。</p><p><strong>当写元素未发送哈希冲突时，使用 CAS 进行无锁化写入，当发生哈希冲突时，使用 Synchronized 给桶位锁定进行吸写入操作，这样降低了锁的粒度</strong>。</p><p>因为 ConcurrentHashMap 的 get 和 size 方法并未使用锁进行同步，特别是 size 方法，返回的只是一个期望值，并不是实际值，所以 ConcurrentHashMap 是<strong>弱一致性</strong>的。</p><p>ConcurrentHashMap 底层是通过数组 + 红黑树 + 链表**构成的，主要还是数组存数据多些，所以 ConcurrentHashMap 不适合存储大量数据。</p><p>最后 ConcurrentHashMap 适合不存储大量数据，读操作比写操作多的场景。</p></div><!----><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: guosgbin@163.com">Dylan Kwok</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a href="/JDK_source/25-ConcurrentSkipListSet%E8%B7%B3%E8%A1%A8.html" class="nav-link prev" aria-label="25-ConcurrentSkipListSet跳表"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->25-ConcurrentSkipListSet跳表</div></a><a href="/JDK_source/27-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97ArrayBlockingQueue.html" class="nav-link next" aria-label="27-阻塞队列ArrayBlockingQueue"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">27-阻塞队列ArrayBlockingQueue<!----></div></a></nav><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-ecfdc732.js" defer></script>
  </body>
</html>
