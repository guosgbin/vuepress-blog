<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.62" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://blog.guosgbin.cn/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html"><meta property="og:title" content="16-客户端处理READ事件详解及RecvByteBufAllocator"><meta property="og:description" content="版本 内容 时间 ---- ---- ---------------------- V1 新建 2022年2月18日18:34:24 V2 重构 2023年05月27日14:28:26 分析顺序 想要理明白客户端处理 READ 事件的读循环，必须了解 AdaptiveRecvByteBufAllocator 和 MaxMessageHandle 这两个..."><meta property="og:type" content="article"><meta property="og:image" content="https://blog.guosgbin.cn/"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-06-04T09:46:30.000Z"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="16-客户端处理READ事件详解及RecvByteBufAllocator"><meta property="article:author" content="超威蓝猫 Dylan Kwok"><meta property="article:tag" content="Netty"><meta property="article:published_time" content="2022-02-23T18:34:24.000Z"><meta property="article:modified_time" content="2023-06-04T09:46:30.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"16-客户端处理READ事件详解及RecvByteBufAllocator","image":["https://blog.guosgbin.cn/"],"datePublished":"2022-02-23T18:34:24.000Z","dateModified":"2023-06-04T09:46:30.000Z","author":[{"@type":"Person","name":"超威蓝猫 Dylan Kwok","url":"","email":"guosgbin@163.com"}]}</script><link rel="icon" href="/小熊猫.svg"><title>16-客户端处理READ事件详解及RecvByteBufAllocator</title><meta name="description" content="版本 内容 时间 ---- ---- ---------------------- V1 新建 2022年2月18日18:34:24 V2 重构 2023年05月27日14:28:26 分析顺序 想要理明白客户端处理 READ 事件的读循环，必须了解 AdaptiveRecvByteBufAllocator 和 MaxMessageHandle 这两个...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-542658da.css" as="style"><link rel="stylesheet" href="/assets/style-542658da.css">
    <link rel="modulepreload" href="/assets/app-c12a9a30.js"><link rel="modulepreload" href="/assets/16-客户端处理READ事件详解及RecvByteBufAllocator.html-a9faccfa.js"><link rel="modulepreload" href="/assets/16-客户端处理READ事件详解及RecvByteBufAllocator.html-81b10f4c.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-c27b6911.js"><link rel="prefetch" href="/assets/index.html-d9edbc0d.js" as="script"><link rel="prefetch" href="/assets/01-创建和销毁对象.html-98280ce1.js" as="script"><link rel="prefetch" href="/assets/index.html-c4f42206.js" as="script"><link rel="prefetch" href="/assets/01-CAS和Unsafe的API分析.html-612c4d6a.js" as="script"><link rel="prefetch" href="/assets/02-基本类型原子类AtomicLong.html-4083b8fd.js" as="script"><link rel="prefetch" href="/assets/03-引用类型原子类AtomicReference.html-8442553d.js" as="script"><link rel="prefetch" href="/assets/04-原子数组类AtomicLongArray.html-74e4c741.js" as="script"><link rel="prefetch" href="/assets/05-原子操作类AtomicReferenceFieldUpdater.html-d0310b2a.js" as="script"><link rel="prefetch" href="/assets/06-高性能原子类LongAdder.html-d6e3da8b.js" as="script"><link rel="prefetch" href="/assets/07-LockSupport分析.html-8117dd17.js" as="script"><link rel="prefetch" href="/assets/08-AQS简单介绍.html-30b6ef5b.js" as="script"><link rel="prefetch" href="/assets/09-基于ReentrantLock分析AQS的独占模式.html-2423c430.js" as="script"><link rel="prefetch" href="/assets/10-基于CountDownLatch分析AQS的共享模式.html-91ef4833.js" as="script"><link rel="prefetch" href="/assets/11-AQS的Condition机制.html-836364af.js" as="script"><link rel="prefetch" href="/assets/12-信号量Semaphore.html-3509682c.js" as="script"><link rel="prefetch" href="/assets/13-循环栏栅CyclicBarrier.html-812d137d.js" as="script"><link rel="prefetch" href="/assets/14-阶段Phaser.html-d684f4a1.js" as="script"><link rel="prefetch" href="/assets/15-交换Exchanger.html-b9bf24f3.js" as="script"><link rel="prefetch" href="/assets/16-读写锁ReentrantReadWriteLock.html-de44a1d3.js" as="script"><link rel="prefetch" href="/assets/17-Future模式-FutureTask.html-641c6250.js" as="script"><link rel="prefetch" href="/assets/18-线程池体系概述.html-dbcc52e5.js" as="script"><link rel="prefetch" href="/assets/19-线程池体系-AbstractExecutorService.html-fbd70afb.js" as="script"><link rel="prefetch" href="/assets/20-线程池体系-ThreadPoolExecutor.html-a274637a.js" as="script"><link rel="prefetch" href="/assets/21-线程池体系-ScheduledThreadPoolExecutor.html-707ffd40.js" as="script"><link rel="prefetch" href="/assets/22-CopyOnWriteArrayList写时复制.html-914977b9.js" as="script"><link rel="prefetch" href="/assets/23-CopyOnWriteArraySet写时复制.html-6c9c3cf6.js" as="script"><link rel="prefetch" href="/assets/24-ConcurrentSkipListMap跳表.html-6cff54bf.js" as="script"><link rel="prefetch" href="/assets/25-ConcurrentSkipListSet跳表.html-36cf4f7d.js" as="script"><link rel="prefetch" href="/assets/26-ConcurrentHashMap源码分析.html-a3bba8a9.js" as="script"><link rel="prefetch" href="/assets/27-阻塞队列ArrayBlockingQueue.html-cd091357.js" as="script"><link rel="prefetch" href="/assets/28-阻塞队列LinkedBlockingQueue.html-d3579ee7.js" as="script"><link rel="prefetch" href="/assets/29-阻塞队列LinkedBlockingDeque.html-32c13680.js" as="script"><link rel="prefetch" href="/assets/30-阻塞队列PriorityBlockingQueue.html-b5455c77.js" as="script"><link rel="prefetch" href="/assets/31-阻塞队列DelayQueue.html-7759c195.js" as="script"><link rel="prefetch" href="/assets/32-阻塞队列SynchronousQueue.html-97ed879a.js" as="script"><link rel="prefetch" href="/assets/33-阻塞队列LinkedTransferQueue.html-3281c1b4.js" as="script"><link rel="prefetch" href="/assets/index.html-f5239cf3.js" as="script"><link rel="prefetch" href="/assets/SPI机制.html-a1ca3921.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis01：myabtis的整体架构.html-f25c0705.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis02：入门案例.html-30e68cd3.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis03：解析全局配置文件.html-2db85266.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis04：解析Mapper映射文件.html-60756a5b.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis05：解析Statement操作节点.html-31e11b60.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis06：解析SQL语句.html-a9181b56.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis07：Java方法和SQL语句绑定.html-9bfa3db6.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis08：获得SqlSession.html-e2a92940.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis09：Executor执行器.html-ad701715.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis10：缓存机制.html-f2daa10c.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis11：StatementHandler.html-95b30d9b.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis12：参数解析和赋值.html-5778c0ea.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis13：结果集处理.html-2ff72779.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis14：插件.html-76cc6bf8.js" as="script"><link rel="prefetch" href="/assets/01-服务端启动流程.html-d2fc1f19.js" as="script"><link rel="prefetch" href="/assets/02-服务端启动添加ChannelInitializer到管道.html-86cb5d6a.js" as="script"><link rel="prefetch" href="/assets/03-客户端启动流程.html-becc83be.js" as="script"><link rel="prefetch" href="/assets/04-线程体系-NioEventLoopGroup.html-700e797e.js" as="script"><link rel="prefetch" href="/assets/05-线程体系-NioEventLoop相关父接口分析.html-754320bc.js" as="script"><link rel="prefetch" href="/assets/06-线程体系-AbstractEventExecutor.html-5250cd42.js" as="script"><link rel="prefetch" href="/assets/07-线程体系-AbstractScheduledEventExecutor-优先队列.html-e7bbaf32.js" as="script"><link rel="prefetch" href="/assets/08-线程体系-NioEventLoop概述.html-fce3fb2c.js" as="script"><link rel="prefetch" href="/assets/09-线程体系-NioEventLoop开启Selector及优化.html-6d8230cf.js" as="script"><link rel="prefetch" href="/assets/10-线程体系-NioEventLoop绑定线程.html-db947821.js" as="script"><link rel="prefetch" href="/assets/11-线程体系-NioEventLoop的run方法.html-def4cc31.js" as="script"><link rel="prefetch" href="/assets/12-线程体系-NioEventLoop规避JDK的NIO空循环bug.html-16ecaf4e.js" as="script"><link rel="prefetch" href="/assets/13-线程体系-NioEventLoop的优雅关闭.html-912d668d.js" as="script"><link rel="prefetch" href="/assets/14-服务端处理客户端的连接(ACCEPT).html-63afdec1.js" as="script"><link rel="prefetch" href="/assets/15-客户端处理READ事件概述.html-b35daeb8.js" as="script"><link rel="prefetch" href="/assets/17-Netty管道机制.html-ba70b238.js" as="script"><link rel="prefetch" href="/assets/18-Netty发送数据流程及出站缓冲区.html-223d04a7.js" as="script"><link rel="prefetch" href="/assets/index.html-b475d8b0.js" as="script"><link rel="prefetch" href="/assets/Redis_Benchmark基准测试.html-dbf21951.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群和槽管理命令.html-2b4a1244.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群基本特性和集群搭建.html-42be726b.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群管理工具redis-cli.html-fc4f1503.js" as="script"><link rel="prefetch" href="/assets/Redis_Pipeline优化RTT.html-8a4aa041.js" as="script"><link rel="prefetch" href="/assets/Redis_Sentinel高可用.html-6bcdb34a.js" as="script"><link rel="prefetch" href="/assets/Redis_key设计规范.html-ab90a7dc.js" as="script"><link rel="prefetch" href="/assets/Redis事务.html-e43061e1.js" as="script"><link rel="prefetch" href="/assets/Redis内存淘汰策略.html-feabd314.js" as="script"><link rel="prefetch" href="/assets/Redis发布订阅.html-68771977.js" as="script"><link rel="prefetch" href="/assets/Redis复制.html-33b20d6f.js" as="script"><link rel="prefetch" href="/assets/Redis大key和热key问题.html-394d194e.js" as="script"><link rel="prefetch" href="/assets/Redis慢查询日志.html-7fb06db0.js" as="script"><link rel="prefetch" href="/assets/Redis持久化机制.html-53af3f7a.js" as="script"><link rel="prefetch" href="/assets/Redis键空间通知(keyspace notification).html-012bd277.js" as="script"><link rel="prefetch" href="/assets/redis-cli 使用.html-f7ab22db.js" as="script"><link rel="prefetch" href="/assets/01-RocketMQ概述.html-25463efe.js" as="script"><link rel="prefetch" href="/assets/02-NameServer启动流程.html-a514999f.js" as="script"><link rel="prefetch" href="/assets/03-Broker启动流程.html-43c84806.js" as="script"><link rel="prefetch" href="/assets/04-RocketMQ网络通信原理.html-ac88de8d.js" as="script"><link rel="prefetch" href="/assets/05-RocketMQ 服务端和客户端的启动.html-ef7f1888.js" as="script"><link rel="prefetch" href="/assets/06-RocketMQ网络通信源码.html-b8e0bf43.js" as="script"><link rel="prefetch" href="/assets/07-NameServer作用和路由元信息.html-82a23869.js" as="script"><link rel="prefetch" href="/assets/08-NameServer路由管理源码分析.html-8da2bd72.js" as="script"><link rel="prefetch" href="/assets/09-生产者相关类分析.html-08f6e840.js" as="script"><link rel="prefetch" href="/assets/10-生产者启动流程.html-d761cf07.js" as="script"><link rel="prefetch" href="/assets/11-生产者发送消息.html-743328bc.js" as="script"><link rel="prefetch" href="/assets/12-Broker存储机制概述.html-5e7ed491.js" as="script"><link rel="prefetch" href="/assets/13-MappedFile和MappedFileQueue分析.html-5b9afaf2.js" as="script"><link rel="prefetch" href="/assets/14-CommitLog原理分析.html-93362aa2.js" as="script"><link rel="prefetch" href="/assets/15-broker的刷盘机制.html-21e2029f.js" as="script"><link rel="prefetch" href="/assets/16-ConsumeQueue和Index原理分析.html-ff18bade.js" as="script"><link rel="prefetch" href="/assets/17-broker过期文件删除机制.html-89f05919.js" as="script"><link rel="prefetch" href="/assets/18-消费者启动流程(TODO).html-988c43b3.js" as="script"><link rel="prefetch" href="/assets/19-消息拉取入口和消息队列负载均衡.html-7e4e20d4.js" as="script"><link rel="prefetch" href="/assets/20-消费者发送消息拉取请求流程.html-19825069.js" as="script"><link rel="prefetch" href="/assets/21-broker处理消息拉取请求-1-主流程.html-d9ca6fa4.js" as="script"><link rel="prefetch" href="/assets/22-broker处理消息拉取请求-2-长轮询.html-0aba4f38.js" as="script"><link rel="prefetch" href="/assets/23-broker处理消息拉取请求-3-读取消息.html-729d741b.js" as="script"><link rel="prefetch" href="/assets/24-消费者处理从broker拉取的消息.html-dcfb7d07.js" as="script"><link rel="prefetch" href="/assets/25-并发消费原理.html-5ef206ec.js" as="script"><link rel="prefetch" href="/assets/001-服务器CPU问题-规律性峰刺.html-81aeb2c9.js" as="script"><link rel="prefetch" href="/assets/002-服务器CPU配置降低GC分析.html-d27479f5.js" as="script"><link rel="prefetch" href="/assets/003-服务器CPU使用率较低但系统负载高.html-13cce7d9.js" as="script"><link rel="prefetch" href="/assets/004-log4j2内存泄露导致的频繁fullgc.html-a403b9d0.js" as="script"><link rel="prefetch" href="/assets/005-线程池父子任务使用不当造成死锁.html-362015fc.js" as="script"><link rel="prefetch" href="/assets/006-linux系统参数-连接队列长度过小导致连接丢弃.html-7c9d02a0.js" as="script"><link rel="prefetch" href="/assets/007-redis频繁淘汰-清除redis线上未设置过期时间的key.html-e760378c.js" as="script"><link rel="prefetch" href="/assets/项目-IM长连接优化.html-00c51a2b.js" as="script"><link rel="prefetch" href="/assets/项目-服务降级.html-6240bf01.js" as="script"><link rel="prefetch" href="/assets/项目-线程池优化.html-c4acfb51.js" as="script"><link rel="prefetch" href="/assets/JUC相关问题.html-9dc4b717.js" as="script"><link rel="prefetch" href="/assets/JVM问题.html-17300c49.js" as="script"><link rel="prefetch" href="/assets/MySQL相关问题.html-a6c2cd41.js" as="script"><link rel="prefetch" href="/assets/index.html-8f5e683a.js" as="script"><link rel="prefetch" href="/assets/Redis相关问题.html-575f1ee1.js" as="script"><link rel="prefetch" href="/assets/二分查找.html-6b017c38.js" as="script"><link rel="prefetch" href="/assets/二叉树.html-e277f749.js" as="script"><link rel="prefetch" href="/assets/代码随想录题目目录.html-308825f0.js" as="script"><link rel="prefetch" href="/assets/HowToSayResume.html-ede1dad2.js" as="script"><link rel="prefetch" href="/assets/index.html-af6a830f.js" as="script"><link rel="prefetch" href="/assets/resume.html-3b3f8934.js" as="script"><link rel="prefetch" href="/assets/404.html-f3795607.js" as="script"><link rel="prefetch" href="/assets/index.html-1f3390c0.js" as="script"><link rel="prefetch" href="/assets/index.html-10b45510.js" as="script"><link rel="prefetch" href="/assets/index.html-dfd17ea5.js" as="script"><link rel="prefetch" href="/assets/index.html-2f392b9e.js" as="script"><link rel="prefetch" href="/assets/index.html-4060f68d.js" as="script"><link rel="prefetch" href="/assets/index.html-d5cde66b.js" as="script"><link rel="prefetch" href="/assets/index.html-07841198.js" as="script"><link rel="prefetch" href="/assets/01-创建和销毁对象.html-2843d3cc.js" as="script"><link rel="prefetch" href="/assets/index.html-47735cd7.js" as="script"><link rel="prefetch" href="/assets/01-CAS和Unsafe的API分析.html-fdc5d65b.js" as="script"><link rel="prefetch" href="/assets/02-基本类型原子类AtomicLong.html-2c1f83dc.js" as="script"><link rel="prefetch" href="/assets/03-引用类型原子类AtomicReference.html-fb7209a4.js" as="script"><link rel="prefetch" href="/assets/04-原子数组类AtomicLongArray.html-73197976.js" as="script"><link rel="prefetch" href="/assets/05-原子操作类AtomicReferenceFieldUpdater.html-32f09026.js" as="script"><link rel="prefetch" href="/assets/06-高性能原子类LongAdder.html-4d244b66.js" as="script"><link rel="prefetch" href="/assets/07-LockSupport分析.html-97470688.js" as="script"><link rel="prefetch" href="/assets/08-AQS简单介绍.html-7d39696c.js" as="script"><link rel="prefetch" href="/assets/09-基于ReentrantLock分析AQS的独占模式.html-172f7455.js" as="script"><link rel="prefetch" href="/assets/10-基于CountDownLatch分析AQS的共享模式.html-cb61ae52.js" as="script"><link rel="prefetch" href="/assets/11-AQS的Condition机制.html-242e4e06.js" as="script"><link rel="prefetch" href="/assets/12-信号量Semaphore.html-4d14cae6.js" as="script"><link rel="prefetch" href="/assets/13-循环栏栅CyclicBarrier.html-26d9b109.js" as="script"><link rel="prefetch" href="/assets/14-阶段Phaser.html-c0a53fcd.js" as="script"><link rel="prefetch" href="/assets/15-交换Exchanger.html-cb561743.js" as="script"><link rel="prefetch" href="/assets/16-读写锁ReentrantReadWriteLock.html-3e47ddc1.js" as="script"><link rel="prefetch" href="/assets/17-Future模式-FutureTask.html-f2c5b7b9.js" as="script"><link rel="prefetch" href="/assets/18-线程池体系概述.html-29970491.js" as="script"><link rel="prefetch" href="/assets/19-线程池体系-AbstractExecutorService.html-beb6f27f.js" as="script"><link rel="prefetch" href="/assets/20-线程池体系-ThreadPoolExecutor.html-04c3ad8d.js" as="script"><link rel="prefetch" href="/assets/21-线程池体系-ScheduledThreadPoolExecutor.html-fb9c7509.js" as="script"><link rel="prefetch" href="/assets/22-CopyOnWriteArrayList写时复制.html-02de8694.js" as="script"><link rel="prefetch" href="/assets/23-CopyOnWriteArraySet写时复制.html-20808b31.js" as="script"><link rel="prefetch" href="/assets/24-ConcurrentSkipListMap跳表.html-442a1bf7.js" as="script"><link rel="prefetch" href="/assets/25-ConcurrentSkipListSet跳表.html-d82dc8ee.js" as="script"><link rel="prefetch" href="/assets/26-ConcurrentHashMap源码分析.html-1019569c.js" as="script"><link rel="prefetch" href="/assets/27-阻塞队列ArrayBlockingQueue.html-874c2417.js" as="script"><link rel="prefetch" href="/assets/28-阻塞队列LinkedBlockingQueue.html-b9f2d2ef.js" as="script"><link rel="prefetch" href="/assets/29-阻塞队列LinkedBlockingDeque.html-8cdbf598.js" as="script"><link rel="prefetch" href="/assets/30-阻塞队列PriorityBlockingQueue.html-f0b0c82f.js" as="script"><link rel="prefetch" href="/assets/31-阻塞队列DelayQueue.html-9aa2eb49.js" as="script"><link rel="prefetch" href="/assets/32-阻塞队列SynchronousQueue.html-be706cfa.js" as="script"><link rel="prefetch" href="/assets/33-阻塞队列LinkedTransferQueue.html-ef00abca.js" as="script"><link rel="prefetch" href="/assets/index.html-dacda6e0.js" as="script"><link rel="prefetch" href="/assets/SPI机制.html-710b51e1.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis01：myabtis的整体架构.html-ca63e73a.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis02：入门案例.html-103abbe3.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis03：解析全局配置文件.html-f7901d1f.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis04：解析Mapper映射文件.html-a2edf117.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis05：解析Statement操作节点.html-e46bb2ad.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis06：解析SQL语句.html-706815d9.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis07：Java方法和SQL语句绑定.html-61575d83.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis08：获得SqlSession.html-31b54ad8.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis09：Executor执行器.html-7f6ba208.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis10：缓存机制.html-02f5cb94.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis11：StatementHandler.html-acc0a9bb.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis12：参数解析和赋值.html-4b6401e4.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis13：结果集处理.html-a3e3c2f9.js" as="script"><link rel="prefetch" href="/assets/深入浅出Mybatis14：插件.html-04c1516d.js" as="script"><link rel="prefetch" href="/assets/01-服务端启动流程.html-98711027.js" as="script"><link rel="prefetch" href="/assets/02-服务端启动添加ChannelInitializer到管道.html-44c93306.js" as="script"><link rel="prefetch" href="/assets/03-客户端启动流程.html-4a3acffd.js" as="script"><link rel="prefetch" href="/assets/04-线程体系-NioEventLoopGroup.html-34921b8c.js" as="script"><link rel="prefetch" href="/assets/05-线程体系-NioEventLoop相关父接口分析.html-7c395163.js" as="script"><link rel="prefetch" href="/assets/06-线程体系-AbstractEventExecutor.html-a5455eca.js" as="script"><link rel="prefetch" href="/assets/07-线程体系-AbstractScheduledEventExecutor-优先队列.html-88b29676.js" as="script"><link rel="prefetch" href="/assets/08-线程体系-NioEventLoop概述.html-551a5f54.js" as="script"><link rel="prefetch" href="/assets/09-线程体系-NioEventLoop开启Selector及优化.html-c09b5b48.js" as="script"><link rel="prefetch" href="/assets/10-线程体系-NioEventLoop绑定线程.html-4ab1c8e8.js" as="script"><link rel="prefetch" href="/assets/11-线程体系-NioEventLoop的run方法.html-0ed7148d.js" as="script"><link rel="prefetch" href="/assets/12-线程体系-NioEventLoop规避JDK的NIO空循环bug.html-cd564b62.js" as="script"><link rel="prefetch" href="/assets/13-线程体系-NioEventLoop的优雅关闭.html-f16a5a5d.js" as="script"><link rel="prefetch" href="/assets/14-服务端处理客户端的连接(ACCEPT).html-8a967541.js" as="script"><link rel="prefetch" href="/assets/15-客户端处理READ事件概述.html-a8ab9fbb.js" as="script"><link rel="prefetch" href="/assets/17-Netty管道机制.html-dc267e89.js" as="script"><link rel="prefetch" href="/assets/18-Netty发送数据流程及出站缓冲区.html-4a0b5d21.js" as="script"><link rel="prefetch" href="/assets/index.html-0af2c592.js" as="script"><link rel="prefetch" href="/assets/Redis_Benchmark基准测试.html-221768b6.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群和槽管理命令.html-cac4a067.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群基本特性和集群搭建.html-7cb68901.js" as="script"><link rel="prefetch" href="/assets/Redis_Cluster集群管理工具redis-cli.html-a48d943e.js" as="script"><link rel="prefetch" href="/assets/Redis_Pipeline优化RTT.html-3583d827.js" as="script"><link rel="prefetch" href="/assets/Redis_Sentinel高可用.html-aae0faf7.js" as="script"><link rel="prefetch" href="/assets/Redis_key设计规范.html-eb3949c8.js" as="script"><link rel="prefetch" href="/assets/Redis事务.html-903c07bb.js" as="script"><link rel="prefetch" href="/assets/Redis内存淘汰策略.html-f164df58.js" as="script"><link rel="prefetch" href="/assets/Redis发布订阅.html-4b737528.js" as="script"><link rel="prefetch" href="/assets/Redis复制.html-80be1c71.js" as="script"><link rel="prefetch" href="/assets/Redis大key和热key问题.html-b2828758.js" as="script"><link rel="prefetch" href="/assets/Redis慢查询日志.html-153f908a.js" as="script"><link rel="prefetch" href="/assets/Redis持久化机制.html-23aa3bf5.js" as="script"><link rel="prefetch" href="/assets/Redis键空间通知(keyspace notification).html-4c7559b1.js" as="script"><link rel="prefetch" href="/assets/redis-cli 使用.html-e7ff06a6.js" as="script"><link rel="prefetch" href="/assets/01-RocketMQ概述.html-f8b9da2a.js" as="script"><link rel="prefetch" href="/assets/02-NameServer启动流程.html-e7beaab3.js" as="script"><link rel="prefetch" href="/assets/03-Broker启动流程.html-b0c4bc5f.js" as="script"><link rel="prefetch" href="/assets/04-RocketMQ网络通信原理.html-8a90072d.js" as="script"><link rel="prefetch" href="/assets/05-RocketMQ 服务端和客户端的启动.html-00340df2.js" as="script"><link rel="prefetch" href="/assets/06-RocketMQ网络通信源码.html-21ec16dc.js" as="script"><link rel="prefetch" href="/assets/07-NameServer作用和路由元信息.html-666901dc.js" as="script"><link rel="prefetch" href="/assets/08-NameServer路由管理源码分析.html-9be1e54c.js" as="script"><link rel="prefetch" href="/assets/09-生产者相关类分析.html-2fb4c0ea.js" as="script"><link rel="prefetch" href="/assets/10-生产者启动流程.html-4d8b0fb5.js" as="script"><link rel="prefetch" href="/assets/11-生产者发送消息.html-13db25c3.js" as="script"><link rel="prefetch" href="/assets/12-Broker存储机制概述.html-c2f2abc2.js" as="script"><link rel="prefetch" href="/assets/13-MappedFile和MappedFileQueue分析.html-614d7bd6.js" as="script"><link rel="prefetch" href="/assets/14-CommitLog原理分析.html-1c39d17f.js" as="script"><link rel="prefetch" href="/assets/15-broker的刷盘机制.html-7e6a2f38.js" as="script"><link rel="prefetch" href="/assets/16-ConsumeQueue和Index原理分析.html-5fd5f462.js" as="script"><link rel="prefetch" href="/assets/17-broker过期文件删除机制.html-f6162b01.js" as="script"><link rel="prefetch" href="/assets/18-消费者启动流程(TODO).html-a124c511.js" as="script"><link rel="prefetch" href="/assets/19-消息拉取入口和消息队列负载均衡.html-70402d89.js" as="script"><link rel="prefetch" href="/assets/20-消费者发送消息拉取请求流程.html-e3c27d5b.js" as="script"><link rel="prefetch" href="/assets/21-broker处理消息拉取请求-1-主流程.html-c4454ece.js" as="script"><link rel="prefetch" href="/assets/22-broker处理消息拉取请求-2-长轮询.html-adbf0571.js" as="script"><link rel="prefetch" href="/assets/23-broker处理消息拉取请求-3-读取消息.html-e49a44e5.js" as="script"><link rel="prefetch" href="/assets/24-消费者处理从broker拉取的消息.html-9bbb2e00.js" as="script"><link rel="prefetch" href="/assets/25-并发消费原理.html-ef774456.js" as="script"><link rel="prefetch" href="/assets/001-服务器CPU问题-规律性峰刺.html-956a5c59.js" as="script"><link rel="prefetch" href="/assets/002-服务器CPU配置降低GC分析.html-53df7a39.js" as="script"><link rel="prefetch" href="/assets/003-服务器CPU使用率较低但系统负载高.html-cdac8407.js" as="script"><link rel="prefetch" href="/assets/004-log4j2内存泄露导致的频繁fullgc.html-56c92088.js" as="script"><link rel="prefetch" href="/assets/005-线程池父子任务使用不当造成死锁.html-1bd9c396.js" as="script"><link rel="prefetch" href="/assets/006-linux系统参数-连接队列长度过小导致连接丢弃.html-b589bc16.js" as="script"><link rel="prefetch" href="/assets/007-redis频繁淘汰-清除redis线上未设置过期时间的key.html-401108f2.js" as="script"><link rel="prefetch" href="/assets/项目-IM长连接优化.html-5bcb64d5.js" as="script"><link rel="prefetch" href="/assets/项目-服务降级.html-2c21e5e0.js" as="script"><link rel="prefetch" href="/assets/项目-线程池优化.html-df95fc15.js" as="script"><link rel="prefetch" href="/assets/JUC相关问题.html-1f5ec703.js" as="script"><link rel="prefetch" href="/assets/JVM问题.html-e8f1e21b.js" as="script"><link rel="prefetch" href="/assets/MySQL相关问题.html-074d7fbb.js" as="script"><link rel="prefetch" href="/assets/index.html-8f1f6cb9.js" as="script"><link rel="prefetch" href="/assets/Redis相关问题.html-7b9fc700.js" as="script"><link rel="prefetch" href="/assets/二分查找.html-314da328.js" as="script"><link rel="prefetch" href="/assets/二叉树.html-bc94003c.js" as="script"><link rel="prefetch" href="/assets/代码随想录题目目录.html-792e1114.js" as="script"><link rel="prefetch" href="/assets/HowToSayResume.html-4b99164a.js" as="script"><link rel="prefetch" href="/assets/index.html-15f7f162.js" as="script"><link rel="prefetch" href="/assets/resume.html-257f3ebc.js" as="script"><link rel="prefetch" href="/assets/404.html-05149ab9.js" as="script"><link rel="prefetch" href="/assets/index.html-090ad6a8.js" as="script"><link rel="prefetch" href="/assets/index.html-4c65e945.js" as="script"><link rel="prefetch" href="/assets/index.html-bb243685.js" as="script"><link rel="prefetch" href="/assets/index.html-7fe4ae79.js" as="script"><link rel="prefetch" href="/assets/index.html-9c5483fa.js" as="script"><link rel="prefetch" href="/assets/index.html-dce96f42.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-2450701e.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a href="/" class="vp-brand"><img class="vp-nav-logo" src="/小熊猫.png" alt><!----><!----></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><!----><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><!----><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><!--[--><a href="/Netty_source/" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="Netty源码分析"><!---->Netty源码分析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Netty_source/01-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="01-服务端启动流程"><!---->01-服务端启动流程<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Netty_source/02-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%B7%BB%E5%8A%A0ChannelInitializer%E5%88%B0%E7%AE%A1%E9%81%93.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="02-服务端启动添加ChannelInitializer到管道"><!---->02-服务端启动添加ChannelInitializer到管道<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Netty_source/03-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="03-客户端启动流程"><!---->03-客户端启动流程<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Netty_source/04-%E7%BA%BF%E7%A8%8B%E4%BD%93%E7%B3%BB-NioEventLoopGroup.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="04-线程体系-NioEventLoopGroup"><!---->04-线程体系-NioEventLoopGroup<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Netty_source/05-%E7%BA%BF%E7%A8%8B%E4%BD%93%E7%B3%BB-NioEventLoop%E7%9B%B8%E5%85%B3%E7%88%B6%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="05-线程体系-NioEventLoop相关接口分析"><!---->05-线程体系-NioEventLoop相关接口分析<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Netty_source/06-%E7%BA%BF%E7%A8%8B%E4%BD%93%E7%B3%BB-AbstractEventExecutor.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="06-线程体系-AbstractEventExecutor"><!---->06-线程体系-AbstractEventExecutor<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Netty_source/07-%E7%BA%BF%E7%A8%8B%E4%BD%93%E7%B3%BB-AbstractScheduledEventExecutor-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="07-线程体系-AbstractScheduledEventExecutor-优先队列"><!---->07-线程体系-AbstractScheduledEventExecutor-优先队列<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Netty_source/08-%E7%BA%BF%E7%A8%8B%E4%BD%93%E7%B3%BB-NioEventLoop%E6%A6%82%E8%BF%B0.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="08-线程体系-NioEventLoop概述"><!---->08-线程体系-NioEventLoop概述<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Netty_source/09-%E7%BA%BF%E7%A8%8B%E4%BD%93%E7%B3%BB-NioEventLoop%E5%BC%80%E5%90%AFSelector%E5%8F%8A%E4%BC%98%E5%8C%96.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="09-线程体系-NioEventLoop开启Selector及优化"><!---->09-线程体系-NioEventLoop开启Selector及优化<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Netty_source/10-%E7%BA%BF%E7%A8%8B%E4%BD%93%E7%B3%BB-NioEventLoop%E7%BB%91%E5%AE%9A%E7%BA%BF%E7%A8%8B.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="10-线程体系-NioEventLoop绑定线程"><!---->10-线程体系-NioEventLoop绑定线程<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Netty_source/11-%E7%BA%BF%E7%A8%8B%E4%BD%93%E7%B3%BB-NioEventLoop%E7%9A%84run%E6%96%B9%E6%B3%95.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="11-线程体系-NioEventLoop的run方法"><!---->11-线程体系-NioEventLoop的run方法<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Netty_source/12-%E7%BA%BF%E7%A8%8B%E4%BD%93%E7%B3%BB-NioEventLoop%E8%A7%84%E9%81%BFJDK%E7%9A%84NIO%E7%A9%BA%E5%BE%AA%E7%8E%AFbug.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="12-线程体系-NioEventLoop规避JDK的NIO空循环bug"><!---->12-线程体系-NioEventLoop规避JDK的NIO空循环bug<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Netty_source/13-%E7%BA%BF%E7%A8%8B%E4%BD%93%E7%B3%BB-NioEventLoop%E7%9A%84%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="13-线程体系-NioEventLoop的优雅关闭"><!---->13-线程体系-NioEventLoop的优雅关闭<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Netty_source/14-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%BF%9E%E6%8E%A5(ACCEPT).html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="14-服务端处理客户端的连接(ACCEPT)"><!---->14-服务端处理客户端的连接(ACCEPT)<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Netty_source/15-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E6%A6%82%E8%BF%B0.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="15-客户端处理READ事件概述"><!---->15-客户端处理READ事件概述<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html" class="router-link-active router-link-exact-active nav-link active vp-sidebar-link vp-sidebar-page active" aria-label="16-客户端处理READ事件详解及RecvByteBufAllocator"><!---->16-客户端处理READ事件详解及RecvByteBufAllocator<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#分析顺序" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="分析顺序"><!---->分析顺序<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#处理-read-事件相关类的源码分析" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="处理 READ 事件相关类的源码分析"><!---->处理 READ 事件相关类的源码分析<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#继承体系" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="继承体系"><!---->继承体系<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#recvbytebufallocator-接口" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="RecvByteBufAllocator 接口"><!---->RecvByteBufAllocator 接口<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#maxmessagesrecvbytebufallocator-接口" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="MaxMessagesRecvByteBufAllocator 接口"><!---->MaxMessagesRecvByteBufAllocator 接口<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#defaultmaxmessagesrecvbytebufallocator-抽象类" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="DefaultMaxMessagesRecvByteBufAllocator 抽象类"><!---->DefaultMaxMessagesRecvByteBufAllocator 抽象类<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#maxmessagehandle-的成员属性" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="MaxMessageHandle 的成员属性"><!---->MaxMessageHandle 的成员属性<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#handleimpl-的成员属性" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="HandleImpl 的成员属性"><!---->HandleImpl 的成员属性<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#客户端处理-read-事件详细流程" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="客户端处理 READ 事件详细流程"><!---->客户端处理 READ 事件详细流程<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#流程概览" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="流程概览"><!---->流程概览<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#重置数据" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="重置数据"><!---->重置数据<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#do-while-循环-获取-bytebuf" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="do...while 循环：获取 ByteBuf"><!---->do...while 循环：获取 ByteBuf<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#do-while-循环-读取-channel-数据" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="do...while 循环：读取 Channel 数据"><!---->do...while 循环：读取 Channel 数据<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#do-while-循环-校验读取数据量" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="do...while 循环：校验读取数据量"><!---->do...while 循环：校验读取数据量<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#do-while-循环-循环计数自增" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="do...while 循环：循环计数自增"><!---->do...while 循环：循环计数自增<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#do-while-循环-传递-channelread-事件" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="do...while 循环：传递 channelRead 事件"><!---->do...while 循环：传递 channelRead 事件<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#do-while-循环-校验-while-条件" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="do...while 循环：校验 while 条件"><!---->do...while 循环：校验 while 条件<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#读取完毕-后续操作" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="读取完毕，后续操作"><!---->读取完毕，后续操作<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#小结" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="小结"><!---->小结<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#读数据缓冲区-bytebuf-的自适应扩容缩容机制" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="读数据缓冲区 ByteBuf 的自适应扩容缩容机制"><!---->读数据缓冲区 ByteBuf 的自适应扩容缩容机制<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#分配-bytebuf-入口" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="分配 ByteBuf 入口"><!---->分配 ByteBuf 入口<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#自适应扩容缩容的入口" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="自适应扩容缩容的入口"><!---->自适应扩容缩容的入口<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#自适应扩容缩容的索引表" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="自适应扩容缩容的索引表"><!---->自适应扩容缩容的索引表<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#自适应扩容缩容分析" class="router-link-active router-link-exact-active nav-link vp-sidebar-link vp-heading" aria-label="自适应扩容缩容分析"><!---->自适应扩容缩容分析<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a href="/Netty_source/17-Netty%E7%AE%A1%E9%81%93%E6%9C%BA%E5%88%B6.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="17-Netty管道机制"><!---->17-Netty管道机制<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/Netty_source/18-Netty%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%87%BA%E7%AB%99%E7%BC%93%E5%86%B2%E5%8C%BA.html" class="nav-link vp-sidebar-link vp-sidebar-page" aria-label="18-Netty发送数据流程及出站缓冲区"><!---->18-Netty发送数据流程及出站缓冲区<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->16-客户端处理READ事件详解及RecvByteBufAllocator</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="page-author-item">超威蓝猫 Dylan Kwok</span></span><span property="author" content="超威蓝猫 Dylan Kwok"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2022-02-23T18:34:24.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 19 分钟</span><meta property="timeRequired" content="PT19M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#分析顺序" class="router-link-active router-link-exact-active toc-link level2">分析顺序</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#处理-read-事件相关类的源码分析" class="router-link-active router-link-exact-active toc-link level2">处理 READ 事件相关类的源码分析</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#继承体系" class="router-link-active router-link-exact-active toc-link level3">继承体系</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#recvbytebufallocator-接口" class="router-link-active router-link-exact-active toc-link level3">RecvByteBufAllocator 接口</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#maxmessagesrecvbytebufallocator-接口" class="router-link-active router-link-exact-active toc-link level3">MaxMessagesRecvByteBufAllocator 接口</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#defaultmaxmessagesrecvbytebufallocator-抽象类" class="router-link-active router-link-exact-active toc-link level3">DefaultMaxMessagesRecvByteBufAllocator 抽象类</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#maxmessagehandle-的成员属性" class="router-link-active router-link-exact-active toc-link level3">MaxMessageHandle 的成员属性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#handleimpl-的成员属性" class="router-link-active router-link-exact-active toc-link level3">HandleImpl 的成员属性</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#客户端处理-read-事件详细流程" class="router-link-active router-link-exact-active toc-link level2">客户端处理 READ 事件详细流程</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#流程概览" class="router-link-active router-link-exact-active toc-link level3">流程概览</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#重置数据" class="router-link-active router-link-exact-active toc-link level3">重置数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#do-while-循环-获取-bytebuf" class="router-link-active router-link-exact-active toc-link level3">do...while 循环：获取 ByteBuf</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#do-while-循环-读取-channel-数据" class="router-link-active router-link-exact-active toc-link level3">do...while 循环：读取 Channel 数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#do-while-循环-校验读取数据量" class="router-link-active router-link-exact-active toc-link level3">do...while 循环：校验读取数据量</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#do-while-循环-循环计数自增" class="router-link-active router-link-exact-active toc-link level3">do...while 循环：循环计数自增</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#do-while-循环-传递-channelread-事件" class="router-link-active router-link-exact-active toc-link level3">do...while 循环：传递 channelRead 事件</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#do-while-循环-校验-while-条件" class="router-link-active router-link-exact-active toc-link level3">do...while 循环：校验 while 条件</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#读取完毕-后续操作" class="router-link-active router-link-exact-active toc-link level3">读取完毕，后续操作</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#小结" class="router-link-active router-link-exact-active toc-link level3">小结</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#读数据缓冲区-bytebuf-的自适应扩容缩容机制" class="router-link-active router-link-exact-active toc-link level2">读数据缓冲区 ByteBuf 的自适应扩容缩容机制</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#分配-bytebuf-入口" class="router-link-active router-link-exact-active toc-link level3">分配 ByteBuf 入口</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#自适应扩容缩容的入口" class="router-link-active router-link-exact-active toc-link level3">自适应扩容缩容的入口</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#自适应扩容缩容的索引表" class="router-link-active router-link-exact-active toc-link level3">自适应扩容缩容的索引表</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/Netty_source/16-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%E5%8F%8ARecvByteBufAllocator.html#自适应扩容缩容分析" class="router-link-active router-link-exact-active toc-link level3">自适应扩容缩容分析</a></li><!----><!--]--></ul></li><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><table><thead><tr><th>版本</th><th>内容</th><th>时间</th></tr></thead><tbody><tr><td>V1</td><td>新建</td><td>2022年2月18日18:34:24</td></tr><tr><td>V2</td><td>重构</td><td>2023年05月27日14:28:26</td></tr></tbody></table><h2 id="分析顺序" tabindex="-1"><a class="header-anchor" href="#分析顺序" aria-hidden="true">#</a> 分析顺序</h2><p>想要理明白客户端处理 READ 事件的读循环，必须了解 AdaptiveRecvByteBufAllocator 和 MaxMessageHandle 这两个类的实现原理。本篇文章的分析流程如下：</p><ol><li><p>处理 READ 事件相关类的源码分析；</p><ol><li>AdaptiveRecvByteBufAllocator 源码分析；</li><li>MaxMessageHandle 源码分析；</li></ol></li><li><p>客户端处理 READ 事件的主要流程；</p></li><li><p>读取数据缓冲区 ByteBuf 的自适应扩容缩容机制；</p></li></ol><h2 id="处理-read-事件相关类的源码分析" tabindex="-1"><a class="header-anchor" href="#处理-read-事件相关类的源码分析" aria-hidden="true">#</a> 处理 READ 事件相关类的源码分析</h2><h3 id="继承体系" tabindex="-1"><a class="header-anchor" href="#继承体系" aria-hidden="true">#</a> 继承体系</h3><p><img src="/assets/image-20230525224053239-9d274d58.png" alt="image-20230525224053239"></p><p>这幅图包含了两个关键的类 AdaptiveRecvByteBufAllocator 和 MaxMessageHandle。</p><h3 id="recvbytebufallocator-接口" tabindex="-1"><a class="header-anchor" href="#recvbytebufallocator-接口" aria-hidden="true">#</a> RecvByteBufAllocator 接口</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RecvByteBufAllocator</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建一个新的Handle，保存着预测的一些信息</span>
    <span class="token class-name">Handle</span> <span class="token function">newHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Deprecated</span>
    <span class="token keyword">interface</span> <span class="token class-name">Handle</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个新的接收缓冲区，其容量可能足够大以读取所有入站数据，并且足够小以不浪费其空间</span>
        <span class="token class-name">ByteBuf</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token class-name">ByteBufAllocator</span> alloc<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 预测读循环下次该用多大的缓冲区接收数据</span>
        <span class="token keyword">int</span> <span class="token function">guess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 读循环前重置上一次 READ 事件读取数据的一些统计参数</span>
        <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token class-name">ChannelConfig</span> config<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 增加当前读取循环已读取的次数</span>
        <span class="token keyword">void</span> <span class="token function">incMessagesRead</span><span class="token punctuation">(</span><span class="token keyword">int</span> numMessages<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 设置上次循环中读取操作已读取的字节数</span>
        <span class="token keyword">void</span> <span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token keyword">int</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 获取上次循环中读取的字节数</span>
        <span class="token keyword">int</span> <span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 设置-读取操作将（或已经）尝试读取的字节数。</span>
        <span class="token keyword">void</span> <span class="token function">attemptedBytesRead</span><span class="token punctuation">(</span><span class="token keyword">int</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 获取-读取操作将（或已经）尝试读取的字节数。</span>
        <span class="token keyword">int</span> <span class="token function">attemptedBytesRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 判断是否应该继续循环读取数据，一般用作 while 条件</span>
        <span class="token keyword">boolean</span> <span class="token function">continueReading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// READ 事件读取数据这步完成了，需要做一些处理，例如可能做自适应扩容缩容</span>
        <span class="token keyword">void</span> <span class="token function">readComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;deprecation&quot;</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@UnstableApi</span>
    <span class="token keyword">interface</span> <span class="token class-name">ExtendedHandle</span> <span class="token keyword">extends</span> <span class="token class-name">Handle</span> <span class="token punctuation">{</span>
        <span class="token comment">// 判断是否应该继续循环读取数据，一般用作 while 条件</span>
        <span class="token keyword">boolean</span> <span class="token function">continueReading</span><span class="token punctuation">(</span><span class="token class-name">UncheckedBooleanSupplier</span> maybeMoreDataSupplier<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">DelegatingHandle</span> <span class="token keyword">implements</span> <span class="token class-name">Handle</span> <span class="token punctuation">{</span>
        <span class="token comment">// ......省略......</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>RecvByteBufAllocator 有两个内部接口，分别是 Handle 和 ExtendedHandle 接口，它们的作用分别为：</p><ul><li>RecvByteBufAllocator 接口：提供创建 Handle 接口的实现类的 API；</li><li>Handle 接口：主要提供读循环次数控制和自适应扩容缩容的 API；</li><li>ExtendedHandle 接口：扩展了 Handle 接口的 continueReading 方法；</li></ul><h3 id="maxmessagesrecvbytebufallocator-接口" tabindex="-1"><a class="header-anchor" href="#maxmessagesrecvbytebufallocator-接口" aria-hidden="true">#</a> MaxMessagesRecvByteBufAllocator 接口</h3><p>MaxMessagesRecvByteBufAllocator 接口继承自 RecvByteBufAllocator 接口，主要是额外提供了两个方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 限制EventLoop尝试读取操作时尝试的读取操作次数</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MaxMessagesRecvByteBufAllocator</span> <span class="token keyword">extends</span> <span class="token class-name">RecvByteBufAllocator</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取-每个读取循环允许读的次数</span>
    <span class="token keyword">int</span> <span class="token function">maxMessagesPerRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 设置-每个读取循环允许读的次数</span>
    <span class="token class-name">MaxMessagesRecvByteBufAllocator</span> <span class="token function">maxMessagesPerRead</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxMessagesPerRead<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前面我们提到过，读循环次数是有限制的，默认是 16 次，可以通过这两个 API 设置。</p><h3 id="defaultmaxmessagesrecvbytebufallocator-抽象类" tabindex="-1"><a class="header-anchor" href="#defaultmaxmessagesrecvbytebufallocator-抽象类" aria-hidden="true">#</a> DefaultMaxMessagesRecvByteBufAllocator 抽象类</h3><p>这个抽象类主要提供两个字段：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">DefaultMaxMessagesRecvByteBufAllocator</span> <span class="token keyword">implements</span> <span class="token class-name">MaxMessagesRecvByteBufAllocator</span> <span class="token punctuation">{</span>
    <span class="token comment">// 读循环允许的最大读次数</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> maxMessagesPerRead<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> respectMaybeMoreData <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
 
    <span class="token comment">// ......省略......</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>maxMessagesPerRead：表示读循环允许的最大读次数，超过无论数据是否读取完毕都会退出读循环；</li><li>respectMaybeMoreData：这个参数较复杂，用于控制 Channel 中可能还有数据未读取的情况下，如何处理的 <ul><li>true：当某次读循环读取的数据把分配的 ByteBuf 占满了，则说明 Channel 上可能还有数据未读取，需要继续尝试读取数据；</li><li>false：无论某次循环读取到的数据是否占满 ByteBuf，都需要继续循环读取数据。直到读取不到数据，或者对端关闭，或者超过读循环次数了，就退出循环；</li></ul></li></ul><p>关于 respectMaybeMoreData 参数，直译过来就是，对可能还有数据需要谨慎（respect）对待。</p><h3 id="maxmessagehandle-的成员属性" tabindex="-1"><a class="header-anchor" href="#maxmessagehandle-的成员属性" aria-hidden="true">#</a> MaxMessageHandle 的成员属性</h3><p>MaxMessageHandle 的方法比较多，这里只说明它的成员属性代表的含义，后面分析 do...while...循环会结合成员方法一起分析：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">MaxMessageHandle</span> <span class="token keyword">implements</span> <span class="token class-name">ExtendedHandle</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">ChannelConfig</span> config<span class="token punctuation">;</span>
    <span class="token comment">// do...while... 读循环最大能够读取多少次，默认 16 次</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> maxMessagePerRead<span class="token punctuation">;</span>
    <span class="token comment">// do...while... 已经循环读取的次数</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> totalMessages<span class="token punctuation">;</span>
    <span class="token comment">// do...while... 循环已经读取的数据大小 size</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> totalBytesRead<span class="token punctuation">;</span>
    <span class="token comment">// 某次循环预计可以读的字节数</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> attemptedBytesRead<span class="token punctuation">;</span>
    <span class="token comment">// 最后一次读的字节数</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> lastBytesRead<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> respectMaybeMoreData <span class="token operator">=</span> <span class="token class-name">DefaultMaxMessagesRecvByteBufAllocator</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>respectMaybeMoreData<span class="token punctuation">;</span>
	
    <span class="token comment">// ......省略成员方法......</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>maxMessagePerRead：do...while... 读循环最大能够读取多少次，默认 16 次；</li><li>totalMessages：do...while... 已经循环读取的次数；</li><li>totalBytesRead：do...while... 循环已经读取的数据大小；</li><li>attemptedBytesRead：某次循环预计可以读的字节数；</li><li>lastBytesRead：最后一次读的字节数；</li><li>respectMaybeMoreData：就是上一节分析的含义，见一节；</li></ul><h3 id="handleimpl-的成员属性" tabindex="-1"><a class="header-anchor" href="#handleimpl-的成员属性" aria-hidden="true">#</a> HandleImpl 的成员属性</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HandleImpl</span> <span class="token keyword">extends</span> <span class="token class-name">MaxMessageHandle</span> <span class="token punctuation">{</span>
    <span class="token comment">// 最小的在 SIZE_TABLE 的索引</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> minIndex<span class="token punctuation">;</span>
    <span class="token comment">// 最大的在 SIZE_TABLE 的索引</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> maxIndex<span class="token punctuation">;</span>
    <span class="token comment">// 当前缓冲区大小 在数组中的索引</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> index<span class="token punctuation">;</span>
    <span class="token comment">// 下一次分配的缓冲区的大小，，默认初始值 2048</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> nextReceiveBufferSize<span class="token punctuation">;</span>
    <span class="token comment">// 控制是否缩容</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> decreaseNow<span class="token punctuation">;</span>

	<span class="token comment">// ......省略成员方法......</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里主要关心 nextReceiveBufferSize 字段，表示下一次给读数据分配的缓冲区的大小，这个值是会自适应变大变小的，默认的初始值是 2048。</p><p>关于其他字段是自适应扩容缩容要用的，后面小节详细分析，这里先略过。</p><h2 id="客户端处理-read-事件详细流程" tabindex="-1"><a class="header-anchor" href="#客户端处理-read-事件详细流程" aria-hidden="true">#</a> 客户端处理 READ 事件详细流程</h2><h3 id="流程概览" tabindex="-1"><a class="header-anchor" href="#流程概览" aria-hidden="true">#</a> 流程概览</h3><p><img src="/assets/客户端处理READ事件-ca048891.png" alt="客户端处理READ事件"></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
     * 1 通过 doReadBytes(byteBuf) 方法,从底层NIO 通道中读取数据到输入缓冲区ByteBuf 中。
     * 2 通过 pipeline.fireChannelRead(...) 方法，发送ChannelRead读取事件。
     * 3 通过 allocHandle.continueReading() 判断是否需要继续读取。
     * 4 这次读取完成，调用 pipeline.fireChannelReadComplete() 方法，发送 ChannelReadComplete 读取完成事件。
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取客户端的配置Config对象</span>
        <span class="token keyword">final</span> <span class="token class-name">ChannelConfig</span> config <span class="token operator">=</span> <span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldBreakReadReady</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">clearReadPending</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 获取客户端的pipeline对象</span>
        <span class="token keyword">final</span> <span class="token class-name">ChannelPipeline</span> pipeline <span class="token operator">=</span> <span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取缓冲区分配器，默认是PooledByteBufAllocator</span>
        <span class="token keyword">final</span> <span class="token class-name">ByteBufAllocator</span> allocator <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getAllocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 控制读循环和预测下次创建的bytebuf的容量大小</span>
        <span class="token keyword">final</span> <span class="token class-name">RecvByteBufAllocator<span class="token punctuation">.</span>Handle</span> allocHandle <span class="token operator">=</span> <span class="token function">recvBufAllocHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 清空上一次读取的字节数，每次读取时搜重新计算</span>
        allocHandle<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">ByteBuf</span> byteBuf <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> close <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">do</span> <span class="token punctuation">{</span>
                <span class="token comment">// 参数是缓冲区内存分配器</span>
                <span class="token comment">// allocHandle只是预测分配多大的内存</span>
                byteBuf <span class="token operator">=</span> allocHandle<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>allocator<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// doReadBytes(byteBuf) 读取当前Socket读缓冲区的数据到byteBuf对象中</span>
                allocHandle<span class="token punctuation">.</span><span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token function">doReadBytes</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// channel底层Socket读缓冲区 已经完全读取完毕会返回0，或者是Channel对端关闭了 返回-1</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>allocHandle<span class="token punctuation">.</span><span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// nothing was read. release the buffer.</span>
                    byteBuf<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    byteBuf <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    close <span class="token operator">=</span> allocHandle<span class="token punctuation">.</span><span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>close<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">// There is nothing left to read as we received an EOF.</span>
                        <span class="token comment">// 此时是 -1</span>
                        readPending <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token comment">// 更新缓冲区预测分配器 读取消息数量</span>
                allocHandle<span class="token punctuation">.</span><span class="token function">incMessagesRead</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                readPending <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token comment">// 因为 TCP 有粘包问题</span>
                <span class="token comment">// 向客户端pipeline发送channelRead事件，该pipeline实现了channelRead的Handler就可以进行业务处理了</span>
                pipeline<span class="token punctuation">.</span><span class="token function">fireChannelRead</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
                byteBuf <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>allocHandle<span class="token punctuation">.</span><span class="token function">continueReading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 读取操作完毕</span>
            allocHandle<span class="token punctuation">.</span><span class="token function">readComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 触发管道的fireChannelReadComplete事件</span>
            pipeline<span class="token punctuation">.</span><span class="token function">fireChannelReadComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>close<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果连接对端关闭了，则关闭读操作</span>
                <span class="token function">closeOnRead</span><span class="token punctuation">(</span>pipeline<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">handleReadException</span><span class="token punctuation">(</span>pipeline<span class="token punctuation">,</span> byteBuf<span class="token punctuation">,</span> t<span class="token punctuation">,</span> close<span class="token punctuation">,</span> allocHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token comment">// Check if there is a readPending which was not processed yet.</span>
            <span class="token comment">// This could be for two reasons:</span>
            <span class="token comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span>
            <span class="token comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span>
            <span class="token comment">//</span>
            <span class="token comment">// See https://github.com/netty/netty/issues/2254</span>
            <span class="token comment">// 假如读操作完毕，且没有配置自动读，则从选择的Key兴趣集中移除读操作事件</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>readPending <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>config<span class="token punctuation">.</span><span class="token function">isAutoRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">removeReadOp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>处理 TCP 半关闭（Half-Close）；</li><li>获取缓存区分配器 ByteBufAllocator 和控制读循环和预测缓存大小的分配器 RecvByteBufAllocator.Handle；</li><li><code>allocHandle.reset(config)</code>，循环前重置一些数据，如清空上一次读取的字节数；</li><li>do...while... 循环读取数据；</li><li><code>allocHandle.allocate(allocator)</code> 预测当前循环需要使用多大的 ByteBuf；</li><li>通过 <code>doReadBytes(byteBuf)</code> 方法，从底层 NIO 通道中读取数据到输入缓冲区 ByteBuf 中，如果所有数据都读取完毕，或者对端关闭连接了，就退出循环；</li><li><code>allocHandle.incMessagesRead(1)</code> 更新缓冲区预测分配器，增加读循环次数；</li><li><code> pipeline.fireChannelRead(byteBuf)</code>，向客户端 pipeline 发送 channelRead 事件；</li><li>while 循环的条件 <code>allocHandle.continueReading()</code>，判断是否允许继续循环读数据；</li><li>当前次数数据读取完毕或者循环读到了上限 16 次（可能 16 次都没读完），<code>pipeline.fireChannelReadComplete()</code> 向客户端管道发送 channelReadComplete 事件；</li></ol><h3 id="重置数据" tabindex="-1"><a class="header-anchor" href="#重置数据" aria-hidden="true">#</a> 重置数据</h3><p>在获取到缓冲区 ByteBuf 分配器 ByteBufAllocator 和 RecvByteBufAllocator 对象后，需要情况上一次 READ 事件的一些数据。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 清空上一次读取的字节数，每次读取时搜重新计算</span>
allocHandle<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>最终调用到 MaxMessageHandle#reset 方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token class-name">ChannelConfig</span> config<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>config <span class="token operator">=</span> config<span class="token punctuation">;</span>
    <span class="token comment">// 重新设置 读循环操作 最大可读消息量，默认情况下是16，服务端和客户端都是16</span>
    maxMessagePerRead <span class="token operator">=</span> <span class="token function">maxMessagesPerRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 统计字段归零</span>
    totalMessages <span class="token operator">=</span> totalBytesRead <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要就是将读循环最大次数 maxMessagePerRead、当前 do...while 循环的次数、和当前 do...while... 总共读取的数据大小都清空。</p><h3 id="do-while-循环-获取-bytebuf" tabindex="-1"><a class="header-anchor" href="#do-while-循环-获取-bytebuf" aria-hidden="true">#</a> do...while 循环：获取 ByteBuf</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>byteBuf <span class="token operator">=</span> allocHandle<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>allocator<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过 RecvByteBufAllocator 和 ByteBufAllocator 获取 ByteBuf 对象，用于存放此次循环读取的数据。</p><p>调用到 MaxMessageHandle#allocate 方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">ByteBuf</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token class-name">ByteBufAllocator</span> alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// guess()根据读循环过程中的上下文，预估一个适合本次读大小的值</span>
    <span class="token comment">// alloc.ioBuffer 真正分配缓冲区的对象</span>
    <span class="token keyword">return</span> alloc<span class="token punctuation">.</span><span class="token function">ioBuffer</span><span class="token punctuation">(</span><span class="token function">guess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关键点就是这个 HandleImpl#guess 方法，前面说过 nextReceiveBufferSize 是下一次分配缓冲区 ByteBuf 的大小。是一个自适应的值。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">guess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> nextReceiveBufferSize<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>后面分析自适应扩容缩容的时候详细分析 nextReceiveBufferSize 字段，这里只需要知道会分配一个 nextReceiveBufferSize大小的 ByteBuf，用于本次循环读数据用。</p><h3 id="do-while-循环-读取-channel-数据" tabindex="-1"><a class="header-anchor" href="#do-while-循环-读取-channel-数据" aria-hidden="true">#</a> do...while 循环：读取 Channel 数据</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>allocHandle<span class="token punctuation">.</span><span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token function">doReadBytes</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这一步首先调用 NioSocketChannel#doReadBytes 方法读取数据到 ByteBuf 里：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">doReadBytes</span><span class="token punctuation">(</span><span class="token class-name">ByteBuf</span> byteBuf<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取计算内存分配器Handle</span>
    <span class="token keyword">final</span> <span class="token class-name">RecvByteBufAllocator<span class="token punctuation">.</span>Handle</span> allocHandle <span class="token operator">=</span> <span class="token function">unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">recvBufAllocHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置尝试读取字节数为buf的可写字节数</span>
    allocHandle<span class="token punctuation">.</span><span class="token function">attemptedBytesRead</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">.</span><span class="token function">writableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 参数1:JDK层面的SocketChannel实例</span>
    <span class="token comment">// 参数2：长度length，想要读取的数据量</span>
    <span class="token comment">// 返回从SocketChannel中读取的数据量</span>
    <span class="token comment">// 从Channel中读取字节数并写入buf，返回读取字节</span>
    <span class="token keyword">return</span> byteBuf<span class="token punctuation">.</span><span class="token function">writeBytes</span><span class="token punctuation">(</span><span class="token function">javaChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> allocHandle<span class="token punctuation">.</span><span class="token function">attemptedBytesRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将本次 Channel 中可读取的数据大小保存到 MaxMessageHandle 类的 attemptedBytesRead 属性中，后面用于判断 while 循环的条件。MaxMessageHandle#attemptedBytesRead(int)</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">attemptedBytesRead</span><span class="token punctuation">(</span><span class="token keyword">int</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    attemptedBytesRead <span class="token operator">=</span> bytes<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>NioSocketChannel#doReadBytes 方法执行完毕后，调用 Handle#lastBytesRead(int) 方法记录当前真实读取到的数据大小，待会儿会和上面的 attemptedBytesRead 属性做比较。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token keyword">int</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果条件成立：说明读取的数据量和预测的数据量一致，</span>
    <span class="token comment">// 也就是说将接收缓冲区的可写位置填满了，说明ch内可能还有数据未读取完...还需要继续</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">==</span> <span class="token function">attemptedBytesRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 要进行缓冲区大小伸缩了</span>
        <span class="token function">record</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">lastBytesRead</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>父类的 MaxMessageHandle#lastBytesRead(int) 方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token keyword">int</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    lastBytesRead <span class="token operator">=</span> bytes<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        totalBytesRead <span class="token operator">+=</span> bytes<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的 record 方法是处理自适应扩容缩容的，这里放在后面分析。在父类的 MaxMessageHandle#lastBytesRead(int) 方法中，可以看到就是记录 lastBytesRead 字段的值，然后累加此次 do...while... 循环读取到的数据总量。</p><h3 id="do-while-循环-校验读取数据量" tabindex="-1"><a class="header-anchor" href="#do-while-循环-校验读取数据量" aria-hidden="true">#</a> do...while 循环：校验读取数据量</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// channel底层Socket读缓冲区 已经完全读取完毕会返回0，或者是Channel对端关闭了 返回-1</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>allocHandle<span class="token punctuation">.</span><span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// nothing was read. release the buffer.</span>
    byteBuf<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    byteBuf <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    close <span class="token operator">=</span> allocHandle<span class="token punctuation">.</span><span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>close<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// There is nothing left to read as we received an EOF.</span>
        <span class="token comment">// 此时是 -1</span>
        readPending <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>allocHandle.lastBytesRead()</code> 方法获取当前某次循环读取到的数据量，校验当前读取的数据是否正常：</p><ol><li>等于 0：说明当前数据已经读取完毕了，释放 ByteBuf 对象，并退出循环；</li><li>小于 0：说明 Channel 对端关闭连接了，其实就是返回 -1，此时也需要释放 ByteBuf 对象，退出循环后会关闭读操作；</li><li>大于 0：说明本次读到数据了，在 while 条件满足的情况下会继续尝试循环读取数据；</li></ol><h3 id="do-while-循环-循环计数自增" tabindex="-1"><a class="header-anchor" href="#do-while-循环-循环计数自增" aria-hidden="true">#</a> do...while 循环：循环计数自增</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 更新缓冲区预测分配器 读取消息数量</span>
allocHandle<span class="token punctuation">.</span><span class="token function">incMessagesRead</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>MaxMessageHandle#incMessagesRead 方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 增加读消息的数量
 * <span class="token keyword">@param</span> <span class="token parameter">amt</span>
 */</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">incMessagesRead</span><span class="token punctuation">(</span><span class="token keyword">int</span> amt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    totalMessages <span class="token operator">+=</span> amt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>就是将 totalMessages 字段的值自增，表示已经循环读取的次数。</p><h3 id="do-while-循环-传递-channelread-事件" tabindex="-1"><a class="header-anchor" href="#do-while-循环-传递-channelread-事件" aria-hidden="true">#</a> do...while 循环：传递 channelRead 事件</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 向客户端pipeline发送channelRead事件，该pipeline实现了channelRead的Handler就可以进行业务处理了</span>
pipeline<span class="token punctuation">.</span><span class="token function">fireChannelRead</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
byteBuf <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="do-while-循环-校验-while-条件" tabindex="-1"><a class="header-anchor" href="#do-while-循环-校验-while-条件" aria-hidden="true">#</a> do...while 循环：校验 while 条件</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>allocHandle<span class="token punctuation">.</span><span class="token function">continueReading</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>调用 MaxMessageHandle#continueReading() 方法判断是否允许继续循环读取数据。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">continueReading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">continueReading</span><span class="token punctuation">(</span>defaultMaybeMoreSupplier<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">continueReading</span><span class="token punctuation">(</span><span class="token class-name">UncheckedBooleanSupplier</span> maybeMoreDataSupplier<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> config<span class="token punctuation">.</span><span class="token function">isAutoRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
           <span class="token punctuation">(</span><span class="token operator">!</span>respectMaybeMoreData <span class="token operator">||</span> maybeMoreDataSupplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
           totalMessages <span class="token operator">&lt;</span> maxMessagePerRead <span class="token operator">&amp;&amp;</span>
           totalBytesRead <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 defaultMaybeMoreSupplier 参数如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">UncheckedBooleanSupplier</span> defaultMaybeMoreSupplier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UncheckedBooleanSupplier</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> attemptedBytesRead <span class="token operator">==</span> lastBytesRead<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个 while 条件的判断十分复杂，先说一下空参 continueReading 方法内部的重载方法传入的默认的 defaultMaybeMoreSupplier 参数，就是 <code>attemptedBytesRead == lastBytesRead</code>，这里我们得知道这两个字段的含义，前面已经分析过，这里再复述一遍：</p><ul><li>attemptedBytesRead：某次循环预计可读的数据量，（其实就是分配的 ByteBuf 的可写的大小）；</li><li>lastBytesRead：某次循环实际读取的数据量；</li></ul><p>把这两个条件做等值比较，表示就含义就是 「某次循环预计可读的数据量和实际读取的数据量是否相等」，如果相等了，则说明实际读取的数据量把分配的缓冲区 ByteBuf 占满了，也就是说明，SocketChannel 中可能还存在数据没有读取完，可能需要继续尝试循环读取。</p><p><strong>总的来说，对于 defaultMaybeMoreSupplier，返回 true，就表示可能还有数据未读取完；返回 false，表示 SocketChannel 此次读取数据完毕了。</strong></p><p>接下来分析 continueReading 方法里的四个条件了。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token keyword">return</span> config<span class="token punctuation">.</span><span class="token function">isAutoRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
           <span class="token punctuation">(</span><span class="token operator">!</span>respectMaybeMoreData <span class="token operator">||</span> maybeMoreDataSupplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
           totalMessages <span class="token operator">&lt;</span> maxMessagePerRead <span class="token operator">&amp;&amp;</span>
           totalBytesRead <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>config.isAutoRead() 默认就是 true；</li><li>respectMaybeMoreData 前面分析过，具体见上面的 DefaultMaxMessagesRecvByteBufAllocator 类的字段分析。主要就是根据这个字段来决定是否继续用 defaultMaybeMoreSupplier 条件来判断。 <ul><li>假如 respectMaybeMoreData 是 true，就需要通过 defaultMaybeMoreSupplier 来判断，如果 defaultMaybeMoreSupplier 返回 true，就表示可能还有数据未读取完，需要尝试继续循环读取数据；</li></ul></li><li>totalMessages 小于 maxMessagePerRead：表示 do...while... 循环次数还未到达上限（默认 16 次），可以继续循环尝试读取数据；</li><li>totalBytesRead 大于 0：表示此次总的循环读取到数据了，可以继续尝试循环读取数据；</li></ul><p><strong>只有这四个条件都满足了，才允许继续 do...while... 循环读取数据。</strong></p><h3 id="读取完毕-后续操作" tabindex="-1"><a class="header-anchor" href="#读取完毕-后续操作" aria-hidden="true">#</a> 读取完毕，后续操作</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 读取操作完毕</span>
allocHandle<span class="token punctuation">.</span><span class="token function">readComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 触发管道的fireChannelReadComplete事件</span>
pipeline<span class="token punctuation">.</span><span class="token function">fireChannelReadComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>close<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果连接对端关闭了，则关闭读操作</span>
    <span class="token function">closeOnRead</span><span class="token punctuation">(</span>pipeline<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从 do...while... 循环退出后，可能有下面几种情况：</p><ol><li>此次读取数据，读完了；</li><li>此次读取数据，对端关闭连接了；</li><li>此次读取数据到达了读循环的上限次数（默认 16），Channel 内的数据还未读完；</li></ol><blockquote><p>设置读循环的上限的原因是，一个 Reactor 线程，它的 Selector 有很多 Channel 注册在上面，不能把时间都耗费在一个 Channel 上面。而且 Netty 的 Reactor 线程，除了处理 I/O 事件，还会处理一些异步任务。</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 读取操作完毕</span>
allocHandle<span class="token punctuation">.</span><span class="token function">readComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这一步操作是预估下次读取的 ByteBuf 的大小的，也就是自适应扩容缩容，下一节详细分析，这里知道入口就行了。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 触发管道的fireChannelReadComplete事件</span>
pipeline<span class="token punctuation">.</span><span class="token function">fireChannelReadComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后向管道传递 channelReadComplete 事件。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>close<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果连接对端关闭了，则关闭读操作</span>
    <span class="token function">closeOnRead</span><span class="token punctuation">(</span>pipeline<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，如果对端连接关闭了，则需要关闭读操作。</p><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h3><p>自此我们分析完了客户端处理 READ 事件的详细流程了，</p><ol><li>处理 TCP 半关闭（Half-Close）；</li><li>获取缓存区分配器 ByteBufAllocator 和控制读循环和预测缓存大小的分配器 RecvByteBufAllocator.Handle；</li><li><code>allocHandle.reset(config)</code>，循环前重置一些数据，如清空上一次读取的字节数；</li><li>do...while... 循环读取数据； <ol><li><code>allocHandle.allocate(allocator)</code> 预测当前循环需要使用多大的 ByteBuf；</li><li>通过 <code>doReadBytes(byteBuf)</code> 方法，从底层 NIO 通道中读取数据到输入缓冲区 ByteBuf 中，如果所有数据都读取完毕，或者对端关闭连接了，就退出循环；</li><li><code>allocHandle.incMessagesRead(1)</code> 更新缓冲区预测分配器，增加读循环次数；</li><li><code> pipeline.fireChannelRead(byteBuf)</code>，向客户端 pipeline 发送 channelRead 事件；</li><li>while 循环的条件 <code>allocHandle.continueReading()</code>，判断是否允许继续循环读数据；</li></ol></li><li>处理自适应扩容缩容；</li><li>当前次数数据读取完毕或者循环读到了上限 16 次（可能 16 次都没读完），<code>pipeline.fireChannelReadComplete()</code> 向客户端管道发送 channelReadComplete 事件；</li></ol><h2 id="读数据缓冲区-bytebuf-的自适应扩容缩容机制" tabindex="-1"><a class="header-anchor" href="#读数据缓冲区-bytebuf-的自适应扩容缩容机制" aria-hidden="true">#</a> 读数据缓冲区 ByteBuf 的自适应扩容缩容机制</h2><h3 id="分配-bytebuf-入口" tabindex="-1"><a class="header-anchor" href="#分配-bytebuf-入口" aria-hidden="true">#</a> 分配 ByteBuf 入口</h3><p>前面在分析客户端处理 READ 事件的 do...while... 循环中，我们说了每次循环读取数据的 ByteBuf 是可以自适应扩容缩容的。分配 ByteBuf 的入口就是</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>byteBuf <span class="token operator">=</span> allocHandle<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>allocator<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>最终就是获取的 HandleImpl 的 nextReceiveBufferSize 字段。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">guess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> nextReceiveBufferSize<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么自适应扩容缩容的关键就是 nextReceiveBufferSize 是怎么计算的了。</p><h3 id="自适应扩容缩容的入口" tabindex="-1"><a class="header-anchor" href="#自适应扩容缩容的入口" aria-hidden="true">#</a> 自适应扩容缩容的入口</h3><p>最终调整 nextReceiveBufferSize 字段大小的入口在 HandleImpl#record 方法，在 do...while... 循环中会有两个地方调用：</p><p><strong>第一个就是在 do...while 的单次循环中的下面的方法</strong>，HandleImpl#lastBytesRead</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>allocHandle<span class="token punctuation">.</span><span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token function">doReadBytes</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>就是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token keyword">int</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">==</span> <span class="token function">attemptedBytesRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 要进行缓冲区大小伸缩了</span>
        <span class="token function">record</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">lastBytesRead</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>bytes == attemptedBytesRead()</code> 是 true 的时候，说明本次读取数据的大小把 ByteBuf 都占满了，可能 channel 中可能还有更多的数据需要读取，这里就去做自适应扩容缩容的操作了。</p><p><strong>第二个就是在 do...while... 方法结束后调的了</strong>，就是</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 读取操作完毕</span>
allocHandle<span class="token punctuation">.</span><span class="token function">readComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="自适应扩容缩容的索引表" tabindex="-1"><a class="header-anchor" href="#自适应扩容缩容的索引表" aria-hidden="true">#</a> 自适应扩容缩容的索引表</h3><p>既然要自适应扩容缩容，那么得有一个指引告诉需要扩容和缩容到什么地步，Netty 中使用一个数组存放一些值，这些值表示 ByteBuf 的允许大小。</p><p>这个索引表的初始化位置在 AdaptiveRecvByteBufAllocator 类的静态代码块中：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdaptiveRecvByteBufAllocator</span> <span class="token keyword">extends</span> <span class="token class-name">DefaultMaxMessagesRecvByteBufAllocator</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_MINIMUM</span> <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>
    <span class="token comment">// Use an initial value that is bigger than the common MTU of 1500</span>
    <span class="token comment">// MTU是&quot;最大传输单元&quot;（Maximum Transmission Unit）</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL</span> <span class="token operator">=</span> <span class="token number">2048</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_MAXIMUM</span> <span class="token operator">=</span> <span class="token number">65536</span><span class="token punctuation">;</span>

    <span class="token comment">// 索引增量4（扩容增量）</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">INDEX_INCREMENT</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// 索引减量1（缩容减量）</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">INDEX_DECREMENT</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token comment">// RecvBuf分配容量表（扩缩容索引表）按照表中记录的容量大小进行扩缩容</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">SIZE_TABLE</span><span class="token punctuation">;</span>

    <span class="token doc-comment comment">/**
     * 16-496间隔16 512到2的31次-1 间隔2倍
     */</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> sizeTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 向集合16 32 48 .... 496</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">512</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sizeTable<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Suppress a warning since i becomes negative when an integer overflow happens</span>
        <span class="token comment">// 继续向数组添加 512 1024 2048 ... 直到溢出（成为负数）</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// lgtm[java/constant-comparison]</span>
            sizeTable<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token constant">SIZE_TABLE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>sizeTable<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">SIZE_TABLE</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token constant">SIZE_TABLE</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sizeTable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">// ......省略......</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单说明下上面的一些常量的含义：</p><ol><li>DEFAULT_MINIMUM：64，表示分配给 ByteBuf 大小的默认的最小值，ByteBuf 大小不会小于这个值；</li><li>DEFAULT_INITIAL：2048，表示分配给 ByteBuf 大小的默认的初始值；</li><li>DEFAULT_MAXIMUM：65536，表示分配给 ByteBuf 大小的默认的最大值，ByteBuf 大小不会大于这个值；</li><li>INDEX_INCREMENT：4，自适应扩容索引增量；</li><li>INDEX_DECREMENT：1，自适应缩容索引减量；</li><li>SIZE_TABLE 数组：就是我们的索引表了。</li></ol><p>SIZE_TABLE 初始化后，最终的效果就是：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>sizeTable = {ArrayList@1424}  size = 53
 0 = {Integer@1428} 16
 1 = {Integer@1429} 32
 2 = {Integer@1430} 48
 3 = {Integer@1431} 64
 4 = {Integer@1432} 80
 5 = {Integer@1433} 96
 6 = {Integer@1434} 112
 7 = {Integer@1435} 128
 8 = {Integer@1436} 144
 9 = {Integer@1437} 160
 10 = {Integer@1438} 176
 11 = {Integer@1439} 192
 12 = {Integer@1440} 208
 13 = {Integer@1441} 224
 14 = {Integer@1442} 240
 15 = {Integer@1443} 256
 16 = {Integer@1444} 272
 17 = {Integer@1445} 288
 18 = {Integer@1446} 304
 19 = {Integer@1447} 320
 20 = {Integer@1448} 336
 21 = {Integer@1449} 352
 22 = {Integer@1450} 368
 23 = {Integer@1451} 384
 24 = {Integer@1452} 400
 25 = {Integer@1453} 416
 26 = {Integer@1454} 432
 27 = {Integer@1455} 448
 28 = {Integer@1456} 464
 29 = {Integer@1457} 480
 30 = {Integer@1458} 496
 31 = {Integer@1459} 512
 32 = {Integer@1460} 1024
 33 = {Integer@1461} 2048
 34 = {Integer@1462} 4096
 35 = {Integer@1463} 8192
 36 = {Integer@1464} 16384
 37 = {Integer@1465} 32768
 38 = {Integer@1466} 65536
 39 = {Integer@1467} 131072
 40 = {Integer@1468} 262144
 41 = {Integer@1469} 524288
 42 = {Integer@1470} 1048576
 43 = {Integer@1471} 2097152
 44 = {Integer@1472} 4194304
 45 = {Integer@1473} 8388608
 46 = {Integer@1474} 16777216
 47 = {Integer@1475} 33554432
 48 = {Integer@1476} 67108864
 49 = {Integer@1477} 134217728
 50 = {Integer@1478} 268435456
 51 = {Integer@1479} 536870912
 52 = {Integer@1480} 1073741824
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="自适应扩容缩容分析" tabindex="-1"><a class="header-anchor" href="#自适应扩容缩容分析" aria-hidden="true">#</a> 自适应扩容缩容分析</h3><p><strong>扩容</strong>：默认给 ByteBuf 分配的大小是 2048，在 SIZE_TABLE 索引表中的位置是 33。当某次读循环读的数据或者总读取的数据大于 2048，那么就会调整下一次分配的 ByteBuf 的大小了。使用扩容增量 4 （INDEX_INCREMENT）来扩容。</p><p>举例：当前是 2048，在索引表的位置是 33，扩容后就是 33 + 4 = 37，也就是对应 32768 了。</p><p><strong>缩容</strong>：当某次读循环总读取的数据小于 2048，假如连续两次小于 2048，那么就会调整下一次分配的 ByteBuf 的大小了。使用缩容减量 1（INDEX_DECREMENT）来缩容。</p><p>举例：当前是 2048，在索引表的位置是 33，缩容后就是 33 - 1 = 32，也就是对应 1024 了。</p><blockquote><p><strong>注意：只需要读取数据的大小大于当前分配的大小 1 次，就会立即扩容。而缩容比较谨慎，需要连续 2 次小于才去进行缩容。</strong></p></blockquote><p>下面看下具体的代码 HandleImpl#record</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 记录，根据这次真实读取的数据大小，进行下一次读取接收缓冲区的大小伸缩
 * <span class="token keyword">@param</span> <span class="token parameter">actualReadBytes</span> 真实读取的数据大小
 */</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">record</span><span class="token punctuation">(</span><span class="token keyword">int</span> actualReadBytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 连续两次小，才会进行缩减</span>
    <span class="token comment">// 索引减量 INDEX_DECREMENT 为 1</span>
    <span class="token comment">// 条件: 实际读取的字节数 &lt;= index - INDEX_DECREMENT 位置的大小</span>
    <span class="token comment">// 说明需要缩小</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>actualReadBytes <span class="token operator">&lt;=</span> <span class="token constant">SIZE_TABLE</span><span class="token punctuation">[</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token constant">INDEX_DECREMENT</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>decreaseNow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 减少，索引-1，不小于最小索引</span>
            index <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token constant">INDEX_DECREMENT</span><span class="token punctuation">,</span> minIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 赋值下一次分配的缓冲区大小</span>
            nextReceiveBufferSize <span class="token operator">=</span> <span class="token constant">SIZE_TABLE</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
            decreaseNow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 第一次设置成true</span>
            decreaseNow <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// INDEX_INCREMENT 4</span>
    <span class="token comment">// 条件：实际读取的字节数 &gt;= 预测的大小，则需要扩容</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>actualReadBytes <span class="token operator">&gt;=</span> nextReceiveBufferSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        index <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token constant">INDEX_INCREMENT</span><span class="token punctuation">,</span> maxIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        nextReceiveBufferSize <span class="token operator">=</span> <span class="token constant">SIZE_TABLE</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
        decreaseNow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个代码的流程就是前面描述的扩容和缩容的逻辑，其中 decreaseNow 字段就是控制需要连续两次小于才去缩容的。</p></div><!----><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: guosgbin@163.com">Dylan Kwok</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a href="/Netty_source/15-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86READ%E4%BA%8B%E4%BB%B6%E6%A6%82%E8%BF%B0.html" class="nav-link prev" aria-label="15-客户端处理READ事件概述"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->15-客户端处理READ事件概述</div></a><a href="/Netty_source/17-Netty%E7%AE%A1%E9%81%93%E6%9C%BA%E5%88%B6.html" class="nav-link next" aria-label="17-Netty管道机制"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">17-Netty管道机制<!----></div></a></nav><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-c12a9a30.js" defer></script>
  </body>
</html>
