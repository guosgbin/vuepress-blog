import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as a,f as l}from"./app-341a7728.js";const i="/assets/image-20240228172223249-42445aaf.png",s="/assets/image-20240228172250626-a58802fa.png",r="/assets/image-20240228172320233-efad1071.png",d="/assets/image-20240228172340604-b2383b2f.png",n={},o=l(`<table><thead><tr><th>版本</th><th>内容</th><th>时间</th></tr></thead><tbody><tr><td>V1</td><td>新建</td><td>2023年03月28日15:29:22</td></tr></tbody></table><h2 id="现状" tabindex="-1"><a class="header-anchor" href="#现状" aria-hidden="true">#</a> 现状</h2><p>期望将服务器从 16 核 32G 内存降到 8 核 16G。</p><p>JVM 的参数如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>java -Xms8g -Xmx8g -Xmn2g -Xss900k -XX:+ExplicitGCInvokesConcurrent -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=70 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=5 -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/logs/bak -Xloggc:/data/logs/gc.log.20230327_074744 -Djava.net.preferIPv4Stack=true ....省略....
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="对照" tabindex="-1"><a class="header-anchor" href="#对照" aria-hidden="true">#</a> 对照</h2><p>将一台服务器降为 8 核 16G 后，和 16 核 32G 的服务器的对照数据如下：</p><table><thead><tr><th style="text-align:left;"></th><th style="text-align:left;">16核32G内存</th><th style="text-align:left;">8核16G内存</th></tr></thead><tbody><tr><td style="text-align:left;">gc总停顿时间</td><td style="text-align:left;">总暂停时间12分钟</td><td style="text-align:left;">总暂停时间16分钟</td></tr><tr><td style="text-align:left;">内存分配</td><td style="text-align:left;"><img src="`+i+'" alt="image-20240228172223249" style="zoom:50%;"></td><td style="text-align:left;"><img src="'+s+'" alt="image-20240228172250626" style="zoom:50%;"></td></tr><tr><td style="text-align:left;">垃圾回收停顿时间</td><td style="text-align:left;"><img src="'+r+'" alt="image-20240228172320233" style="zoom:40%;"></td><td style="text-align:left;"><img src="'+d+'" alt="image-20240228172340604" style="zoom:50%;"></td></tr></tbody></table><p>结果对比</p><ol><li>根据配置 ParNew 回收器是 serial 的多线程版，可以充分利用 cpu 资源，减少回收时间；</li><li>因为是多线程同时执行，所以 cpu 核数，对垃圾回收有一定影响，降低 cpu 配置会导致回收时间延长；</li></ol><h2 id="优化策略" tabindex="-1"><a class="header-anchor" href="#优化策略" aria-hidden="true">#</a> 优化策略</h2><h3 id="确定目标" tabindex="-1"><a class="header-anchor" href="#确定目标" aria-hidden="true">#</a> 确定目标</h3><p>低延迟：系统要求在 500ms 内必须响应请求。</p><h3 id="分析" tabindex="-1"><a class="header-anchor" href="#分析" aria-hidden="true">#</a> 分析</h3><ol><li>gc 停顿时间 100~200ms 增加了 3644 次，服务的 qps 按照 1500/s 来算， gc 回收时停顿时间 100ms 到 200ms 大概影响 200 个请求（1500 * 0.15 = 200，这个应该按照平均响应时间算），计算影响请求数：200*3644 = 728800；</li><li>现在高峰期，大概每 3 秒一次 gc，按照每个接口响应时间 500ms 算，500ms 过后这个请求涉及的对象都可以被回收，3 秒内存在大量可回收对象</li></ol><h3 id="解决思路" tabindex="-1"><a class="header-anchor" href="#解决思路" aria-hidden="true">#</a> 解决思路</h3><ol><li>垃圾回收器，每秒回收 2g 内存，肯定比回收 1g 内存的耗时长，为了达到请求的低延迟效果，可以将堆内存分配调小，让每次回收的垃圾小一点，充分利用 cpu 资源；</li><li>按照 3 秒内一次 Minor 回收计算，3 秒大概 2048M 数据，如果调整成 1 秒一次垃圾回收大概需要年轻代 700M 内存，尝试将新生代改为 1G；</li></ol>',17),c=[o];function h(g,m){return e(),a("div",null,c)}const f=t(n,[["render",h],["__file","002-服务器CPU配置降低GC分析.html.vue"]]);export{f as default};
