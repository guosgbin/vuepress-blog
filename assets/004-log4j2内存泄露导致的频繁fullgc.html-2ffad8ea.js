import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as r,f as i}from"./app-341a7728.js";const t="/assets/image-20240301122232905-de489138.png",s="/assets/image-20240301122412468-394a1712.png",l="/assets/image-20240301142204610-807f09fe.png",o="/assets/image-20240301142914193-651434f9.png",g="/assets/image-20240301142815763-bd4b85bb.png",n="/assets/image-20240301143518060-4f9ba2fc.png",d="/assets/image-20240301153345137-f4b84d39.png",c="/assets/image-20240301154038886-3f5bd26a.png",p="/assets/image-20240301154444481-4dec8b38.png",h={},m=i('<h2 id="现象" tabindex="-1"><a class="header-anchor" href="#现象" aria-hidden="true">#</a> 现象</h2><p>线上服务突然发生频繁的 Full GC，并且每次 Full GC 后只回收一点点内存，老年代的内存使用率不降。</p><ul><li>频繁发生 Full GC 👇🏻</li></ul><img src="'+t+'" alt="image-20240301122232905" style="zoom:100%;"><ul><li>每次 Full GC 老年代只回收了一点点内存 👇🏻</li></ul><img src="'+s+'" alt="image-20240301122412468" style="zoom:100%;"><h2 id="排查方向" tabindex="-1"><a class="header-anchor" href="#排查方向" aria-hidden="true">#</a> 排查方向</h2><p>第一时间下载 dump 的 prof 文件，并对将该服务器的流量切走。</p><h2 id="问题排查和分析" tabindex="-1"><a class="header-anchor" href="#问题排查和分析" aria-hidden="true">#</a> 问题排查和分析</h2><h3 id="定位业务代码" tabindex="-1"><a class="header-anchor" href="#定位业务代码" aria-hidden="true">#</a> 定位业务代码</h3><p>visualVm 发现大量 char[]。按大小排序，前面部分基本都是存储的 log 日志，大小都好几兆，怀疑是打了大日志有关，排查相关业务，关闭了一些不合理的日志。</p><img src="'+l+'" alt="image-20240301142204610" style="zoom:100%;"><p>将其中一个char[] 数组的内容拿出来看一下：</p><img src="'+o+'" alt="image-20240301142914193"><p>对应的代码如下：</p><img src="'+g+'" alt="image-20240301142815763"><p>从代码中看到，这条日志并不长，为啥这个 char[] 却好几m，而且 unansweredCnt:0 后面的日志明显跟前面的接不上, 随便找了其他的char[] 也有这种情况。</p><h3 id="分析引用链路" tabindex="-1"><a class="header-anchor" href="#分析引用链路" aria-hidden="true">#</a> 分析引用链路</h3><p>通过 references，分析引用链路</p><img src="'+n+'" alt="image-20240301143518060"><p>发现日志最终缓存到 StringBuilder，而这个 StringBuilder 存储到了线程的 ThreadLocal 里面去了。</p><p>搜索 Log4j2 在什么地方使用了 StringBuilder，排查发现 org.apache.logging.log4j.message.ParameterizedMessage 这个类中有一个复用 StringBuilder 的代码，线上使用 log4j-api 的版本是 2.6.1</p><img src="'+d+'" alt="image-20240301153345137"><p>这段代码中 Log4j2 引用了一个 ThreadLocal 中的 StringBuilder，这样复用 StringBuilder 可以大幅提高日志输出效率，但是这段代码 buffer.setLength(0)，这个操作只会将 StringBuilder 的写入重置为从 0 开始写入，但不会回收 StringBuilder 已经占用的内存，由于当前的 ThreadLocal 是 tomcat 的线程池里的线程，线程一般不会销毁，所以 ThreadLocal 就基本没啥可能会被释放，导致StringBuilder 也不会被回收。这个 StringBuilder 的内存只会增加不会减少，由此导致内存泄漏。</p><h2 id="问题解决" tabindex="-1"><a class="header-anchor" href="#问题解决" aria-hidden="true">#</a> 问题解决</h2><p>查看官网发现，这是一个 bug，具体地址如下：https://issues.apache.org/jira/browse/LOG4J2-1858</p><p>然后 log4j 官方在 2.9.0 版本修复了这个 bug， release note 地址：https://logging.apache.org/log4j/2.x/release-notes.html</p><img src="'+c+'" alt="image-20240301154038886" style="zoom:100%;"><p>我们决定升级到 2.12.1</p><img src="'+p+'" alt="image-20240301154444481" style="zoom:100%;"><p>可以看到新版本中增加一个操作trimToMaxSize，当 buffer 的长度大于某一直时会触发 StringBuilder 的 trimToSize 操作，这个方法会回收 StringBuilder 的缓存。</p><h2 id="结论" tabindex="-1"><a class="header-anchor" href="#结论" aria-hidden="true">#</a> 结论</h2><p>1、某些业务打印了大量大日志，导致每个线程 threadLocal 的 StringBuilder 占用内存增大，最大达到 5m；</p><p>2、目前系统常驻线程稳定在 6000~7000，最终日志 buffer 就会占到 3~4g；</p><p>3、规范日志输出，避免磁盘、内存浪费；</p><p>4、升级 log4j2 版本，从 2.6.1 到 2.12.1；</p>',36),u=[m];function _(f,b){return a(),r("div",null,u)}const x=e(h,[["render",_],["__file","004-log4j2内存泄露导致的频繁fullgc.html.vue"]]);export{x as default};
