import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,b as e}from"./app-7fdd4541.js";const t="/assets/客户端处理READ事件-ca048891.png",p={},c=e(`<table><thead><tr><th>版本</th><th>内容</th><th>时间</th></tr></thead><tbody><tr><td>V1</td><td>新建</td><td>2022年03月10日09:04:53</td></tr><tr><td>V2</td><td>重构</td><td>2023年05月25日21:48:30</td></tr></tbody></table><h2 id="回顾" tabindex="-1"><a class="header-anchor" href="#回顾" aria-hidden="true">#</a> 回顾</h2><h3 id="nioeventloop-处理-i-o-事件入口" tabindex="-1"><a class="header-anchor" href="#nioeventloop-处理-i-o-事件入口" aria-hidden="true">#</a> NioEventLoop 处理 I/O 事件入口</h3><p>在上一篇文章中，主要分析了服务端处理客户端的连接，也就是处理 ACCEPT 事件。本篇主要分析客户端读取数据的逻辑，也就是处理 READ 事件。在 NioEventLoop#run 方法中，循环处理异步任务和 I/O 事件。NioEventLoop#run 方法伪代码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// epoll bug的一个特征计数变量</span>
    <span class="token keyword">int</span> selectCnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// ....... 1. 检查是否有任务和就绪的I/O事件需要处理 ......</span>
            <span class="token comment">// ....... 2. 处理任务和就绪I/O事件的 ......</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CancelledKeyException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// ....... 省略异常处理 ......</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">handleLoopException</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                <span class="token comment">// ....... 3. 检查 Reactor 线程的状态，必要时走关闭流程 ......</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">throw</span> e<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">handleLoopException</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当有 I/O 事件就绪后，就会调用 NioEventLoop#processSelectedKeys() 方法处理 I/O 事件，最终会调用到 NioEventLoop#processSelectedKey(SelectionKey, AbstractNioChannel) 方法，伪代码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 处理通道 AbstractNioChannel 的IO事件
 */</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processSelectedKey</span><span class="token punctuation">(</span><span class="token class-name">SelectionKey</span> k<span class="token punctuation">,</span> <span class="token class-name">AbstractNioChannel</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// NioServerSocketChannel -&gt; NioMessageUnsafe</span>
    <span class="token comment">// NioSocketChannel -&gt; NioByteUnsafe</span>
    <span class="token keyword">final</span> <span class="token class-name">AbstractNioChannel<span class="token punctuation">.</span>NioUnsafe</span> unsafe <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
   <span class="token comment">// ...... 省略一些校验 ......</span>

    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取 IO 事件类型</span>
        <span class="token keyword">int</span> readyOps <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">readyOps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>readyOps <span class="token operator">&amp;</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_CONNECT</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 处理 OP_CONNECT 事件</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>readyOps <span class="token operator">&amp;</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_WRITE</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 处理 OP_WRITE 事件</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span>
        <span class="token comment">// to a spin loop</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>readyOps <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_READ</span> <span class="token operator">|</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_ACCEPT</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> readyOps <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 处理 OP_READ、OP_ACCEPT 事件，和可能的 JDK NIO bug</span>
            unsafe<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CancelledKeyException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// key失效则close这个channel</span>
        unsafe<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">voidPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本篇文章分析的入口就是 <code>unsafe.read()</code>，处理 READ 事件。因为分析的是客户端处理 READ 事件，所以此处的 Unsafe 实例是 AbstractNioByteChannel.NioByteUnsafe。</p><h3 id="niosocketchannel-的创建流程" tabindex="-1"><a class="header-anchor" href="#niosocketchannel-的创建流程" aria-hidden="true">#</a> NioSocketChannel 的创建流程</h3><p>NioSocketChannel 的构造方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">NioSocketChannel</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> parent<span class="token punctuation">,</span> <span class="token class-name">SocketChannel</span> socket<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> socket<span class="token punctuation">)</span><span class="token punctuation">;</span>
    config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioSocketChannelConfig</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> socket<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>先是 super 调用父类的构造方法，调用父类的构造方法主要做的事情如下：</p><ol><li>创建 UnSafe 实例，对于客户端 NioSocketChannel 来说就是 NioByteUnSafe 实例；</li><li>创建并初始化客户端的 Pipeline；</li><li>赋值感兴趣的事件 READ；</li><li>将 JDK 的客户端 Channel 设置为非阻塞模式；</li></ol><p>这部分之前在分析启动流程时说过，这里主要分析 NioSocketChannelConfig 的创建流程。</p><p>NioSocketChannelConfig 的构造方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">NioSocketChannelConfig</span><span class="token punctuation">(</span><span class="token class-name">NioSocketChannel</span> channel<span class="token punctuation">,</span> <span class="token class-name">Socket</span> javaSocket<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> javaSocket<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">calculateMaxBytesPerGatheringWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>calculateMaxBytesPerGatheringWrite 不知道干嘛的，先留一个坑 TODO-KWOK</p><p>super 调用父类的构造方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">DefaultSocketChannelConfig</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> channel<span class="token punctuation">,</span> <span class="token class-name">Socket</span> javaSocket<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>javaSocket <span class="token operator">=</span> <span class="token class-name">ObjectUtil</span><span class="token punctuation">.</span><span class="token function">checkNotNull</span><span class="token punctuation">(</span>javaSocket<span class="token punctuation">,</span> <span class="token string">&quot;javaSocket&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Enable TCP_NODELAY by default if possible.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">PlatformDependent</span><span class="token punctuation">.</span><span class="token function">canEnableTcpNoDelayByDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token function">setTcpNoDelay</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// Ignore.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个构造方法主要做的事情就是设置了 TCP 的 TCP_NODELAY 属性。</p><p>继续 super 调用父类的构造方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">DefaultChannelConfig</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建 DefaultChannelConfig 对象，传入默认的 AdaptiveRecvByteBufAllocator</span>
    <span class="token keyword">this</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">AdaptiveRecvByteBufAllocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>又看到 AdaptiveRecvByteBufAllocator 对象了，它的作用就是控制读循环次数和预测下次读数据的 ByteBuf 的大小。后面的构造方法重载就不分析了，主要就是设置默认的读循环次数为 16。</p><p>DefaultChannelConfig#setRecvByteBufAllocator(RecvByteBufAllocator, ChannelMetadata)</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setRecvByteBufAllocator</span><span class="token punctuation">(</span><span class="token class-name">RecvByteBufAllocator</span> allocator<span class="token punctuation">,</span> <span class="token class-name">ChannelMetadata</span> metadata<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>allocator<span class="token punctuation">,</span> <span class="token string">&quot;allocator&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>metadata<span class="token punctuation">,</span> <span class="token string">&quot;metadata&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>allocator <span class="token keyword">instanceof</span> <span class="token class-name">MaxMessagesRecvByteBufAllocator</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 设置 MaxMessagesRecvByteBufAllocator 的 maxMessagesPerRead 的默认值 16</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">MaxMessagesRecvByteBufAllocator</span><span class="token punctuation">)</span> allocator<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMessagesPerRead</span><span class="token punctuation">(</span>metadata<span class="token punctuation">.</span><span class="token function">defaultMaxMessagesPerRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">setRecvByteBufAllocator</span><span class="token punctuation">(</span>allocator<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>小结一下 NioSocketChannel 创建过程中做了什么事情：</p><ol><li>创建 UnSafe 实例，对于客户端 NioSocketChannel 来说就是 NioByteUnSafe 实例；</li><li>创建并初始化客户端的 Pipeline；</li><li>赋值感兴趣的事件 READ；</li><li>将 JDK 的客户端 Channel 设置为非阻塞模式；</li><li>设置了 TCP 的 TCP_NODELAY 属性；</li><li>创建 AdaptiveRecvByteBufAllocator，并赋值默认读循环 16 次；</li></ol><h2 id="niobyteunsafe-read-方法整体流程" tabindex="-1"><a class="header-anchor" href="#niobyteunsafe-read-方法整体流程" aria-hidden="true">#</a> NioByteUnsafe#read 方法整体流程</h2><h3 id="整体流程图" tabindex="-1"><a class="header-anchor" href="#整体流程图" aria-hidden="true">#</a> 整体流程图</h3><p><img src="`+t+`" alt="客户端处理READ事件"></p><h3 id="客户端处理-read-事件流程概述" tabindex="-1"><a class="header-anchor" href="#客户端处理-read-事件流程概述" aria-hidden="true">#</a> 客户端处理 READ 事件流程概述</h3><p>NioByteUnsafe#read</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token doc-comment comment">/**
     * 1 通过 doReadBytes(byteBuf) 方法,从底层NIO 通道中读取数据到输入缓冲区ByteBuf 中。
     * 2 通过 pipeline.fireChannelRead(...) 方法，发送ChannelRead读取事件。
     * 3 通过 allocHandle.continueReading() 判断是否需要继续读取。
     * 4 这次读取完成，调用 pipeline.fireChannelReadComplete() 方法，发送 ChannelReadComplete 读取完成事件。
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取客户端的配置Config对象</span>
        <span class="token keyword">final</span> <span class="token class-name">ChannelConfig</span> config <span class="token operator">=</span> <span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldBreakReadReady</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">clearReadPending</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 获取客户端的pipeline对象</span>
        <span class="token keyword">final</span> <span class="token class-name">ChannelPipeline</span> pipeline <span class="token operator">=</span> <span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取缓冲区分配器，默认是PooledByteBufAllocator</span>
        <span class="token keyword">final</span> <span class="token class-name">ByteBufAllocator</span> allocator <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getAllocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 控制读循环和预测下次创建的bytebuf的容量大小</span>
        <span class="token keyword">final</span> <span class="token class-name">RecvByteBufAllocator<span class="token punctuation">.</span>Handle</span> allocHandle <span class="token operator">=</span> <span class="token function">recvBufAllocHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 清空上一次读取的字节数，每次读取时搜重新计算</span>
        allocHandle<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">ByteBuf</span> byteBuf <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> close <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">do</span> <span class="token punctuation">{</span>
                <span class="token comment">// 参数是缓冲区内存分配器</span>
                <span class="token comment">// allocHandle只是预测分配多大的内存\`</span>
                byteBuf <span class="token operator">=</span> allocHandle<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>allocator<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// doReadBytes(byteBuf) 读取当前Socket读缓冲区的数据到byteBuf对象中</span>
                allocHandle<span class="token punctuation">.</span><span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token function">doReadBytes</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// channel底层Socket读缓冲区 已经完全读取完毕会返回0，或者是Channel对端关闭了 返回-1</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>allocHandle<span class="token punctuation">.</span><span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// nothing was read. release the buffer.</span>
                    byteBuf<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    byteBuf <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    close <span class="token operator">=</span> allocHandle<span class="token punctuation">.</span><span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>close<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">// There is nothing left to read as we received an EOF.</span>
                        <span class="token comment">// 此时是 -1</span>
                        readPending <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token comment">// 更新缓冲区预测分配器 读取消息数量</span>
                allocHandle<span class="token punctuation">.</span><span class="token function">incMessagesRead</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                readPending <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token comment">// 因为 TCP 有粘包问题</span>
                <span class="token comment">// 向客户端pipeline发送channelRead事件，该pipeline实现了channelRead的Handler就可以进行业务处理了</span>
                pipeline<span class="token punctuation">.</span><span class="token function">fireChannelRead</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
                byteBuf <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>allocHandle<span class="token punctuation">.</span><span class="token function">continueReading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 读取操作完毕</span>
            allocHandle<span class="token punctuation">.</span><span class="token function">readComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 触发管道的fireChannelReadComplete事件</span>
            pipeline<span class="token punctuation">.</span><span class="token function">fireChannelReadComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>close<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果连接对端关闭了，则关闭读操作</span>
                <span class="token function">closeOnRead</span><span class="token punctuation">(</span>pipeline<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">handleReadException</span><span class="token punctuation">(</span>pipeline<span class="token punctuation">,</span> byteBuf<span class="token punctuation">,</span> t<span class="token punctuation">,</span> close<span class="token punctuation">,</span> allocHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token comment">// 假如读操作完毕，且没有配置自动读，则从选择的Key兴趣集中移除读操作事件</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>readPending <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>config<span class="token punctuation">.</span><span class="token function">isAutoRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">removeReadOp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>客户端处理 READ 事件的主要流程如下：</p><ol><li>处理 TCP 半关闭（Half-Close）；</li><li>获取缓存区分配器 ByteBufAllocator 和控制读循环和预测缓存大小的分配器 RecvByteBufAllocator.Handle；</li><li><code>allocHandle.reset(config)</code>，循环前重置一些数据，如清空上一次读取的字节数；</li><li>do...while... 循环读取数据；</li><li><code>allocHandle.allocate(allocator)</code> 预测当前循环需要使用多大的 ByteBuf；</li><li>通过 <code>doReadBytes(byteBuf)</code> 方法，从底层 NIO 通道中读取数据到输入缓冲区 ByteBuf 中，如果所有数据都读取完毕，或者对端关闭连接了，就退出循环；</li><li><code>allocHandle.incMessagesRead(1)</code> 更新缓冲区预测分配器，增加读循环次数；</li><li><code> pipeline.fireChannelRead(byteBuf)</code>，向客户端 pipeline 发送 channelRead 事件；</li><li>while 循环的条件 <code>allocHandle.continueReading()</code>，判断是否允许继续循环读数据；</li><li>处理自适应扩容缩容；</li><li>当前次数数据读取完毕或者循环读到了上限 16 次（可能 16 次都没读完），<code>pipeline.fireChannelReadComplete()</code> 向客户端管道发送 channelReadComplete 事件；</li></ol><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>本篇只是分析了客户端处理 READ 事件的主要流程，详细步骤并没有分析。其实就是一个 do...while... 循环读取数据，每次读取到数据就向客户端 Pipeline 传递一个 channelRead 事件，当数据读取完毕或者到了读循环上限后，就会退出 while 循环，并且传递一个 channelReadComplete 事件。</p><p>可以看到关键点就是 AdaptiveRecvByteBufAllocator 对象了，会在下一篇详细分析这个对象的作用。</p>`,38),o=[c];function l(i,u){return s(),a("div",null,o)}const r=n(p,[["render",l],["__file","15-客户端处理READ事件概述.html.vue"]]);export{r as default};
