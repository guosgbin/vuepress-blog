import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,f as e}from"./app-e8360c54.js";const t="/assets/Write事件的传播-eb1f8a94.png",p="/assets/Netty出站缓冲区链表增加元素-fcff4ff0.png",o="/assets/Netty出站缓冲区链表移除元素-a97e70e1.png",c="/assets/Netty出站缓冲区链表移除元素特殊-8737a44e.png",i="/assets/image-20230603120237433-7a8e6f28.png",l="/assets/image-20230603120414311-a4a7429c.png",u="/assets/NioSocketChannel的doWrite的流程图-8fe760ea.png",r="/assets/ChannelOutboundBuffer的removeBytes方法-9a4487a5.png",k={},d=e(`<table><thead><tr><th>版本</th><th>内容</th><th>时间</th></tr></thead><tbody><tr><td>V1</td><td>新建</td><td>2022年03月21日01:00:11</td></tr><tr><td>V2</td><td>重构</td><td>2023年06月03日13:51:13</td></tr></tbody></table><h2 id="引入" tabindex="-1"><a class="header-anchor" href="#引入" aria-hidden="true">#</a> 引入</h2><p>为了提高网络的吞吐量，在调用 write 方法时，数据并没有直接写到底层 Socket 中，而是被写到了 Netty 的出站缓冲区 ChannelOutboundBuffer 中。</p><p>本文主要分析 Netty 的写操作的流程，主要分为一下几部分。</p><ol><li>Netty 的 write 事件的传播；</li><li>Netty 的 write 事件的处理；</li><li>出站缓冲区 ChannelOutboundBuffer 原理；</li><li>Netty 的 flush 事件的处理；</li><li>Netty 的 writeAndFlush 方法的逻辑；</li></ol><h2 id="netty-的-write-事件的入口" tabindex="-1"><a class="header-anchor" href="#netty-的-write-事件的入口" aria-hidden="true">#</a> Netty 的 write 事件的入口</h2><p>在 ChannelHandler 处理器中有两个地方可以触发 write 事件：</p><ol><li>调用 ChannelHandlerContext 的 write 方法。该方式会直接沿着当前 ChannelHandlerContext 向 HeadContext 传递 write 事件；</li><li>调用 ChannelHandlerContext 所属的 Channel 的 write 方法。该方式会从 TailContext 向 HeadContext 传递 write 事件；</li></ol><p>以第二种方式 AbstractChannel#write(Object) 为例来分析：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">ChannelFuture</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">Object</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> pipeline<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>就是调用管道的 DefaultChannelPipeline#write(Object) 方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">ChannelFuture</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">Object</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> tail<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用 TailContext 的 write 方法，因为 TailContext 就是 AbstractChannelHandlerContext 的实例，所以需要看 AbstractChannelHandlerContext 的 write 方法</p><h2 id="netty-的-write-事件的传播" tabindex="-1"><a class="header-anchor" href="#netty-的-write-事件的传播" aria-hidden="true">#</a> Netty 的 write 事件的传播</h2><p><img src="`+t+`" alt="Write事件的传播"></p><h3 id="查找上一个-channelhandler" tabindex="-1"><a class="header-anchor" href="#查找上一个-channelhandler" aria-hidden="true">#</a> 查找上一个 ChannelHandler</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">ChannelFuture</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">Object</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">write</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token function">newPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">ChannelFuture</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Object</span> msg<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 写入消息 不刷新</span>
    <span class="token function">write</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> promise<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两个 write 方法就是创建一个 ChannelFuture 对象，传入到重载的 write 中，并将 ChannelFuture 对象返回给调用者，调用者可以监听这个 ChannelFuture，就能知道 write 操作是正常还是异常了。</p><p>接下来看核心的 AbstractChannelHandlerContext#write(Object, boolean, ChannelPromise) 方法了</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">Object</span> msg<span class="token punctuation">,</span> <span class="token keyword">boolean</span> flush<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...... 省略参数校验......</span>

    <span class="token comment">// 找出上一个出站的ctx对象</span>
    <span class="token comment">// flush = true 表示channelHandler中调用的是writeAndFlush方法，这里需要找到pipeline中覆盖write或者flush方法的channelHandler</span>
    <span class="token comment">// flush = false 表示调用的是write方法，只需要找到pipeline中覆盖write方法的channelHandler</span>
    <span class="token keyword">final</span> <span class="token class-name">AbstractChannelHandlerContext</span> next <span class="token operator">=</span> <span class="token function">findContextOutbound</span><span class="token punctuation">(</span>flush <span class="token operator">?</span>
            <span class="token punctuation">(</span><span class="token constant">MASK_WRITE</span> <span class="token operator">|</span> <span class="token constant">MASK_FLUSH</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token constant">MASK_WRITE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 添加附加信息，在内存泄露的时候，可以获取到这个附加信息</span>
    <span class="token keyword">final</span> <span class="token class-name">Object</span> m <span class="token operator">=</span> pipeline<span class="token punctuation">.</span><span class="token function">touch</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">EventExecutor</span> executor <span class="token operator">=</span> next<span class="token punctuation">.</span><span class="token function">executor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>executor<span class="token punctuation">.</span><span class="token function">inEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>flush<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果需要刷新，就调用 invokeWriteAndFlush 方法</span>
            next<span class="token punctuation">.</span><span class="token function">invokeWriteAndFlush</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果不需要刷新，就调用 invokeWrite 方法</span>
            next<span class="token punctuation">.</span><span class="token function">invokeWrite</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将写操作封装成一个 WriteTask，是 Runnable 子类。</span>
        <span class="token keyword">final</span> <span class="token class-name">WriteTask</span> task <span class="token operator">=</span> <span class="token class-name">WriteTask</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> m<span class="token punctuation">,</span> promise<span class="token punctuation">,</span> flush<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">safeExecute</span><span class="token punctuation">(</span>executor<span class="token punctuation">,</span> task<span class="token punctuation">,</span> promise<span class="token punctuation">,</span> m<span class="token punctuation">,</span> <span class="token operator">!</span>flush<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// See https://github.com/netty/netty/issues/8343.</span>
            task<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单分析下这个方法的流程：</p><ul><li>首先使用 <code>findContextOutbound(flush ? (MASK_WRITE | MASK_FLUSH) : MASK_WRITE)</code> 方法，找到上一个实现了 write 或者 『write 和 flush』的 ChannelHandler。（findContextOutbound 方法在管道那一篇中详细分析过，是事件传播的核心方法）；</li><li><code>pipeline.touch(msg, next)</code> 是检测资源泄漏用的，后面单独出一篇文章详细分析；</li><li>最后根据当前执行代码的线程是否是下一个 ChannelHandler 绑定的线程，做不同的处理逻辑； <ul><li>是：根据 flush 参数决定调用对应的方法，invokeWriteAndFlush 或者 invokeWrite 方法；</li><li>不是：需要保证下一个 ChannelHandler 执行的线程是它绑定的线程，所以要封装一个 WriteTask 任务，添加到对应线程的任务队列中；</li></ul></li></ul><h3 id="当前线程是下个出站处理器绑定的线程" tabindex="-1"><a class="header-anchor" href="#当前线程是下个出站处理器绑定的线程" aria-hidden="true">#</a> 当前线程是下个出站处理器绑定的线程</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Object</span> m <span class="token operator">=</span> pipeline<span class="token punctuation">.</span><span class="token function">touch</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">EventExecutor</span> executor <span class="token operator">=</span> next<span class="token punctuation">.</span><span class="token function">executor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>executor<span class="token punctuation">.</span><span class="token function">inEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>flush<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果需要刷新，就调用 invokeWriteAndFlush 方法</span>
        next<span class="token punctuation">.</span><span class="token function">invokeWriteAndFlush</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果不需要刷新，就调用 invokeWrite 方法</span>
        next<span class="token punctuation">.</span><span class="token function">invokeWrite</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    	<span class="token comment">// ...... 省略其他分支 ......</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果当前线程就是下个出站处理器绑定的线程，那么直接调用下个 ChannelHandlerContext 的对应方法，以 AbstractChannelHandlerContext#invokeWrite 为例，</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">invokeWrite</span><span class="token punctuation">(</span><span class="token class-name">Object</span> msg<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">invokeHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">invokeWrite0</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">write</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeWrite0</span><span class="token punctuation">(</span><span class="token class-name">Object</span> msg<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ChannelOutboundHandler</span><span class="token punctuation">)</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">notifyOutboundHandlerException</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到就是调用下一个 ChannelHandler 实现的 write 方法，假如执行发生异常后，这里会通知对应的 ChannelFuture。</p><h3 id="当前线程不是下个出站处理器绑定的线程" tabindex="-1"><a class="header-anchor" href="#当前线程不是下个出站处理器绑定的线程" aria-hidden="true">#</a> 当前线程不是下个出站处理器绑定的线程</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Object</span> m <span class="token operator">=</span> pipeline<span class="token punctuation">.</span><span class="token function">touch</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">EventExecutor</span> executor <span class="token operator">=</span> next<span class="token punctuation">.</span><span class="token function">executor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>executor<span class="token punctuation">.</span><span class="token function">inEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// ...... 省略其他分支 ......</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将写操作封装成一个 WriteTask，是 Runnable 子类。</span>
    <span class="token keyword">final</span> <span class="token class-name">WriteTask</span> task <span class="token operator">=</span> <span class="token class-name">WriteTask</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> m<span class="token punctuation">,</span> promise<span class="token punctuation">,</span> flush<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">safeExecute</span><span class="token punctuation">(</span>executor<span class="token punctuation">,</span> task<span class="token punctuation">,</span> promise<span class="token punctuation">,</span> m<span class="token punctuation">,</span> <span class="token operator">!</span>flush<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        task<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当当前执行代码的线程不是下个出站处理器绑定的线程，为了保证 ChannelHandler 的内的 write 方法的逻辑是它绑定的线程执行，那么就需要向它绑定的线程提交一个 WriteTask 类型的任务。</p><h4 id="writetask-对象池" tabindex="-1"><a class="header-anchor" href="#writetask-对象池" aria-hidden="true">#</a> WriteTask 对象池</h4><p>因为在 Netty 中写操作是很频繁的，如果每次写操作都创建一个 WriteTask 对象，频繁的创建和销毁对象会对 Netty 的性能有很大的影响。所以 WriteTask 内部是使用对象池技术来避免对象频繁创建和销毁。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">WriteTask</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对象池</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ObjectPool</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">WriteTask</span><span class="token punctuation">&gt;</span></span> <span class="token constant">RECYCLER</span> <span class="token operator">=</span> <span class="token class-name">ObjectPool</span><span class="token punctuation">.</span><span class="token function">newPool</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ObjectCreator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">WriteTask</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">WriteTask</span> <span class="token function">newObject</span><span class="token punctuation">(</span><span class="token class-name">Handle</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">WriteTask</span><span class="token punctuation">&gt;</span></span> handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WriteTask</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token comment">// ...... 省略其他 ......</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="writetask-的初始化" tabindex="-1"><a class="header-anchor" href="#writetask-的初始化" aria-hidden="true">#</a> WriteTask 的初始化</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token class-name">WriteTask</span> <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token class-name">AbstractChannelHandlerContext</span> ctx<span class="token punctuation">,</span>
                             <span class="token class-name">Object</span> msg<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">,</span> <span class="token keyword">boolean</span> flush<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 从对象池中获得实例</span>
    <span class="token class-name">WriteTask</span> task <span class="token operator">=</span> <span class="token constant">RECYCLER</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 初始化参数</span>
    <span class="token function">init</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> ctx<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> promise<span class="token punctuation">,</span> flush<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> task<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">WriteTask</span> task<span class="token punctuation">,</span> <span class="token class-name">AbstractChannelHandlerContext</span> ctx<span class="token punctuation">,</span>
                           <span class="token class-name">Object</span> msg<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">,</span> <span class="token keyword">boolean</span> flush<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    task<span class="token punctuation">.</span>ctx <span class="token operator">=</span> ctx<span class="token punctuation">;</span>
    task<span class="token punctuation">.</span>msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>
    task<span class="token punctuation">.</span>promise <span class="token operator">=</span> promise<span class="token punctuation">;</span>

    <span class="token comment">// 是否需要估算写入数据大小</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">ESTIMATE_TASK_SIZE_ON_SUBMIT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 估算数据大小</span>
        task<span class="token punctuation">.</span>size <span class="token operator">=</span> ctx<span class="token punctuation">.</span>pipeline<span class="token punctuation">.</span><span class="token function">estimatorHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">WRITE_TASK_OVERHEAD</span><span class="token punctuation">;</span>
        <span class="token comment">// 增加等待写入数据的大小</span>
        ctx<span class="token punctuation">.</span>pipeline<span class="token punctuation">.</span><span class="token function">incrementPendingOutboundBytes</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        task<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>flush<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将size 大小变成负数，那么就会调用 写入并刷新的方法</span>
        task<span class="token punctuation">.</span>size <span class="token operator">|=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>WriteTask 的初始化流程，先从对象池中获取一个 WriteTask 对象，然后初始化 WriteTask 的属性。</p><p>有一个布尔类型的可配置项 ESTIMATE_TASK_SIZE_ON_SUBMIT，控制是否在提交 WriteTask 任务的时候就计算 Netty 出站缓冲区的高低水位线。这里知道这个水位线就行了，后面详细分析。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 是否需要估算写入数据大小</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token constant">ESTIMATE_TASK_SIZE_ON_SUBMIT</span> <span class="token operator">=</span>
        <span class="token class-name">SystemPropertyUtil</span><span class="token punctuation">.</span><span class="token function">getBoolean</span><span class="token punctuation">(</span><span class="token string">&quot;io.netty.transport.estimateSizeOnSubmit&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如该值是 true 的话，就需要每次计算此次写入数据的大小，判断出站缓冲区的中数据是否超过高水位线，假如超过高水位线，就需要将通道 ChannelPipeline 发起unwriteable 更改事件，设置不可写。</p><p>下面一步是假如调用了 flush 的方法，就需要通过位操作将原来的 size 大小变成负数，这么做是为了区别后续 run 方法中调用不同的方法，区别调用 write 方法还是 write 和 flush 方法。</p><h4 id="writetask-的执行" tabindex="-1"><a class="header-anchor" href="#writetask-的执行" aria-hidden="true">#</a> WriteTask 的执行</h4><p>当下一个出站 ChannelHandler 的线程执行到了当前的 WriteTask 之后，就会调用 WriteTask#run 方法去执行了：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 减小等待写入数据大小</span>
        <span class="token function">decrementPendingOutboundBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 只调用写入操作</span>
            ctx<span class="token punctuation">.</span><span class="token function">invokeWrite</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 当 size &lt; 0 ,写入并刷新操作</span>
            ctx<span class="token punctuation">.</span><span class="token function">invokeWriteAndFlush</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// 回收对象</span>
        <span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 减小等待写入数据大小
 */</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">decrementPendingOutboundBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">ESTIMATE_TASK_SIZE_ON_SUBMIT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ctx<span class="token punctuation">.</span>pipeline<span class="token punctuation">.</span><span class="token function">decrementPendingOutboundBytes</span><span class="token punctuation">(</span>size <span class="token operator">&amp;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单明了，就是调用下个 ChannelHandlerContext 的对应方法，也就是 invokeWrite 和 invokeWriteAndFlush 方法了。我们前面已经分析过。另外，假如配置项 ESTIMATE_TASK_SIZE_ON_SUBMIT 是 true，因为前面累加了出站缓冲区待发送数据，这里需要减少这个累加值。</p><h3 id="headcontext-的-write-方法" tabindex="-1"><a class="header-anchor" href="#headcontext-的-write-方法" aria-hidden="true">#</a> HeadContext 的 write 方法</h3><p>因为 write 是出站事件，所以最终会调用到 HeadContext 的 write 方法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> msg<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// NioSocketChannelUnsafe</span>
    unsafe<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>紧接着调用 UnSafe 的 write 方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 1 先判断写缓冲区 outboundBuffer 是不是为 null，为空说明通道已关闭，进行失败通知。
 * 2 通过 filterOutboundMessage(msg) 方法进行数据转换，例如将 Heap 缓冲区变成 Direct 缓冲区。
 * 3 估算数据大小。
 * 4 通过 outboundBuffer.addMessage(...) 方法，将数据添加到写缓冲区 outboundBuffer 中。
 * 5 如果发送异常，记得释放数据 msg 的引用，防止内存泄露，并进行操作失败通知。
 *
 * msg 大概率是 ByteBuf 对象
 *
 * <span class="token keyword">@param</span> <span class="token parameter">msg</span>
 * <span class="token keyword">@param</span> <span class="token parameter">promise</span>
 */</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">Object</span> msg<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">assertEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">ChannelOutboundBuffer</span> outboundBuffer <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>outboundBuffer<span class="token punctuation">;</span>
    
    <span class="token comment">// ...... 省略防止资源泄漏的代码 ......</span>

    <span class="token comment">// msg数据大小</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// msg一般是ByteBuf对象，该对象根据内存归属分为Heap和Direct，如果ByteBuf类型是Heap类型的话，这里会将其转换为direct类型</span>
        msg <span class="token operator">=</span> <span class="token function">filterOutboundMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取当前消息 有效数据量大小</span>
        size <span class="token operator">=</span> pipeline<span class="token punctuation">.</span><span class="token function">estimatorHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...... 异常处理逻辑 ......</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 将ByteBuf数据加入到出站缓存区内</span>
    <span class="token comment">// 参数1：msg 一般ByteBuf对象，direct堆外内存</span>
    <span class="token comment">// 参数2：size 数据量大小</span>
    outboundBuffer<span class="token punctuation">.</span><span class="token function">addMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> size<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了提高网络的吞吐量，在调用 write 方法时，数据并没有直接写到底层 Socket 中，而是被写到了 Netty 的出站缓冲区 ChannelOutboundBuffer 中。</p><h4 id="filteroutboundmessage-方法" tabindex="-1"><a class="header-anchor" href="#filteroutboundmessage-方法" aria-hidden="true">#</a> filterOutboundMessage 方法</h4><p>AbstractNioByteChannel#filterOutboundMessage</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> <span class="token function">filterOutboundMessage</span><span class="token punctuation">(</span><span class="token class-name">Object</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token keyword">instanceof</span> <span class="token class-name">ByteBuf</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ByteBuf</span> buf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ByteBuf</span><span class="token punctuation">)</span> msg<span class="token punctuation">;</span>
        <span class="token comment">// 是堆外直接返回</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">isDirect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> msg<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 转换为direct返回</span>
        <span class="token keyword">return</span> <span class="token function">newDirectBuffer</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token keyword">instanceof</span> <span class="token class-name">FileRegion</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> msg<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span>
            <span class="token string">&quot;unsupported message type: &quot;</span> <span class="token operator">+</span> <span class="token class-name">StringUtil</span><span class="token punctuation">.</span><span class="token function">simpleClassName</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">EXPECTED_TYPES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>出站缓冲区 ChannelOutboundBuffer 只允许添加 ByteBuffer 类型以及 FileRegion 类型的数据。</p><h4 id="messagesizeestimator-handle-计算数据大小" tabindex="-1"><a class="header-anchor" href="#messagesizeestimator-handle-计算数据大小" aria-hidden="true">#</a> MessageSizeEstimator.Handle 计算数据大小</h4><p>MessageSizeEstimator 对象是在初始化 Channel 的时候，随着创建 ChannelConfig 一起创建的。以 NioSocketChannel 的创建为例，创建了一个 NioSocketChannelConfig 对象。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">NioSocketChannel</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> parent<span class="token punctuation">,</span> <span class="token class-name">SocketChannel</span> socket<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> socket<span class="token punctuation">)</span><span class="token punctuation">;</span>
    config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioSocketChannelConfig</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> socket<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而在 NioSocketChannelConfig 的父类 DefaultChannelConfig 中有个 MessageSizeEstimator 类型的属性，它的默认值就是 DefaultMessageSizeEstimator 对象。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">MessageSizeEstimator</span> <span class="token constant">DEFAULT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMessageSizeEstimator</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>DefaultMessageSizeEstimator 类</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">DefaultMessageSizeEstimator</span> <span class="token keyword">implements</span> <span class="token class-name">MessageSizeEstimator</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HandleImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Handle</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> unknownSize<span class="token punctuation">;</span>

        <span class="token keyword">private</span> <span class="token class-name">HandleImpl</span><span class="token punctuation">(</span><span class="token keyword">int</span> unknownSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>unknownSize <span class="token operator">=</span> unknownSize<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token doc-comment comment">/**
         * 计算不同类型的 数据量大小
         * <span class="token keyword">@param</span> <span class="token parameter">msg</span>       The message for which the size should be calculated
         * <span class="token keyword">@return</span>
         */</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token class-name">Object</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token keyword">instanceof</span> <span class="token class-name">ByteBuf</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ByteBuf</span><span class="token punctuation">)</span> msg<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token keyword">instanceof</span> <span class="token class-name">ByteBufHolder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ByteBufHolder</span><span class="token punctuation">)</span> msg<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token keyword">instanceof</span> <span class="token class-name">FileRegion</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> unknownSize<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">// ...... 省略其他 ......</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们看到就是调用 size 方法去计算 ByteBuffer 的大小，也就是 Buffer 中未读取的字节数 writerIndex - readerIndex。</p><p>在计算完数据大小，就调用 ChannelOutboundBuffer#addMessage 方法将 msg 添加到出站缓冲区中去了。</p><p>到这里我们知道将数据添加到出站缓冲区内就行了，具体出站缓冲区内是如何处理的后面详细分析。</p><h2 id="netty-的-flush-事件的传播" tabindex="-1"><a class="header-anchor" href="#netty-的-flush-事件的传播" aria-hidden="true">#</a> Netty 的 flush 事件的传播</h2><p>Netty 的 flush 事件的传播，其实它和 write 事件的传播的流程基本一致，因为都是出站事件。这里简要说明下：</p><p>（1）首先会调用 ChannelHandlerContext 的 flush 方法，这里就是通过 <code>findContextOutbound(MASK_FLUSH)</code> 方法找到上一个实现了 flush 方法的出站 ChannelHandler。</p><p>然后判断当前执行的线程是否是上一个 ChannelHandlerContext 绑定的线程。如果是就直接调用它的 invokeFlush 方法；如果不是就提交一个刷新任务到上一个 ChannelHandlerContext 绑定的线程的任务队列里去；</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">ChannelHandlerContext</span> <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">AbstractChannelHandlerContext</span> next <span class="token operator">=</span> <span class="token function">findContextOutbound</span><span class="token punctuation">(</span><span class="token constant">MASK_FLUSH</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">EventExecutor</span> executor <span class="token operator">=</span> next<span class="token punctuation">.</span><span class="token function">executor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>executor<span class="token punctuation">.</span><span class="token function">inEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        next<span class="token punctuation">.</span><span class="token function">invokeFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 因为刷新操作没有参数，不用每次都创建新的 Runnable 实例</span>
        <span class="token class-name">Tasks</span> tasks <span class="token operator">=</span> next<span class="token punctuation">.</span>invokeTasks<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tasks <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            next<span class="token punctuation">.</span>invokeTasks <span class="token operator">=</span> tasks <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tasks</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">safeExecute</span><span class="token punctuation">(</span>executor<span class="token punctuation">,</span> tasks<span class="token punctuation">.</span>invokeFlushTask<span class="token punctuation">,</span> <span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">voidPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）在上一个 ChannelHandlerContext 绑定的线程内执行 AbstractChannelHandlerContext#invokeFlush 方法，同样是先判断处理器的状态，然后调用处理器对应的 flush 方法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">invokeHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 调用当前上下文对应处理器的 flush 处理方法</span>
        <span class="token function">invokeFlush0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当前上下文对应的处理器不处理，</span>
        <span class="token comment">// 继续在管道中寻找下一个事件处理器处理</span>
        <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeFlush0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ChannelOutboundHandler</span><span class="token punctuation">)</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">invokeExceptionCaught</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（3）因为是 flush 是出站事件，所以最终会调用到 HeadContext 中的 flush 方法，如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">flush</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    unsafe<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（4）AbstractUnsafe#flush，这里其实做的事情就是，操作之前 write 事件保存到出站缓冲区里面的数据了，将它们刷新到底层 Socket；</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">assertEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">ChannelOutboundBuffer</span> outboundBuffer <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>outboundBuffer<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>outboundBuffer <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 写缓冲区为空，直接返回</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 预准备刷新工作</span>
    <span class="token comment">// 将flushedEntry指向第一个需要刷新的entry节点</span>
    <span class="token comment">// 计算出 flushedEntry --&gt; taiLEntry 之间总共有多少个entry待刷新，值赋值到flushed字段内</span>
    outboundBuffer<span class="token punctuation">.</span><span class="token function">addFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">flush0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在最终了解 flush 方法做了什么事情之前，我们得了解一些出站缓冲区的设计和原理。</p><h2 id="出站缓冲区的设计和原理" tabindex="-1"><a class="header-anchor" href="#出站缓冲区的设计和原理" aria-hidden="true">#</a> 出站缓冲区的设计和原理</h2><h3 id="出站缓冲区的设计原理" tabindex="-1"><a class="header-anchor" href="#出站缓冲区的设计原理" aria-hidden="true">#</a> 出站缓冲区的设计原理</h3><p>出站缓冲区 ChannelOutboundBuffer 是一个单链表的结构，链表上的节点是 Entry 对象。出站缓冲区通过几个指针来维护数据的刷新状态。</p><p>指针如下：</p><ul><li>Entry unflushedEntry：指向第一个未被 flush 的节点；</li><li>Entry tailEntry：指向链表的尾节点，通过 unflushedEntry 和 tailEntry 这两个指针，我们可以很方便的定位到待发送数据的节点；</li><li>Entry flushedEntry：指向第一个已经准备 flush 的节点。当调用 flush 方法时，flushedEntry 指针会指向 unflushedEntry 的位置，这样 flushedEntry 指针和 tailEntry 指针之间的节点就是我们即将发送到 Socket 中的网络数据；</li></ul><h4 id="出站缓冲区添加节点" tabindex="-1"><a class="header-anchor" href="#出站缓冲区添加节点" aria-hidden="true">#</a> 出站缓冲区添加节点</h4><p><img src="`+p+'" alt="Netty出站缓冲区链表增加元素"></p><h4 id="出站缓冲区删除节点" tabindex="-1"><a class="header-anchor" href="#出站缓冲区删除节点" aria-hidden="true">#</a> 出站缓冲区删除节点</h4><p><img src="'+o+'" alt="Netty出站缓冲区链表移除元素"></p><h4 id="特殊情况" tabindex="-1"><a class="header-anchor" href="#特殊情况" aria-hidden="true">#</a> 特殊情况</h4><p><img src="'+c+`" alt="Netty出站缓冲区链表移除元素特殊"></p><h3 id="channeloutboundbuffer-的属性" tabindex="-1"><a class="header-anchor" href="#channeloutboundbuffer-的属性" aria-hidden="true">#</a> ChannelOutboundBuffer 的属性</h3><p>首先需要了解一下 ChannelOutboundBuffer 类中的一些属性</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>Channel channel</td><td>当前出站缓冲区是属于哪一个 Channel 的</td></tr><tr><td>Entry flushedEntry</td><td>指向第一个已经准备 flush 的节点。当调用 flush 方法时，flushedEntry 指针会指向 unflushedEntry 的位置，这样 flushedEntry 指针和 tailEntry 指针之间的节点就是我们即将发送到 Socket 中的网络数据；</td></tr><tr><td>Entry unflushedEntry</td><td>指向第一个未被 flush 的节点；</td></tr><tr><td>Entry tailEntry</td><td>指向链表的尾节点，通过 unflushedEntry 和 tailEntry 这两个指针，我们可以很方便的定位到待发送数据的节点；</td></tr><tr><td>int flushed</td><td>表示还有多少个节点还未被 flush</td></tr><tr><td>int nioBufferCount</td><td>表示出站缓冲区中有多少个 ByteBuffer 等待出站</td></tr><tr><td>long nioBufferSize</td><td>表示出站缓冲区有多少字节的 ByteBuffer 等待出站</td></tr><tr><td>long totalPendingSize</td><td>表示出站缓冲区中有多少自己的数据等待出站（包括 Entry 对象自身占用的内存大小），用于和高低水位作比较</td></tr><tr><td>int unwritable</td><td>表示出站缓冲区是否可写，0 表示可写，1 表示不可写</td></tr></tbody></table><h3 id="链表节点-entry" tabindex="-1"><a class="header-anchor" href="#链表节点-entry" aria-hidden="true">#</a> 链表节点 Entry</h3><p>ChannelOutboundBuffer 内就是一个单链表，链表的节点是 Entry 类型的，先了解 Entry 对象。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token punctuation">{</span>
    <span class="token comment">// entry 对象池</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ObjectPool</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Entry</span><span class="token punctuation">&gt;</span></span> <span class="token constant">RECYCLER</span> <span class="token operator">=</span> <span class="token class-name">ObjectPool</span><span class="token punctuation">.</span><span class="token function">newPool</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ObjectCreator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Entry</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">Entry</span> <span class="token function">newObject</span><span class="token punctuation">(</span><span class="token class-name">Handle</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Entry</span><span class="token punctuation">&gt;</span></span> handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 归还entry到ObjectPool使用的句柄</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Handle</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Entry</span><span class="token punctuation">&gt;</span></span> handle<span class="token punctuation">;</span>
    <span class="token comment">// 组装成链表使用的字段，指向下一个entry的节点</span>
    <span class="token class-name">Entry</span> next<span class="token punctuation">;</span>
    <span class="token comment">// 业务层面的数据，一般msg都是ByteBuf对象</span>
    <span class="token class-name">Object</span> msg<span class="token punctuation">;</span>
    <span class="token comment">// 当unsafe调用 出站缓冲区nioBuffers方法时，被涉及到的entry都会将他的msg转换成ByteBuffer，这里缓存结果使用</span>
    <span class="token class-name">ByteBuffer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bufs<span class="token punctuation">;</span>
    <span class="token class-name">ByteBuffer</span> buf<span class="token punctuation">;</span>
    <span class="token comment">// 业务层面关注msg写结果时，提交的promise</span>
    <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">;</span>
    <span class="token comment">// 进度</span>
    <span class="token keyword">long</span> progress<span class="token punctuation">;</span>
    <span class="token comment">// msg byteBuf 有效数据量大小</span>
    <span class="token keyword">long</span> total<span class="token punctuation">;</span>
    <span class="token comment">// byteBuf 有效数据量大小 + 96 (16 + 6*8 + 16 + 8 + 1)</span>
    <span class="token comment">// Assuming a 64-bit JVM:</span>
    <span class="token comment">//  - 16 bytes object header</span>
    <span class="token comment">//  - 6 reference fields</span>
    <span class="token comment">//  - 2 long fields</span>
    <span class="token comment">//  - 2 int fields</span>
    <span class="token comment">//  - 1 boolean field</span>
    <span class="token comment">//  - padding</span>
    <span class="token keyword">int</span> pendingSize<span class="token punctuation">;</span>
    <span class="token comment">// 当前msg byteBuf底层由多少 ByteBuffer组成 一般都是1，特殊情况是 CompositeByteBuf底层可以由多个ByteBuf组成</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 当前entry是否取消刷新到socket 默认是false</span>
    <span class="token keyword">boolean</span> cancelled<span class="token punctuation">;</span>
 
    
    <span class="token comment">// ...... 省略方法 ......</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Entry 类中一共有 12 个字段，1 个静态字段和 11 个实例字段。</p><p>接下来依次说明这些字段的作用：</p><ul><li><code>ObjectPool&lt;Entry&gt; RECYCLER</code>：因为 Netty 中得 write 操作肯定十分频繁，为了防止 Entry 对象频繁的创建和销毁，使用对象池技术来维护一些 Entry 对象；</li><li><code>Handle&lt;Entry&gt; handle</code>：Netty 中默认的实现是 io.netty.util.Recycler.DefaultHandle。用于在 Entry 使用完后，将其回收到 Entry 对象池；</li><li><code>Entry next</code>：因为是出站缓冲区是单链表，这个 next 的作用就是指向链表中的下一个节点；</li><li><code>Object msg</code>：业务层面要写出的数据，一般都是 ByteBuf 对象，也有 FileRegion；</li><li><code>ByteBuffer[] bufs</code>和 <code>ByteBuffer buf</code>：Netty 最终是要将写出的数据转换为 JDK 原生的 ByteBuffer，传输到底层 Socket 的。这里的 bufs 和 buf 的区别就是，假如是多个 ByteBuffer 就用数组存，假如是单个 ByteBuffer 就用 buf 存；</li><li><code>ChannelPromise promise</code>：业务层面关注 msg 写结果时，提交的 promise，调用方可以通过这个来知道写操作的情况；</li><li><code>long progress</code>：发送数据的进度，表示已经发送了多少数据；</li><li><code>long total</code>：待发送的 msg 有效数据大小，这个字段并不包含 Entry 对象的内存占用大小；</li><li><code>int pendingSize</code>：表示封装 msg 的 Entry 的总体占用内存大小，包括要发送的数据和 Entry 对象本身占用的内存；</li><li><code>int count </code>：表示待发送数据 msg 中一共包含了多少个 ByteBuffer 需要发送；</li><li><code>boolean cancelled</code>：当前 entry 是否取消刷新到 socket；</li></ul><h3 id="添加数据到出站缓冲区" tabindex="-1"><a class="header-anchor" href="#添加数据到出站缓冲区" aria-hidden="true">#</a> 添加数据到出站缓冲区</h3><p>前面分析过 write 方法就是将数据封装成一个 Entry 对象，添加到出站缓冲区中，就是对应的 ChannelOutboundBuffer#addMessage 方法</p><p><img src="`+i+`" alt="image-20230603120237433"></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * Add given message to this <span class="token punctuation">{</span><span class="token keyword">@link</span> <span class="token reference"><span class="token class-name">ChannelOutboundBuffer</span></span><span class="token punctuation">}</span>. The given <span class="token punctuation">{</span><span class="token keyword">@link</span> <span class="token reference"><span class="token class-name">ChannelPromise</span></span><span class="token punctuation">}</span> will be notified once
 * the message was written.
 *
 * <span class="token keyword">@param</span> <span class="token parameter">msg</span> 一般是ByteBuf对象， 这个ByteBuf一般是Direct的
 * <span class="token keyword">@param</span> <span class="token parameter">size</span> 数据量大小
 * <span class="token keyword">@param</span> <span class="token parameter">promise</span>
 */</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addMessage</span><span class="token punctuation">(</span><span class="token class-name">Object</span> msg<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将提供的消息封装为一个 Entry 对象</span>
    <span class="token class-name">Entry</span> entry <span class="token operator">=</span> <span class="token class-name">Entry</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token function">total</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 包装的 entry 对象假如到 entry 链表中，表示数据入站到出站缓冲区</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tailEntry <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        flushedEntry <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将新消息节点添加到队列尾</span>
        <span class="token class-name">Entry</span> tail <span class="token operator">=</span> tailEntry<span class="token punctuation">;</span>
        tail<span class="token punctuation">.</span>next <span class="token operator">=</span> entry<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    tailEntry <span class="token operator">=</span> entry<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>unflushedEntry <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果未刷新节点为空，说明队列节点都变成刷新节点了，</span>
        <span class="token comment">// 那么这个新添加的节点，就是未刷新节点的头了。</span>
        unflushedEntry <span class="token operator">=</span> entry<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// increment pending bytes after adding message to the unflushed arrays.</span>
    <span class="token comment">// See https://github.com/netty/netty/issues/1619</span>
    <span class="token comment">// 累加出站缓冲区 总大小</span>
    <span class="token function">incrementPendingOutboundBytes</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span>pendingSize<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到就是单链表的操作，添加元素到单链表，</p><ul><li>tailEntry 指针指向最后一个元素；</li><li>unflushedEntry：指向链表中第一个未 flush 到底层 Socket 的待发送数据；</li></ul><p>最下面的 incrementPendingOutboundBytes 方法是处理高低水位的方法，后面单独分析；</p><h3 id="出站缓冲区刷新数据的准备工作" tabindex="-1"><a class="header-anchor" href="#出站缓冲区刷新数据的准备工作" aria-hidden="true">#</a> 出站缓冲区刷新数据的准备工作</h3><p>在分析 flush 方法传递的时候，最终会调用 AbstractUnsafe#flush，也就是下面的方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">assertEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">ChannelOutboundBuffer</span> outboundBuffer <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>outboundBuffer<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>outboundBuffer <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 写缓冲区为空，直接返回</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 预准备刷新工作</span>
    <span class="token comment">// 将flushedEntry指向第一个需要刷新的entry节点</span>
    <span class="token comment">// 计算出 flushedEntry --&gt; taiLEntry 之间总共有多少个entry待刷新，值赋值到flushed字段内</span>
    outboundBuffer<span class="token punctuation">.</span><span class="token function">addFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">flush0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在真正调用 flush0 方法刷新数据前，会调用 ChannelOutboundBuffer#addFlush 做准备工作，其实就是前面说的那些指针的移动，然后计算有多少个 Entry 需要刷新。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 未刷新节点后面的链表示新添加的节点列表，都是要加入到刷新中</span>
    <span class="token class-name">Entry</span> entry <span class="token operator">=</span> unflushedEntry<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>entry <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>flushedEntry <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// there is no flushedEntry yet, so start with the entry</span>
            flushedEntry <span class="token operator">=</span> entry<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            flushed <span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token comment">// 将所有要刷新的节点变成不可取消的</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>entry<span class="token punctuation">.</span>promise<span class="token punctuation">.</span><span class="token function">setUncancellable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// Was cancelled so make sure we free up memory and notify about the freed bytes</span>
                <span class="token keyword">int</span> pending <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 挂起消息被取消，所以确保我们释放内存并通知释放的字节</span>
                <span class="token function">decrementPendingOutboundBytes</span><span class="token punctuation">(</span>pending<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            entry <span class="token operator">=</span> entry<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>entry <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// All flushed so reset unflushedEntry</span>
        <span class="token comment">// 每次设置后都需要把 unflushedEntry 置为空</span>
        <span class="token comment">// 在下次添加数据时，unflushedEntry 就是最先添加的 entry</span>
        unflushedEntry <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法会从 unflushedEntry 指针开始遍历，记录 unflushedEntry 节点到 tailEntry 之间总共有多少个节点，用 flushed 字段记录此次刷新有多少个 Entry 需要刷新（还未冲刷出去）。</p><p>这个操作完后，unflushedEntry 为 null 了，flushedEntry 指针指向第一个要刷新的节点。</p><p><img src="`+l+`" alt="image-20230603120414311"></p><p>在每次遍历节点的时候，会减少前面的累加的出站缓冲区的待发送数据量，也就是 decrementPendingOutboundBytes 方法，这是高低水位相关的操作。</p><p>ChannelOutboundBuffer#addFlush 方法走完后，就会调用 AbstractUnsafe#flush0 方法去准备刷新数据了，</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;deprecation&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">flush0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inFlush0<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 防止重复刷新</span>
        <span class="token comment">// Avoid re-entrance</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">final</span> <span class="token class-name">ChannelOutboundBuffer</span> outboundBuffer <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>outboundBuffer<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>outboundBuffer <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> outboundBuffer<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当前写缓冲区没有数据，那么直接返回</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 表示当前Channel正在执行刷新工作</span>
    inFlush0 <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

    <span class="token comment">// Mark all pending write requests as failure if the channel is inactive.</span>
    <span class="token comment">// 如果通道处于非活动状态，则将所有挂起的写请求标记为失败。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// Check if we need to generate the exception at all.</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>outboundBuffer<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    outboundBuffer<span class="token punctuation">.</span><span class="token function">failFlushed</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NotYetConnectedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment">// Do not trigger channelWritabilityChanged because the channel is closed already.</span>
                    outboundBuffer<span class="token punctuation">.</span><span class="token function">failFlushed</span><span class="token punctuation">(</span><span class="token function">newClosedChannelException</span><span class="token punctuation">(</span>initialCloseCause<span class="token punctuation">,</span> <span class="token string">&quot;flush0()&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            inFlush0 <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 正常逻辑 执行此处</span>
        <span class="token function">doWrite</span><span class="token punctuation">(</span>outboundBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">handleWriteError</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// 刷新操作完成，将 inFlush0重新设置为 false，以便下次刷新。</span>
        inFlush0 <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>AbstractUnsafe#flush0 主要是做刷新数据前的一些校验：</p><ul><li>校验出站缓冲区里面是否有数据待刷新；</li><li>Channel 不是 active 时，需要标记本次刷新失败，将 ChannelOutboundBuffer 中 flushedEntry 与tailEntry 之间的 Entry 对象节点全部删除，并释放发送数据占用的内存空间，同时回收 Entry 对象实例；</li></ul><h3 id="出站缓冲区的高低水位" tabindex="-1"><a class="header-anchor" href="#出站缓冲区的高低水位" aria-hidden="true">#</a> 出站缓冲区的高低水位</h3><p>为了提高网络的吞吐量，在调用 write 的时候，数据并没有写到 Socket，而是写到了 ChannelOutboundBuffer 这里，当调用 flush 的时候，才真正的向 Socket 写出。假如由于默写原因导致客户端对网络数据的接收速度以及处理速度越来越慢，而 Netty 服务端却有大量频繁的写操作，不断的写入到出站缓冲区中。</p><p>这样无限制的添加数据到出站缓冲区，就可能会导致堆外内存溢出。Netty 的出站缓冲区使用一个高低水位来控制 write 操作是否可以添加数据到出站缓冲区。</p><ul><li>当待发送的数据占用的内存（包括 Entry 对象的内存）<strong>超过高水位</strong>时，该 Channel 的出站缓冲区会被<strong>标记为不可写状态；</strong></li><li>当待发送的数据占用的内存（包括 Entry 对象的内存）<strong>低于低水位</strong>时，该 Channel 的出站缓冲区会<strong>恢复为可写状态；</strong></li></ul><p><strong>在 Netty 中的默认高水位是 64 * 1024，默认低水位是 32 * 1024</strong>。在 WriteBufferWaterMark 类中定义的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">WriteBufferWaterMark</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_LOW_WATER_MARK</span> <span class="token operator">=</span> <span class="token number">32</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_HIGH_WATER_MARK</span> <span class="token operator">=</span> <span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">WriteBufferWaterMark</span> <span class="token constant">DEFAULT</span> <span class="token operator">=</span>
            <span class="token keyword">new</span> <span class="token class-name">WriteBufferWaterMark</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_LOW_WATER_MARK</span><span class="token punctuation">,</span> <span class="token constant">DEFAULT_HIGH_WATER_MARK</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>

	<span class="token comment">// ...... 省略其他 ......</span>
    
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前面说过，ChannelOutboundBuffer 中有一个 totalPendingSize 字段，这个字段保存的是当前出站缓冲区占用的内存大小，包括真正待刷新的数据和链表节点 Entry 对象本身占用的大小。</p><blockquote><p>为什么说是包含了 Entry 对象自身占用的大小呢？</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token class-name">Entry</span> <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token class-name">Object</span> msg<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">long</span> total<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token comment">// ...... 省略 ......</span>
    
    <span class="token comment">// 加上本身的 96 的大小</span>
    entry<span class="token punctuation">.</span>pendingSize <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token constant">CHANNEL_OUTBOUND_BUFFER_ENTRY_OVERHEAD</span><span class="token punctuation">;</span>
    
    <span class="token comment">// ...... 省略 ......</span>
    <span class="token keyword">return</span> entry<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>CHANNEL_OUTBOUND_BUFFER_ENTRY_OVERHEAD 这个默认值是 96，可配置</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// Assuming a 64-bit JVM:</span>
<span class="token comment">//  - 16 bytes object header</span>
<span class="token comment">//  - 6 reference fields</span>
<span class="token comment">//  - 2 long fields</span>
<span class="token comment">//  - 2 int fields</span>
<span class="token comment">//  - 1 boolean field</span>
<span class="token comment">//  - padding</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CHANNEL_OUTBOUND_BUFFER_ENTRY_OVERHEAD</span> <span class="token operator">=</span>
        <span class="token class-name">SystemPropertyUtil</span><span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">&quot;io.netty.transport.outboundBufferEntrySizeOverhead&quot;</span><span class="token punctuation">,</span> <span class="token number">96</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>每次触发 write 事件会累加 totalPendingSize 的值，每次触发 flush 事件会减少 totalPendingSize 的值，拿 totalPendingSize 的值去和出站缓冲区高低水位做比较。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">incrementPendingOutboundBytes</span><span class="token punctuation">(</span><span class="token keyword">long</span> size<span class="token punctuation">,</span> <span class="token keyword">boolean</span> invokeLater<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// CAS累加 totalPendingSize</span>
    <span class="token keyword">long</span> newWriteBufferSize <span class="token operator">=</span> <span class="token constant">TOTAL_PENDING_SIZE_UPDATER</span><span class="token punctuation">.</span><span class="token function">addAndGet</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果累加完之后的值大于出站缓冲区高水位线，则设置unwriteable字段表示不可写，并且向ChannelPipeline发起unwriteable更改事件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newWriteBufferSize <span class="token operator">&gt;</span> channel<span class="token punctuation">.</span><span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getWriteBufferHighWaterMark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">setUnwritable</span><span class="token punctuation">(</span>invokeLater<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">decrementPendingOutboundBytes</span><span class="token punctuation">(</span><span class="token keyword">long</span> size<span class="token punctuation">,</span> <span class="token keyword">boolean</span> invokeLater<span class="token punctuation">,</span> <span class="token keyword">boolean</span> notifyWritability<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">long</span> newWriteBufferSize <span class="token operator">=</span> <span class="token constant">TOTAL_PENDING_SIZE_UPDATER</span><span class="token punctuation">.</span><span class="token function">addAndGet</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">-</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果缓冲总数据的大小小于低水位，则触发事件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>notifyWritability <span class="token operator">&amp;&amp;</span> newWriteBufferSize <span class="token operator">&lt;</span> channel<span class="token punctuation">.</span><span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getWriteBufferLowWaterMark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">setWritable</span><span class="token punctuation">(</span>invokeLater<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当待发送的数据占用的内存（包括 Entry 对象的内存）<strong>超过高水位</strong>时，就会调用 setUnwritable 方法设置 unwritable 的值。最终会调用触发入站事件 <code>pipeline.fireChannelWritabilityChanged()</code>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setUnwritable</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> invokeLater<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> oldValue <span class="token operator">=</span> unwritable<span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> newValue <span class="token operator">=</span> oldValue <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">UNWRITABLE_UPDATER</span><span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>oldValue <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">fireChannelWritabilityChanged</span><span class="token punctuation">(</span>invokeLater<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当待发送的数据占用的内存（包括 Entry 对象的内存）<strong>低于低水位</strong>时，该 Channel 的出站缓冲区会<strong>恢复为可写状态</strong>，也是修改 unwritable 的值。最终也是调用触发入站事件 <code>pipeline.fireChannelWritabilityChanged()</code>。</p><blockquote><p>注意，这里只是改了 unwritable 属性的值，<strong>在 write 写数据的时候需要判断这个 unwritable 的值，否则高低水位的限制是不生效的。</strong></p></blockquote><h2 id="真正发送数据流程" tabindex="-1"><a class="header-anchor" href="#真正发送数据流程" aria-hidden="true">#</a> 真正发送数据流程</h2><p>真正发送数据的地方在 NioSocketChannel#doWrite 方法。在分析 doWrite 方法前，先通过一个流程图来整体了解一下这个方法的流程。</p><p><img src="`+u+`" alt="NioSocketChannel的doWrite的流程图"></p><p>整体代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 入参是当前 Channel 的出站缓冲区的引用
 */</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doWrite</span><span class="token punctuation">(</span><span class="token class-name">ChannelOutboundBuffer</span> in<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token class-name">SocketChannel</span> ch <span class="token operator">=</span> <span class="token function">javaChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取属性配置writeSpinCount 循环写的最大次数 默认16</span>
    <span class="token comment">// 控制写循环次数，默认最大允许写 16 次</span>
    <span class="token keyword">int</span> writeSpinCount <span class="token operator">=</span> <span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getWriteSpinCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token comment">// 缓存中数据为空，没有数据可写</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// All written so clear OP_WRITE</span>
            <span class="token comment">// 正常退出 doWrite 走这里</span>
            <span class="token comment">// 移除写事件，并直接返回，移除当前channel 注册到的selector上的OP_WRITE事件</span>
            <span class="token function">clearOpWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// Directly return here so incompleteWrite(...) is not called.</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 执行到这里说明当前 Channel 的出站缓冲区里面还有剩余的entry待刷新</span>

        <span class="token comment">// Ensure the pending writes are made of ByteBufs only.</span>
        <span class="token comment">// 获取一次最大可写字节数 限定每次从出站缓冲区内转换多少ByteBuf字节数据的一个变量，该变量会随着 Channel 的状态不断变化</span>
        <span class="token keyword">int</span> maxBytesPerGatheringWrite <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">NioSocketChannelConfig</span><span class="token punctuation">)</span> config<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMaxBytesPerGatheringWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将出站缓冲区的部分 Entry.msg 转换为JDK Channel依赖的标准对象ByteBuffer 这里返回的是数组</span>
        <span class="token comment">// 参数1：最多转换1024个 ByteBuffer 对象</span>
        <span class="token comment">// 参数2：nioBuffers方法最多转换 maxBytes 个字节的 ByteBuf 对象</span>
        <span class="token comment">// maxBytesPerGatheringWrite 表示本次 write loop 中最多从 ChannelOutboundBuffer 中</span>
        <span class="token comment">// 转换 maxBytesPerGatheringWrite 个字节出来。也就是本次 write loop 最多能发送多少字节</span>
        <span class="token class-name">ByteBuffer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nioBuffers <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">nioBuffers</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span> maxBytesPerGatheringWrite<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> nioBufferCnt <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">nioBufferCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Always use nioBuffers() to workaround data-corruption.</span>
        <span class="token comment">// See https://github.com/netty/netty/issues/2761</span>
        <span class="token comment">// 缓存中有多少个nioBufferCnt</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>nioBufferCnt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>
                <span class="token comment">// We have something else beside ByteBuffers to write so fallback to normal writes.</span>
                <span class="token comment">// 不是ByteBuffer数据，交给父类实现</span>
                writeSpinCount <span class="token operator">-=</span> <span class="token function">doWrite0</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                <span class="token comment">// Only one ByteBuf so use non-gathering write</span>
                <span class="token comment">// Zero length buffers are not added to nioBuffers by ChannelOutboundBuffer, so there is no need</span>
                <span class="token comment">// to check if the total size of all the buffers is non-zero.</span>
                <span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> nioBuffers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token comment">// buffer可读字节</span>
                <span class="token keyword">int</span> attemptedBytes <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">remaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 将buffer写到到Socket缓存中，有可能全部写进去了，也有可能写了一部分，也有可能全部写失败的</span>
                <span class="token keyword">final</span> <span class="token keyword">int</span> localWrittenBytes <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 发送失败，说明底层 socket 写缓冲区已经满了，本次 write 没写进去</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>localWrittenBytes <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 将写事件添加到事件兴趣集中，等待socket 写缓冲区有空闲空间后，继续写</span>
                    <span class="token function">incompleteWrite</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token comment">// 执行到这里，说明 buffer 可能数据全部写入到 socket 缓存区，也可能写了一部分数据到 socket 缓存区</span>
                <span class="token function">adjustMaxBytesPerGatheringWrite</span><span class="token punctuation">(</span>attemptedBytes<span class="token punctuation">,</span> localWrittenBytes<span class="token punctuation">,</span> maxBytesPerGatheringWrite<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 移除写成功的字节数</span>
                in<span class="token punctuation">.</span><span class="token function">removeBytes</span><span class="token punctuation">(</span>localWrittenBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">--</span>writeSpinCount<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">default</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                <span class="token comment">// Zero length buffers are not added to nioBuffers by ChannelOutboundBuffer, so there is no need</span>
                <span class="token comment">// to check if the total size of all the buffers is non-zero.</span>
                <span class="token comment">// We limit the max amount to int above so cast is safe</span>
                <span class="token keyword">long</span> attemptedBytes <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">nioBufferSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">final</span> <span class="token keyword">long</span> localWrittenBytes <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>nioBuffers<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nioBufferCnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>localWrittenBytes <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">incompleteWrite</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// Casting to int is safe because we limit the total amount of data in the nioBuffers to int above.</span>
                <span class="token function">adjustMaxBytesPerGatheringWrite</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> attemptedBytes<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> localWrittenBytes<span class="token punctuation">,</span>
                        maxBytesPerGatheringWrite<span class="token punctuation">)</span><span class="token punctuation">;</span>
                in<span class="token punctuation">.</span><span class="token function">removeBytes</span><span class="token punctuation">(</span>localWrittenBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">--</span>writeSpinCount<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>writeSpinCount <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 执行到这里的时候，do while循环了16次，仍然没有把 出站缓冲区 待发送的数据处理完</span>
    <span class="token comment">//</span>
    <span class="token function">incompleteWrite</span><span class="token punctuation">(</span>writeSpinCount <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="获取-netty-允许写循环的次数" tabindex="-1"><a class="header-anchor" href="#获取-netty-允许写循环的次数" aria-hidden="true">#</a> 获取 Netty 允许写循环的次数</h3><p>第一步获取 Netty 的允许的最大写循环次数，因为一个 Reactor 线程的 Selector 上会处理多个 Channel 的事件，所以得限制一次读循环的次数，不能一直在处理某个 Channel 上的事件，否则其他 Channel 上的事件执行等待的时间可能就比较长。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> writeSpinCount <span class="token operator">=</span> <span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getWriteSpinCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="do-while-出站缓冲区数据写完后退出" tabindex="-1"><a class="header-anchor" href="#do-while-出站缓冲区数据写完后退出" aria-hidden="true">#</a> do...while：出站缓冲区数据写完后退出</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doWrite</span><span class="token punctuation">(</span><span class="token class-name">ChannelOutboundBuffer</span> in<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...... 省略其他 ......</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token comment">// 缓存中数据为空，没有数据可写</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// All written so clear OP_WRITE</span>
            <span class="token comment">// 正常退出 doWrite 走这里</span>
            <span class="token comment">// 移除写事件，并直接返回，移除当前channel 注册到的selector上的OP_WRITE事件</span>
            <span class="token function">clearOpWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// Directly return here so incompleteWrite(...) is not called.</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// ...... 省略其他 ......</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>writeSpinCount <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// ...... 省略其他 ......</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里是将出站缓冲区中要刷新的数据全部写入到 Socket 后的出口，一般情况都是从这里退出循环的。</p><p>关于 ChannelOutboundBuffer#isEmpty 方法，其实就是判断 flushed 字段是否是 0，前面分析过 flushed 就是表示当前出站缓冲区中有多少个 Entry 对象需要刷新，是在 ChannelOutboundBuffer#addFlush 中累加的。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> flushed <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果出站缓冲区的数据已经刷新完了，就清除当前 Channel 注册到 Selector 上的写事件。后面解释为什么要清除写事件。</p><h3 id="do-while-获取此次循环能够写入的最大字节数" tabindex="-1"><a class="header-anchor" href="#do-while-获取此次循环能够写入的最大字节数" aria-hidden="true">#</a> do...while：获取此次循环能够写入的最大字节数</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doWrite</span><span class="token punctuation">(</span><span class="token class-name">ChannelOutboundBuffer</span> in<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...... 省略其他 ......</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...... 省略其他 ......</span>
        
        <span class="token comment">// 获取一次最大可写字节数 限定每次从出站缓冲区内转换多少ByteBuf字节数据的一个变量，该变量会随着 Channel 的状态不断变化</span>
        <span class="token keyword">int</span> maxBytesPerGatheringWrite <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">NioSocketChannelConfig</span><span class="token punctuation">)</span> config<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMaxBytesPerGatheringWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// ...... 省略其他 ......</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>writeSpinCount <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// ...... 省略其他 ......</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>首先需要获取此次能够写入的最大字节数</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> maxBytesPerGatheringWrite <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">NioSocketChannelConfig</span><span class="token punctuation">)</span> config<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMaxBytesPerGatheringWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>默认是 SocketOptions#SO_SNDBUF 的两倍。在 Netty 中 SO_SNDBUF 初始大小是 131072，两倍就是 262144。也就是说 maxBytesPerGatheringWrite 默认初始大小是 262144。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">calculateMaxBytesPerGatheringWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Multiply by 2 to give some extra space in case the OS can process write data faster than we can provide.</span>
    <span class="token keyword">int</span> newSendBufferSize <span class="token operator">=</span> <span class="token function">getSendBufferSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newSendBufferSize <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">setMaxBytesPerGatheringWrite</span><span class="token punctuation">(</span>newSendBufferSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="do-while-待发送数据转换为-bytebuffer" tabindex="-1"><a class="header-anchor" href="#do-while-待发送数据转换为-bytebuffer" aria-hidden="true">#</a> do...while：待发送数据转换为 ByteBuffer</h3><blockquote><p>本小结只需要了解会将待发送的数据转换为 ByteBuffer 即可。</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doWrite</span><span class="token punctuation">(</span><span class="token class-name">ChannelOutboundBuffer</span> in<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...... 省略其他 ......</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...... 省略其他 ......</span>
        
        <span class="token comment">// 将出站缓冲区的部分 Entry.msg 转换为JDK Channel依赖的标准对象ByteBuffer 这里返回的是数组</span>
        <span class="token comment">// 参数1：最多转换1024个 ByteBuffer 对象</span>
        <span class="token comment">// 参数2：nioBuffers方法最多转换 maxBytes 个字节的 ByteBuf 对象</span>
        <span class="token class-name">ByteBuffer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nioBuffers <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">nioBuffers</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span> maxBytesPerGatheringWrite<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// ...... 省略其他 ......</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>writeSpinCount <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// ...... 省略其他 ......</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为最终数据是要写入到 Socket 里面的，需要将出站缓冲区的数据转换为 JDK 的 ByteBuffer 对象写入。</p><p>ChannelOutboundBuffer#nioBuffers(int, long) 的两个参数：</p><ul><li><code>maxCount</code>：默认 1024，表示此次循环最多只能转换 1024 个 JDK 的 ByteBuffer 对象；</li><li><code>maxBytesPerGatheringWrite</code>：表示此次最多只能转换多少个字节，也就是说当前写循环最多能够发送多少字节；</li></ul><p>这个方法主要做的事情就是：从 flushedEntry 节点开始遍历，直到遍历完或者遇到了 unflushedEntry 节点就退出，具体对每个 Entry 节点做的事情就是：</p><ol><li>累加可发送的字节数；</li><li>记录遍历到的 Entry 中的 count 字段，这个字段前面说过，表示当前 msg byteBuf 底层由多少 ByteBuffer组成，一般都是 1，特殊情况是 CompositeByteBuf 底层可以由多个 ByteBuf 组成； <ol><li>假如是 1 个 ByteBuffer 组成，就用 Entry 的 <code>ByteBuffer buf</code> 字段保存 ByteBuffer；</li><li>假如是多个 ByteBuffer 组成，就用 Entry 的 <code>ByteBuffer[] bufs</code> 字段保存 ByteBuffer；</li></ol></li></ol><p>当整个遍历节点结束，或者到了 ByteBuffer 的限制，或者到了 maxBytesPerGatheringWrite 的限制，最后就能得到下面两个ChannelOutboundBuffer 的字段的值：</p><ul><li><code>int nioBufferCount</code>：当前出站缓冲区有多少个 ByteBuffer 正在等待出站；</li><li><code>long nioBufferSize</code>：当前出站缓冲区有多少个字节的数据正在等待出站；</li></ul><p>全部代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nioBuffers</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxCount<span class="token punctuation">,</span> <span class="token keyword">long</span> maxBytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">assert</span> maxCount <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">assert</span> maxBytes <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 本次方法调用一共转换了多少容量的buffer</span>
    <span class="token keyword">long</span> nioBufferSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 本次方法调用，一共将ByteBuf转换成多少个ByteBuffer对象</span>
    <span class="token keyword">int</span> nioBufferCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">InternalThreadLocalMap</span> threadLocalMap <span class="token operator">=</span> <span class="token class-name">InternalThreadLocalMap</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 从线程本地缓存获取 ByteBuffer 数组，会给每个线程分配一个1024的ByteBuffer数组，避免每个线程每次调用都创建一个ByteBuffer数组</span>
    <span class="token class-name">ByteBuffer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nioBuffers <span class="token operator">=</span> <span class="token constant">NIO_BUFFERS</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>threadLocalMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 循环处理开始节点，准备第一个写入 Socket 的元素</span>
    <span class="token class-name">Entry</span> entry <span class="token operator">=</span> flushedEntry<span class="token punctuation">;</span>
    <span class="token comment">// 循环条件 当前节点不是 null &amp;&amp; 当前节点不是 unflushedEntry 指向的节点</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isFlushedEntry</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> entry<span class="token punctuation">.</span>msg <span class="token keyword">instanceof</span> <span class="token class-name">ByteBuf</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 条件成立，则说明当前 entry 节点不是取消状态，所以需要提取它的数据</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>entry<span class="token punctuation">.</span>cancelled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">ByteBuf</span> buf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ByteBuf</span><span class="token punctuation">)</span> entry<span class="token punctuation">.</span>msg<span class="token punctuation">;</span>
            <span class="token comment">// 获取读索引位置</span>
            <span class="token keyword">final</span> <span class="token keyword">int</span> readerIndex <span class="token operator">=</span> buf<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 有效数据量，可发送的字节数</span>
            <span class="token keyword">final</span> <span class="token keyword">int</span> readableBytes <span class="token operator">=</span> buf<span class="token punctuation">.</span><span class="token function">writerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> readerIndex<span class="token punctuation">;</span>

            <span class="token comment">// 条件成立 说明msg包含待发送数据...</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>readableBytes <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// nioBufferSize + readableBytes &gt; maxBytes</span>
                <span class="token comment">// 本次调用已转换Buffer容量大小 + 本次循环转换大小 &gt; 最大限制，则跳出循环</span>
                <span class="token comment">// 累计发送字节数不能大于 maxBytes</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>maxBytes <span class="token operator">-</span> readableBytes <span class="token operator">&lt;</span> nioBufferSize <span class="token operator">&amp;&amp;</span> nioBufferCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token comment">// 正常逻辑走到此处</span>

                <span class="token comment">// 更新累计发送字节数</span>
                nioBufferSize <span class="token operator">+=</span> readableBytes<span class="token punctuation">;</span>
                <span class="token comment">// 一般情况下 count默认值 -1</span>
                <span class="token keyword">int</span> count <span class="token operator">=</span> entry<span class="token punctuation">.</span>count<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">//noinspection ConstantValueVariableUse</span>
                    <span class="token comment">// 获取节点中 bytebuffer 的个数，，获取出ByteBuf底层到底是由几个ByteBuffer构成的，这里msg都是direct bytebuf</span>
                    <span class="token comment">// 一般情况下返回的1，特殊情况CompositeByteBuf</span>
                    entry<span class="token punctuation">.</span>count <span class="token operator">=</span> count <span class="token operator">=</span> buf<span class="token punctuation">.</span><span class="token function">nioBufferCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 计算出需要多大的ByteBuffer数组</span>
                <span class="token keyword">int</span> neededSpace <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>maxCount<span class="token punctuation">,</span> nioBufferCount <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>neededSpace <span class="token operator">&gt;</span> nioBuffers<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 假如需要的 数组大小 &gt; 默认的 1024 的话，则扩容操作</span>
                    nioBuffers <span class="token operator">=</span> <span class="token function">expandNioBufferArray</span><span class="token punctuation">(</span>nioBuffers<span class="token punctuation">,</span> neededSpace<span class="token punctuation">,</span> nioBufferCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token constant">NIO_BUFFERS</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>threadLocalMap<span class="token punctuation">,</span> nioBuffers<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 大部分情况 count == 1</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">ByteBuffer</span> nioBuf <span class="token operator">=</span> entry<span class="token punctuation">.</span>buf<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nioBuf <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">// cache ByteBuffer as it may need to create a new ByteBuffer instance if its a</span>
                        <span class="token comment">// derived buffer</span>
                        <span class="token comment">// 获取ByteBuf底层真正内存 ByteBuffer对象</span>
                        <span class="token comment">// 参数1：读索引</span>
                        <span class="token comment">// 参数2：可读数据容量</span>
                        entry<span class="token punctuation">.</span>buf <span class="token operator">=</span> nioBuf <span class="token operator">=</span> buf<span class="token punctuation">.</span><span class="token function">internalNioBuffer</span><span class="token punctuation">(</span>readerIndex<span class="token punctuation">,</span> readableBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment">// 将刚刚转换出来的ByteBuffer对象加入到数组</span>
                    nioBuffers<span class="token punctuation">[</span>nioBufferCount<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nioBuf<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment">// The code exists in an extra method to ensure the method is not too big to inline as this</span>
                    <span class="token comment">// branch is not very likely to get hit very frequently.</span>
                    <span class="token comment">// 如果有多个循环获取 ByteBuffer 存到 niobuffers 数组中</span>
                    nioBufferCount <span class="token operator">=</span> <span class="token function">nioBuffers</span><span class="token punctuation">(</span>entry<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> nioBuffers<span class="token punctuation">,</span> nioBufferCount<span class="token punctuation">,</span> maxCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>nioBufferCount <span class="token operator">&gt;=</span> maxCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 节点指针后移</span>
        entry <span class="token operator">=</span> entry<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 出站缓冲区记录 有多少 byteBuffer 等待出站</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>nioBufferCount <span class="token operator">=</span> nioBufferCount<span class="token punctuation">;</span>
    <span class="token comment">// 出站缓冲区记录 有多少字节的 byteBuffer 待出站</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>nioBufferSize <span class="token operator">=</span> nioBufferSize<span class="token punctuation">;</span>

    <span class="token comment">// 返回从entry链表中提取的buffer数组</span>
    <span class="token keyword">return</span> nioBuffers<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="do-while-发送数据到-socket" tabindex="-1"><a class="header-anchor" href="#do-while-发送数据到-socket" aria-hidden="true">#</a> do...while：发送数据到 Socket</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doWrite</span><span class="token punctuation">(</span><span class="token class-name">ChannelOutboundBuffer</span> in<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...... 省略其他 ......</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...... 省略其他 ......</span>

        <span class="token keyword">int</span> nioBufferCnt <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">nioBufferCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 缓存中有多少个nioBufferCnt</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>nioBufferCnt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>
                <span class="token comment">// We have something else beside ByteBuffers to write so fallback to normal writes.</span>
                <span class="token comment">// 不是ByteBuffer数据，交给父类实现</span>
                writeSpinCount <span class="token operator">-=</span> <span class="token function">doWrite0</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                <span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> nioBuffers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token comment">// buffer可读字节</span>
                <span class="token keyword">int</span> attemptedBytes <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">remaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 将buffer写到到Socket缓存中，有可能全部写进去了，也有可能写了一部分，也有可能全部写失败的</span>
                <span class="token keyword">final</span> <span class="token keyword">int</span> localWrittenBytes <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 发送失败，说明底层 socket 写缓冲区已经满了，本次 write 没写进去</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>localWrittenBytes <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 将写事件添加到事件兴趣集中，等待socket 写缓冲区有空闲空间后，继续写</span>
                    <span class="token function">incompleteWrite</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token comment">// 执行到这里，说明 buffer 可能数据全部写入到 socket 缓存区，也可能写了一部分数据到 socket 缓存区</span>
                <span class="token function">adjustMaxBytesPerGatheringWrite</span><span class="token punctuation">(</span>attemptedBytes<span class="token punctuation">,</span> localWrittenBytes<span class="token punctuation">,</span> maxBytesPerGatheringWrite<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 移除写成功的字节数</span>
                in<span class="token punctuation">.</span><span class="token function">removeBytes</span><span class="token punctuation">(</span>localWrittenBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">--</span>writeSpinCount<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">default</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                <span class="token comment">// Zero length buffers are not added to nioBuffers by ChannelOutboundBuffer, so there is no need</span>
                <span class="token comment">// to check if the total size of all the buffers is non-zero.</span>
                <span class="token comment">// We limit the max amount to int above so cast is safe</span>
                <span class="token keyword">long</span> attemptedBytes <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">nioBufferSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">final</span> <span class="token keyword">long</span> localWrittenBytes <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>nioBuffers<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nioBufferCnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>localWrittenBytes <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">incompleteWrite</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// Casting to int is safe because we limit the total amount of data in the nioBuffers to int above.</span>
                <span class="token function">adjustMaxBytesPerGatheringWrite</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> attemptedBytes<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> localWrittenBytes<span class="token punctuation">,</span>
                                                maxBytesPerGatheringWrite<span class="token punctuation">)</span><span class="token punctuation">;</span>
                in<span class="token punctuation">.</span><span class="token function">removeBytes</span><span class="token punctuation">(</span>localWrittenBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">--</span>writeSpinCount<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>writeSpinCount <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// ...... 省略其他 ......</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在转换 ByteBuffer 的方法中，已经得到了此次需要转换多少个 ByteBuffer。CASE 0 的情况是处理 FileRegion 类型的，交给父类去处理。</p><p>这里分析 CASE 1 和 default 的情况，这两个情况的处理其实差不多，无非就是一个写 1 个 ByteBuffer 到 Socket，一个是写多个 ByteBuffer 到 Socket。这里拿 CASE 1 分支来分析。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// Only one ByteBuf so use non-gathering write</span>
    <span class="token comment">// Zero length buffers are not added to nioBuffers by ChannelOutboundBuffer, so there is no need</span>
    <span class="token comment">// to check if the total size of all the buffers is non-zero.</span>
    <span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> nioBuffers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// buffer可读字节</span>
    <span class="token keyword">int</span> attemptedBytes <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">remaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 将buffer写到到Socket缓存中，有可能全部写进去了，也有可能写了一部分，也有可能全部写失败的</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> localWrittenBytes <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 发送失败，说明底层 socket 写缓冲区已经满了，本次 write 没写进去</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>localWrittenBytes <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将写事件添加到事件兴趣集中，等待socket 写缓冲区有空闲空间后，继续写</span>
        <span class="token function">incompleteWrite</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 执行到这里，说明 buffer 可能数据全部写入到 socket 缓存区，也可能写了一部分数据到 socket 缓存区</span>
    <span class="token function">adjustMaxBytesPerGatheringWrite</span><span class="token punctuation">(</span>attemptedBytes<span class="token punctuation">,</span> localWrittenBytes<span class="token punctuation">,</span> maxBytesPerGatheringWrite<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 移除写成功的字节数</span>
    in<span class="token punctuation">.</span><span class="token function">removeBytes</span><span class="token punctuation">(</span>localWrittenBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">--</span>writeSpinCount<span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="记录-bytebuffer-的可写的数据大小" tabindex="-1"><a class="header-anchor" href="#记录-bytebuffer-的可写的数据大小" aria-hidden="true">#</a> 记录 ByteBuffer 的可写的数据大小</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> nioBuffers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// buffer可读字节</span>
    <span class="token keyword">int</span> attemptedBytes <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">remaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="将数据写到-socket" tabindex="-1"><a class="header-anchor" href="#将数据写到-socket" aria-hidden="true">#</a> 将数据写到 socket</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 将buffer写到到Socket缓存中，有可能全部写进去了，也有可能写了一部分，也有可能全部写失败的</span>
<span class="token keyword">final</span> <span class="token keyword">int</span> localWrittenBytes <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="处理-socket-满-未写入成功情况" tabindex="-1"><a class="header-anchor" href="#处理-socket-满-未写入成功情况" aria-hidden="true">#</a> 处理 socket 满，未写入成功情况</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 将buffer写到到Socket缓存中，有可能全部写进去了，也有可能写了一部分，也有可能全部写失败的</span>
<span class="token keyword">final</span> <span class="token keyword">int</span> localWrittenBytes <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 发送失败，说明底层 socket 写缓冲区已经满了，本次 write 没写进去</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>localWrittenBytes <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将写事件添加到事件兴趣集中，等待socket 写缓冲区有空闲空间后，继续写</span>
    <span class="token function">incompleteWrite</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>localWrittenBytes 返回值小于等于 0，说明本次写入 Socket 失败，socket 的写缓冲区 SEND_BUF 满了，需要调用 bstractNioByteChannel#incompleteWrite 方法去设置 Channel 在 Selector 注册 OP_WRITE 事件，当 Socket 再次可写时会唤醒 Reactor 线程继续写入。</p><h4 id="调整每次循环可写的最大字节数" tabindex="-1"><a class="header-anchor" href="#调整每次循环可写的最大字节数" aria-hidden="true">#</a> 调整每次循环可写的最大字节数</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 执行到这里，说明 buffer 可能数据全部写入到 socket 缓存区，也可能写了一部分数据到 socket 缓存区</span>
<span class="token function">adjustMaxBytesPerGatheringWrite</span><span class="token punctuation">(</span>attemptedBytes<span class="token punctuation">,</span> localWrittenBytes<span class="token punctuation">,</span> maxBytesPerGatheringWrite<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>NioSocketChannel#adjustMaxBytesPerGatheringWrite</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">adjustMaxBytesPerGatheringWrite</span><span class="token punctuation">(</span><span class="token keyword">int</span> attempted<span class="token punctuation">,</span> <span class="token keyword">int</span> written<span class="token punctuation">,</span> <span class="token keyword">int</span> oldMaxBytesPerGatheringWrite<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>attempted <span class="token operator">==</span> written<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>attempted <span class="token operator">&lt;</span><span class="token generics"><span class="token punctuation">&lt;</span> 1 <span class="token punctuation">&gt;</span></span> oldMaxBytesPerGatheringWrite<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">NioSocketChannelConfig</span><span class="token punctuation">)</span> config<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setMaxBytesPerGatheringWrite</span><span class="token punctuation">(</span>attempted <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>attempted <span class="token operator">&gt;</span> <span class="token constant">MAX_BYTES_PER_GATHERING_WRITE_ATTEMPTED_LOW_THRESHOLD</span> <span class="token operator">&amp;&amp;</span> written <span class="token generics"><span class="token punctuation">&lt;</span> attempted <span class="token punctuation">&gt;</span></span><span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">NioSocketChannelConfig</span><span class="token punctuation">)</span> config<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setMaxBytesPerGatheringWrite</span><span class="token punctuation">(</span>attempted <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SO_SNDBUF 用来设置发送缓冲区大小的，即应用程序可以写入到套接字发送缓冲区的最大字节数。但一些操作系统可能会动态地调整 SO_SNDBUF 的大小，这个方法的作用就是尽量适应操作系统行为变化。</p><p>该方法有两个参数：</p><ul><li><code>attempted</code>：某次循环待发送的数据量；</li><li><code>written</code>：某次循环真正写入到发送缓冲区的数据量；</li><li><code>oldMaxBytesPerGatheringWrite</code>：旧的 maxBytesPerGatheringWrite 值，也就是上一次写循环中的允许写入的最大值；</li></ul><p>通过把 attempted 和 written 作比较来动态调整 maxBytesPerGatheringWrite字段的大小，也就是写循环每次最多能发送的数据大小。maxBytesPerGatheringWrite 初始值为 SO_SNDBUF 的两倍 262144。</p><p>第一个 CASE <code>attempted == written</code>，说明某次循环把要写入的数据全部写入到 Socket 了，说明可能还有更多的数据需要写入，需要将 maxBytesPerGatheringWrite 的值扩大到原来的两倍，即 <code>attempted &lt;&lt; 1</code>。</p><p>第二个 CASE <code>attempted &gt; MAX_BYTES_PER_GATHERING_WRITE_ATTEMPTED_LOW_THRESHOLD &amp;&amp; written &lt; attempted &gt;&gt;&gt; 1</code>，其中那个常量的值是 4096，<code>written &lt; attempted &gt;&gt;&gt; 1</code>，表示本次写入的数据还未达到上限的一般。总的来说就是，当本次写入的数据还未达到上限的一半时，就将 maxBytesPerGatheringWrite 缩小到原来的 1/2，即 <code>attempted &gt;&gt;&gt; 1</code>，当然最小不能小于 4096。</p><h4 id="移除成功写入到-socket-的-entry" tabindex="-1"><a class="header-anchor" href="#移除成功写入到-socket-的-entry" aria-hidden="true">#</a> 移除成功写入到 Socket 的 Entry</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 移除写成功的字节数</span>
in<span class="token punctuation">.</span><span class="token function">removeBytes</span><span class="token punctuation">(</span>localWrittenBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>既然已经写入部分数据到 Socket 的发送缓冲区中去了，那么就需要将 ChannelOutboundBuffer 出站缓冲区的对应的 Entry 节点从单链表中移除。</p><blockquote><p>需要注意的是，写入到 Socket 的数据，可能不是完整个 Entry 的数据，也就是说某个 Entry 可能就写了一部分数据到 Socket 的发送缓冲区中了</p></blockquote><p><img src="`+r+`" alt="ChannelOutboundBuffer的removeBytes方法"></p><p>ChannelOutboundBuffer#removeBytes 方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeBytes</span><span class="token punctuation">(</span><span class="token keyword">long</span> writtenBytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取flushedEntry节点指向的entry.msg数据,从第一个准备写入socket 的节点开始</span>
        <span class="token class-name">Object</span> msg <span class="token operator">=</span> <span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>msg <span class="token keyword">instanceof</span> <span class="token class-name">ByteBuf</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">assert</span> writtenBytes <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">final</span> <span class="token class-name">ByteBuf</span> buf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ByteBuf</span><span class="token punctuation">)</span> msg<span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> readerIndex <span class="token operator">=</span> buf<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 计算出msg可读数据量大小</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> readableBytes <span class="token operator">=</span> buf<span class="token punctuation">.</span><span class="token function">writerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> readerIndex<span class="token punctuation">;</span>

        <span class="token comment">// 条件成立 说明unsafe写入到socket底层缓存区的 数据量 &gt; flushedEntry.msg可读数据量的大小，if内的逻辑就是移除flushedEntry代表的entry</span>
        <span class="token comment">// 如果当前节点的字节数小于或等于已发送的字节数，则直接删除整个节点，并更新精度进度</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>readableBytes <span class="token operator">&lt;=</span> writtenBytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>writtenBytes <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">progress</span><span class="token punctuation">(</span>readableBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
                writtenBytes <span class="token operator">-=</span> readableBytes<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 执行到else说明 unsafe真正写入到socket的数据量 &lt; 当前flushedEntry.msg的可读数据量</span>
        <span class="token comment">// 若当前节点还有部分未发送完，则缩小当前节点的可发送字节长度</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// readableBytes &gt; writtenBytes</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>writtenBytes <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                buf<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span>readerIndex <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> writtenBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">progress</span><span class="token punctuation">(</span>writtenBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 因为每次发送时，都是从线程本地缓存获取的 byteBuffer 数组</span>
    <span class="token comment">// 需要在每次处理完后清理这个数组</span>
    <span class="token function">clearNioBuffers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该方法 for 循环遍历 Entry，直到所有的 writtenBytes 都处理完毕了就退出循环。</p><p>（1）第一步通过 ChannelOutboundBuffer#current 方法，获取 flushedEntry 指针指向的 Entry 的 msg，也就是该 Entry 内保存的数据。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Entry</span> entry <span class="token operator">=</span> flushedEntry<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>entry <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> entry<span class="token punctuation">.</span>msg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）第二步：计算这个 Entry 内的数据大小 readableBytes。</p><p>（3）第三步：将 readableBytes 和 writtenBytes 做比较，做不同的处理。readableBytes 是当前 Entry 内的数据大小，writtenBytes 是剩余待处理的数据大小。</p><ul><li>假如 readableBytes 小于等于 writtenBytes，说明当前 Entry 内的数据已经成功写入到 Socket 的发送缓冲区了，需要记录当前的发送进度，然后将 writtenBytes 的值减少，最后调用 remove 方法，将写入成功的数据从链表移除；</li><li>假如 readableBytes 大于 writtenBytes，有两种情况 <ul><li>writtenBytes 大于 0，但是比 readableBytes 小，说明某个 Entry 内的数据，只有部分数据成功写入到 Socket 的发送缓冲区了。这是需要将 Entry 内的 （Netty 的对象）ByteBuf 的读指针增大一下。最后需要退出循环；</li><li>writtenBytes 等于 0，说明这次写入数据刚好都是完整的 Entry 的数据，直接退出循环即可；</li></ul></li></ul><p>那么是怎么移除节点的呢？</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Entry</span> e <span class="token operator">=</span> flushedEntry<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 假如获取不到链表头结点，则清空 Bytebuf 缓存</span>
        <span class="token function">clearNioBuffers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Object</span> msg <span class="token operator">=</span> e<span class="token punctuation">.</span>msg<span class="token punctuation">;</span>

    <span class="token class-name">ChannelPromise</span> promise <span class="token operator">=</span> e<span class="token punctuation">.</span>promise<span class="token punctuation">;</span>
    <span class="token keyword">int</span> size <span class="token operator">=</span> e<span class="token punctuation">.</span>pendingSize<span class="token punctuation">;</span>

    <span class="token comment">// 一般是移动 flushedEntry指向当前e的下一个节点，并且更新flushed字段</span>
    <span class="token function">removeEntry</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>e<span class="token punctuation">.</span>cancelled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// only release message, notify and decrement if it was not canceled before.</span>
        <span class="token comment">// ByteBuf实现了引用计数，更新引用计数</span>
        <span class="token class-name">ReferenceCountUtil</span><span class="token punctuation">.</span><span class="token function">safeRelease</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">safeSuccess</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">decrementPendingOutboundBytes</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// recycle the entry</span>
    <span class="token comment">// 归还entry到对象池</span>
    e<span class="token punctuation">.</span><span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">removeEntry</span><span class="token punctuation">(</span><span class="token class-name">Entry</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span> flushed <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 说明待刷新的数据都 刷完了</span>
        <span class="token comment">// processed everything</span>
        flushedEntry <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> tailEntry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            tailEntry <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            unflushedEntry <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        flushedEntry <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>移除节点的逻辑很简单，就是单链表的操作，前面说过 flushed 表示此次要刷新的 Entry 的个数。当 <code>--flushed == 0</code> 时就说明所有的 Entry 都已经写到 Socket 的发送缓冲区上去了。当 <code>--flushed</code> 操作不等于 0 时，说明还有 Entry 没有刷新完， <code>flushedEntry = e.next</code> 让 flushedEntry 指针后移即可，这里就是单链表的删除操作了。</p><h3 id="do-while-退出写循环的地方" tabindex="-1"><a class="header-anchor" href="#do-while-退出写循环的地方" aria-hidden="true">#</a> do...while：退出写循环的地方</h3><p>有两个地方退出写循环</p><p>**（1）出站缓冲区的数据全部刷新到 Socket 的发送缓冲区了。此时循环条件 <code>while(writeSpinCount &gt; 0)</code> 中的 writeSpinCount 可能还未减到 0；**这里不仅是退出循环，是直接退出方法了。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 缓存中数据为空，没有数据可写</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// All written so clear OP_WRITE</span>
    <span class="token comment">// 正常退出 doWrite 走这里</span>
    <span class="token comment">// 移除写事件，并直接返回，移除当前channel 注册到的selector上的OP_WRITE事件</span>
    <span class="token function">clearOpWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Directly return here so incompleteWrite(...) is not called.</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>（2）另外一种情况就是 writeSpinCount 的值减到 0 了，也就是写了 16 次，出站缓冲区的数据还未写完；</strong></p><h3 id="处理-socket-可写但写满16次还没完全写完" tabindex="-1"><a class="header-anchor" href="#处理-socket-可写但写满16次还没完全写完" aria-hidden="true">#</a> 处理 Socket 可写但写满16次还没完全写完</h3><p>AbstractNioByteChannel#incompleteWrite 方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">incompleteWrite</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> setOpWrite<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Did not write completely.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>setOpWrite<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 没有写完，设置 OP_WRITE 事件</span>
        <span class="token function">setOpWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// It is possible that we have set the write OP, woken up by NIO because the socket is writable, and then</span>
        <span class="token comment">// use our write quantum. In this case we no longer want to set the write OP because the socket is still</span>
        <span class="token comment">// writable (as far as we know). We will find out next time we attempt to write if the socket is writable</span>
        <span class="token comment">// and set the write OP if necessary.</span>
        <span class="token function">clearOpWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Schedule flush again later so other tasks can be picked up in the meantime</span>
        <span class="token comment">// 调用任务是，因为防止多路复用器上的其他 Channel饥饿，</span>
        <span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>flushTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有两个地方会调用这个方法：</p><ul><li>传 true 的时候：发送缓冲区满了，无法写入了，此时调用 <code>incompleteWrite</code> 方法传入 true，去注册 OP_WRITE 事件。当发送缓冲区可写时，会唤醒 Reactor 线程；</li><li>传 false 的时候有两种情况： <ul><li>一种是处理 ByteBuf 的时候，此次要写的数据太多了，导致写循环 16 次还没有写完，此时 writeSpinCount 就是 0 了；</li><li>另外一种是处理 FileRegion 的时候，当无法写入到发送缓冲区的时候，会返回 <code>WRITE_STATUS_SNDBUF_FULL</code>，这个常量的值是 Integer.MAX_VALUE，会触发 <code>writeSpinCount -= doWrite0(in);</code>，这样子 writeSpinCount 就小于 0了；</li></ul></li></ul><p>传 true 的时候很好理解，就是注册 OP_WRITE 事件。传 false 的时候，首先清除掉关注的 OP_WRITE 事件，然后添加一个刷新任务。因为写缓冲区是可写的，此次是因为要写的数据量太大了，写了 16 次还没写完，所以先要清除掉关注的 OP_WRITE 事件。否则会应为写缓冲区是可写的一直触发写事件。（JDK NIO Selector 默认的是 epoll 的水平触发）</p><h2 id="nioeventloop-处理-op-write-事件" tabindex="-1"><a class="header-anchor" href="#nioeventloop-处理-op-write-事件" aria-hidden="true">#</a> NioEventLoop 处理 OP_WRITE 事件</h2><p>前面在分析 NioEventLoop 的 run 方法的时候，已经分析过 Reactor 线程处理 I/O 事件的入口就是 NioEventLoop#processSelectedKey(SelectionKey, AbstractNioChannel) 方法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processSelectedKey</span><span class="token punctuation">(</span><span class="token class-name">SelectionKey</span> k<span class="token punctuation">,</span> <span class="token class-name">AbstractNioChannel</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">AbstractNioChannel<span class="token punctuation">.</span>NioUnsafe</span> unsafe <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// ...... 省略</span>

    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取 I/O 事件类型</span>
        <span class="token keyword">int</span> readyOps <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">readyOps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>readyOps <span class="token operator">&amp;</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_CONNECT</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> ops <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">interestOps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 删除OP_CONNECT，否则Selector.select(..)将始终返回而不阻塞</span>
            ops <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_CONNECT</span><span class="token punctuation">;</span>
            k<span class="token punctuation">.</span><span class="token function">interestOps</span><span class="token punctuation">(</span>ops<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 连接完成则调用finishiConnect操作</span>
            unsafe<span class="token punctuation">.</span><span class="token function">finishConnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>readyOps <span class="token operator">&amp;</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_WRITE</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 调用forceFlush，即使没有东西可写，它也会清除OP_WRITE</span>
            ch<span class="token punctuation">.</span><span class="token function">unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forceFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>readyOps <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_READ</span> <span class="token operator">|</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_ACCEPT</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> readyOps <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            unsafe<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CancelledKeyException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// key失效则close这个channel</span>
        unsafe<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">voidPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到处理 OP_WRITE 事件就是调用 <code>ch.unsafe().forceFlush()</code>，最终这个方法还是会调用到 NioSocketChannel#doWrite 方法，就是我们上面分析的写循环的方法。</p>`,215),v=[d];function m(b,f){return s(),a("div",null,v)}const w=n(k,[["render",m],["__file","18-Netty发送数据流程及出站缓冲区.html.vue"]]);export{w as default};
