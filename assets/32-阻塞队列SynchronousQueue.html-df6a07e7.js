import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,f as p}from"./app-cadb7c17.js";const t="/assets/46-SynchronousQueue非公平模式简要流程-644f309c.png",e="/assets/47-SynchronousQueue公平模式简要流程-2673d648.png",o={},c=p(`<table><thead><tr><th>版本</th><th>内容</th><th>时间</th></tr></thead><tbody><tr><td>V1</td><td>新建</td><td>2022年12月13日23:34:22</td></tr></tbody></table><h2 id="synchronousqueue-简介" tabindex="-1"><a class="header-anchor" href="#synchronousqueue-简介" aria-hidden="true">#</a> SynchronousQueue 简介</h2><p>SynchronousQueue 是一个特殊的阻塞队列，实现了 BlockingQueue 接口。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronousQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">implements</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...省略...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SynchronousQueue 的特点如下：</p><ol><li>SynchronousQueue 底层使用<strong>栈</strong>和<strong>双端队列</strong>来实现。</li><li>SynchronousQueue 支持<strong>公平模式和非公平模式</strong>。其中<strong>公平模式使用双端队列实现，非公平模式使用栈来实现</strong>。</li><li>SynchronousQueue <strong>内部不存储元素</strong>，<strong>入队和出队线程必须匹配才不会阻塞</strong>，没有匹配会一直阻塞直到有对应的线程来匹配。</li></ol><p>SynchronousQueue 基于 <code>dual stack and dual queue algorithms </code> 论文实现的。</p><p>http://www.cs.rochester.edu/u/scott/synchronization/pseudocode/duals.html</p><p>源码注释：</p><p>This class implements extensions of the dual stack and dual queue algorithms described in &quot;Nonblocking Concurrent Objects with Condition Synchronization&quot;, by W. N. Scherer III and M. L. Scott. 18th Annual Conf. on Distributed Computing, Oct. 2004 (see also http://www.cs.rochester.edu/u/scott/synchronization/pseudocode/duals.html). The (Lifo) stack is used for non-fair mode, and the (Fifo) queue for fair mode. The performance of the two is generally similar. Fifo usually supports higher throughput under contention but Lifo maintains higher thread locality in common applications.</p><h2 id="transferer-抽象类" tabindex="-1"><a class="header-anchor" href="#transferer-抽象类" aria-hidden="true">#</a> Transferer 抽象类</h2><p>SynchronousQueue 底层使用<strong>栈</strong>和<strong>双端队列</strong>来实现，栈和双端队列的实现类都必须继承这个抽象类。</p><p>其中</p><ul><li>栈是 TransferStack 类；</li><li>双端队列是 TransferQueue 类；</li></ul><p>下面看下 Transfer 接口定义的方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Transferer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">abstract</span> <span class="token class-name">E</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">,</span> <span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到就定义了 transfer 这一个方法。</p><p>既然是阻塞队列，那就包含的入队和出队的操作，在 SynchronousQueue 中 Transferer#transfer 方法既表示了入队操作也表示了出队操作。</p><p>入参：</p><ul><li><code>E e</code>：假如是入队操作，e 就表示要入队的数据。出队操作时 e 是 null，不传这个；</li><li><code>boolean timed</code>：表示当前入队或出队的操作是否支持超时；</li><li><code>long nanos</code>：假如支持超时，nanos 表示超时时间；</li></ul><p>返回值：</p><ul><li>返回值非空：假如当前表示的是入队操作，那么返回值就是当前入参 e 的值；</li><li>返回值非空：假如当前表示的是出队操作，那么返回值就是匹配到入队的数据值了；</li><li>返回值是 null：表示当前入队或出队操作超时了，或者线程被中断了。</li></ul><h2 id="synchronousqueue-属性和构造方法" tabindex="-1"><a class="header-anchor" href="#synchronousqueue-属性和构造方法" aria-hidden="true">#</a> SynchronousQueue 属性和构造方法</h2><p>transferer 属性</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Transferer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> transferer<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>构造方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">SynchronousQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token class-name">SynchronousQueue</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    transferer <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TransferQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">TransferStack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会根据入参创建不同的 Transferer 对象，具体实现由栈和双端队列，分别代表非公平模式和公平模式。</p><p><strong>默认是非公平的 TransferStack</strong>。</p><p>具体是怎么公平和非公平的，后面详细分析。</p><h2 id="synchronousqueue-非公平模式" tabindex="-1"><a class="header-anchor" href="#synchronousqueue-非公平模式" aria-hidden="true">#</a> SynchronousQueue 非公平模式</h2><p>SynchronousQueue 非公平模式使用的是栈这个数据结构，需要看 TransferStack 类的实现。</p><p><strong>为什么在这里栈是非公平模式的呢？</strong></p><p>因为每次相同模式的节点都是直接压栈，当来一个不同模式的节点时，此时会与栈顶元素匹配，这就是不公平了，栈顶元素是后到的，反而先匹配。</p><h3 id="transferstack-的节点模式" tabindex="-1"><a class="header-anchor" href="#transferstack-的节点模式" aria-hidden="true">#</a> TransferStack 的节点模式</h3><p>TransferStack 中定义了栈中节点的模式，主要就是 0，1，2。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">/* Modes for SNodes, ORed together in node fields */</span>
<span class="token doc-comment comment">/** Node represents an unfulfilled consumer */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">REQUEST</span>    <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 00 未配对的消费者</span>
<span class="token doc-comment comment">/** Node represents an unfulfilled producer */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DATA</span>       <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 01 未配对的生产者</span>
<span class="token doc-comment comment">/** Node is fulfilling another unfulfilled DATA or REQUEST */</span>
<span class="token comment">/*
 * 表示 Node 类型为匹配中的类型
 * 假设栈顶元素是 REQUEST-Node 类型，当前请求类型是 DATA 的话，入栈会修改类型为 FULFILLING
 * 假设栈顶元素是 DATA-Node 类型，当前请求类型是 REQUEST 的话，入栈会修改类型为 FULFILLING
 */</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">FULFILLING</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">// 10 配对成功的消费者/生产者</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>REQUEST 模式：表示尝试 take 元素的线程封装的节点，也就是消费者；</li><li>DATA 模式：表示尝试 put 元素的线程封装的节点，也就是生产者；</li><li>FULFILLING 模式：这时说明 take 和 put 的两个节点发生匹配了；</li></ul><h3 id="transferstack-snode-节点对象" tabindex="-1"><a class="header-anchor" href="#transferstack-snode-节点对象" aria-hidden="true">#</a> TransferStack.SNode 节点对象</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SNode</span> <span class="token punctuation">{</span>
    <span class="token keyword">volatile</span> <span class="token class-name">SNode</span> next<span class="token punctuation">;</span>        <span class="token comment">// next node in stack           栈中的指向下一个栈帧</span>
    <span class="token keyword">volatile</span> <span class="token class-name">SNode</span> match<span class="token punctuation">;</span>       <span class="token comment">// the node matched to this     与当前结点配对的结点</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Thread</span> waiter<span class="token punctuation">;</span>     <span class="token comment">// to control park/unpark      </span>
    <span class="token comment">// data 不是空的话表示当前是 DATA请求，入队</span>
    <span class="token comment">// data 是空的话表示当前是 REQUEST 请求，出队</span>
    <span class="token class-name">Object</span> item<span class="token punctuation">;</span>                <span class="token comment">// data; or null for REQUESTs   实际数据或null</span>
    <span class="token keyword">int</span> mode<span class="token punctuation">;</span>                   <span class="token comment">// 结点类型，DATA,REQUEST,FULFILLING</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>属性名</th><th>功能</th></tr></thead><tbody><tr><td><code>SNode next</code></td><td>执行栈中的下一个栈帧</td></tr><tr><td><code>SNode match</code></td><td>与当前节点匹配的节点</td></tr><tr><td><code>Thread waiter</code></td><td>假如节点入队后发现没有节点匹配，在尝试一段时间后假如还未匹配，<br>此时会挂起，并把线程引用赋值到 waiter</td></tr><tr><td><code>Object item</code></td><td>DATA 模式，就是存的数据；<br>REQUEST 模式是 null；TODO-KWOK 存疑</td></tr><tr><td><code>int mode</code></td><td>节点的模式，DATA、REQUEST、FULFILLING</td></tr></tbody></table><h3 id="核心方法-transferstack-transfer" tabindex="-1"><a class="header-anchor" href="#核心方法-transferstack-transfer" aria-hidden="true">#</a> 核心方法 TransferStack#transfer</h3><p>先看下入队 put 和出队 take 方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>transferer<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token class-name">E</span> e <span class="token operator">=</span> transferer<span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> e<span class="token punctuation">;</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到 put 和 take 方法都是调用的抽象方法 transfer，区别就是 put 方法传了数据，而 take 传的是 null。</p><p>接下来看核心方法 TransferStack#transfer 的分析。</p><p>先分析下大概的流程，整个 TransferStack#transfer 方法是在一个自旋中，尝试做下面三件事其中之一：</p><ol><li>如果栈是空的，或者已经有相同模式的节点，那么就将当前节点压栈，并等待对应模式的节点来匹配；</li><li>如果栈的节点与当前的节点的模式相反，此时会将当前节点设置为 FULFILLING 模式并压栈，与相应的节点进行匹配；</li><li>如果栈顶元素已经是 FULFILLING 模式的节点了，说明已经此时栈中已经有两个节点在匹配的操作中了，此时需要协助匹配或出栈操作；</li></ol><p>完整看下 TransferStack#transfer 的代码，后面依次分析。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">E</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">,</span> <span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">SNode</span> s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// constructed/reused as needed</span>
    <span class="token keyword">int</span> mode <span class="token operator">=</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">REQUEST</span> <span class="token operator">:</span> <span class="token constant">DATA</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SNode</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token comment">// CASE1: 栈为空 或 栈顶结点的模式与当前mode相同，都需要做入栈操作</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> h<span class="token punctuation">.</span>mode <span class="token operator">==</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// empty or same-mode</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// can&#39;t wait</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span><span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// pop cancelled node</span>
                <span class="token keyword">else</span>
                    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> s <span class="token operator">=</span> <span class="token function">snode</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> e<span class="token punctuation">,</span> h<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">SNode</span> m <span class="token operator">=</span> <span class="token function">awaitFulfill</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> timed<span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment">// wait was cancelled</span>
                    <span class="token function">clean</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>next <span class="token operator">==</span> s<span class="token punctuation">)</span>
                    <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> s<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// help s&#39;s fulfiller</span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mode <span class="token operator">==</span> <span class="token constant">REQUEST</span><span class="token punctuation">)</span> <span class="token operator">?</span> m<span class="token punctuation">.</span>item <span class="token operator">:</span> s<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// CASE2: 前置条件，栈顶结点的模式与当前mode不相同，栈顶结点还未配对成功</span>
        <span class="token comment">// 条件：栈顶元素的模式不是 FULFILLING，进入该分支去匹配</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isFulfilling</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// try to fulfill</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>h<span class="token punctuation">.</span><span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment">// already cancelled</span>
                <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// pop and retry</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token function">snode</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> e<span class="token punctuation">,</span> h<span class="token punctuation">,</span> <span class="token constant">FULFILLING</span><span class="token operator">|</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// loop until matched or waiters disappear</span>
                    <span class="token class-name">SNode</span> m <span class="token operator">=</span> s<span class="token punctuation">.</span>next<span class="token punctuation">;</span>       <span class="token comment">// m is s&#39;s match</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// all waiters are gone</span>
                        <span class="token comment">// 将整个栈清空，因为 s.next 都是 null 了，只有 s 一个节点</span>
                        <span class="token function">casHead</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// pop fulfill node</span>
                        s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>           <span class="token comment">// use new node next time</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>              <span class="token comment">// restart main loop</span>
                    <span class="token punctuation">}</span>
                    <span class="token class-name">SNode</span> mn <span class="token operator">=</span> m<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">tryMatch</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">casHead</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> mn<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// pop both s and m</span>
                        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mode <span class="token operator">==</span> <span class="token constant">REQUEST</span><span class="token punctuation">)</span> <span class="token operator">?</span> m<span class="token punctuation">.</span>item <span class="token operator">:</span> s<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span>                  <span class="token comment">// lost match</span>
                        s<span class="token punctuation">.</span><span class="token function">casNext</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> mn<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// help unlink</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// CASE3：栈顶模式是 FULFILLING，表示栈顶和栈顶的 next 节点正在匹配</span>
        <span class="token comment">// 当前请求需要做协助工作</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token comment">// help a fulfiller</span>
            <span class="token class-name">SNode</span> m <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">;</span>               <span class="token comment">// m is h&#39;s match</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                  <span class="token comment">// waiter is gone</span>
                <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// pop fulfilling node</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token class-name">SNode</span> mn <span class="token operator">=</span> m<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">tryMatch</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment">// help match</span>
                    <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> mn<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// pop both h and m</span>
                <span class="token keyword">else</span>                        <span class="token comment">// lost match</span>
                    h<span class="token punctuation">.</span><span class="token function">casNext</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> mn<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// help unlink</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第（1）步</strong>，判断当前 TransferStack#transfer 操作的模式，DATA 模式是会传数据进来的。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">SNode</span> s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// constructed/reused as needed</span>
<span class="token keyword">int</span> mode <span class="token operator">=</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">REQUEST</span> <span class="token operator">:</span> <span class="token constant">DATA</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>后面就开始自旋针对三种不同的情况做操作了。</p><p><strong>第（2）步</strong>，开始自旋。</p><p><strong>自旋 CASE1</strong>：栈中没有元素，或者栈顶元素与当前模式相同。此时需要进行入栈操作。</p><p>这里会判断是否支持超时的情况。假如不支持超时或者未超时，这时需要将创建一个节点并将其压栈。假如压栈成功，就会调用 TransferStack#awaitFulfill 方法等待匹配的节点，该方法返回值有两种：①<strong>匹配到相反模式的节点了；②出现中断或者超时取消了</strong>。</p><p>假如节点取消了，就需要将节点从栈中移除。假如匹配到节点了就需要将当前节点和匹配到的节点一起出栈。</p><p>最后根据当前模式返回数据。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">SNode</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token comment">// CASE1: 栈为空 或 栈顶结点的模式与当前mode相同，都需要做入栈操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> h<span class="token punctuation">.</span>mode <span class="token operator">==</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// empty or same-mode</span>
        <span class="token comment">// case1.1: timed 成立表示当前是支持超时的，nanos &lt;= 0 表示已经等待超时了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// can&#39;t wait</span>
            <span class="token comment">// 条件成立表示栈顶元素是取消状态，需要弹出取消状态的节点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span><span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// pop cancelled node</span>
            <span class="token keyword">else</span>
                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// case1.2 前置条件是栈顶元素是 null 或者当前模式与栈顶元素模式一样</span>
        <span class="token comment">// 且 timed 是 false 或者支持超时但是超时时间未到</span>
        <span class="token comment">// 这里将 s 压栈</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> s <span class="token operator">=</span> <span class="token function">snode</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> e<span class="token punctuation">,</span> h<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 走到这里说明入栈成功， 阻塞当前调用线程，等待被匹配</span>
            <span class="token class-name">SNode</span> m <span class="token operator">=</span> <span class="token function">awaitFulfill</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> timed<span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 1. 正常情况是匹配到值了，就是匹配到的节点</span>
            <span class="token comment">// 2. 异常情况就是被取消了，match 是 this，指向当前节点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment">// wait was cancelled</span>
                <span class="token comment">// 将取消的节点移除栈，直接移除，并不是 pop</span>
                <span class="token function">clean</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 此时m为配对结点</span>
            <span class="token comment">// (h = head) != null 表示栈顶不为 null</span>
            <span class="token comment">// h.next == s 说明栈顶的下一个元素是当前线程封装的节点 s，说明匹配的两个节点还未出栈</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>next <span class="token operator">==</span> s<span class="token punctuation">)</span>
                <span class="token comment">// 出栈匹配的 两个节点</span>
                <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> s<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// help s&#39;s fulfiller</span>
            <span class="token comment">// 入队DATA线程就是  提交的值, 出队线程返回配对结点的值</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mode <span class="token operator">==</span> <span class="token constant">REQUEST</span><span class="token punctuation">)</span> <span class="token operator">?</span> m<span class="token punctuation">.</span>item <span class="token operator">:</span> s<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 执行到此处说明入栈失败(多个线程同时入栈导致CAS操作head失败),则进入下一次自旋继续执行</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">// 省略其他 CASE.........</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>自旋 CASE2</strong>：前置条件是<strong>栈顶元素的模式和当前的模式不同</strong>。这里 TransferStack#isFulfilling 判断栈顶节点是否是正在匹配中的状态。进入该 CASE 说明<strong>栈顶元素还未开始做匹配操作</strong>，需要进入该 CASE 处理。</p><p>首先会判断栈顶节点是否已经取消了，假如取消了就移除该节点，并设置新的栈顶，继续自旋判断；</p><p>否则尝试压栈一个 SNode 节点，该节点特殊的是 mode 属性是<code>FULFILLING|mode</code>。压栈成功后会开启一个自旋，会自旋直到节点匹配成功或者等待的线程不存在了。</p><p>调用 TransferStack.SNode#tryMatch 方法尝试匹配节点，在改方法中会尝试唤醒阻塞的线程。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">boolean</span> <span class="token function">tryMatch</span><span class="token punctuation">(</span><span class="token class-name">SNode</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// match == null 说明当前 Node 还未匹配，然后 CAS 尝试将 match 设置为 s</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>match <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
        <span class="token constant">UNSAFE</span><span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> matchOffset<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当前 NOde 如果自旋结束后，会调用 park 方法挂起，挂起之前会将挂起的线程存到 waiter 字段里</span>
        <span class="token class-name">Thread</span> w <span class="token operator">=</span> waiter<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// waiters need at most one unpark</span>
            waiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token comment">// 唤醒</span>
            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> match <span class="token operator">==</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如匹配节点成功后，就将匹配成功的这两个节点出栈，最后返回值。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// CASE2: 前置条件，栈顶结点的模式与当前mode不相同，栈顶结点还未配对成功</span>
<span class="token comment">// 条件：栈顶元素的模式不是 FULFILLING，进入该分支去匹配</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isFulfilling</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// try to fulfill</span>
    <span class="token comment">// case2.1: 元素取消情况（因中断或超时）的处理</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>h<span class="token punctuation">.</span><span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment">// already cancelled</span>
        <span class="token comment">// 移除取消节点</span>
        <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// pop and retry</span>
    <span class="token comment">// case2.2: 将当前结点压入栈中，将当前节点的 mode 改为 FULFILLING|mode</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token function">snode</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> e<span class="token punctuation">,</span> h<span class="token punctuation">,</span> <span class="token constant">FULFILLING</span><span class="token operator">|</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 自旋直到匹配成功或者 waiter 没了</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// loop until matched or waiters disappear</span>
            <span class="token class-name">SNode</span> m <span class="token operator">=</span> s<span class="token punctuation">.</span>next<span class="token punctuation">;</span>       <span class="token comment">// m is s&#39;s match</span>
            <span class="token comment">// m == null 什么时候成立？</span>
            <span class="token comment">// 当 s.next 节点超时或者外部线程中断唤醒后，会执行 clean 操作将自己清理出站</span>
            <span class="token comment">// 此时站在匹配者线程来看，s.next 是有可能是 null 的</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// all waiters are gone</span>
                <span class="token comment">// 将整个栈清空，因为 s.next 都是 null 了，只有 s 一个节点</span>
                <span class="token function">casHead</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// pop fulfill node</span>
                s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>           <span class="token comment">// use new node next time</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>              <span class="token comment">// restart main loop</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">SNode</span> mn <span class="token operator">=</span> m<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">tryMatch</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 假如匹配成功，就将 m 和 s 一起弹出栈，将 mn 设置为新的栈顶</span>
                <span class="token function">casHead</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> mn<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// pop both s and m</span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mode <span class="token operator">==</span> <span class="token constant">REQUEST</span><span class="token punctuation">)</span> <span class="token operator">?</span> m<span class="token punctuation">.</span>item <span class="token operator">:</span> s<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span>                  <span class="token comment">// lost match</span>
                <span class="token comment">// 假如匹配失败，说明 m 可能出现了超时了等情况，帮助将 m 移出栈</span>
                s<span class="token punctuation">.</span><span class="token function">casNext</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> mn<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// help unlink</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>自旋CASE3</strong>：这个 CASE 表示栈顶元素是 FULFILLING 模式，进入这个 CASE 协助匹配节点。代码和 CASE2 一样，只是没有返回值。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// CASE3：栈顶模式是 FULFILLING，表示栈顶和栈顶的 next 节点正在匹配</span>
<span class="token comment">// 当前请求需要做协助工作</span>
<span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token comment">// help a fulfiller</span>
    <span class="token class-name">SNode</span> m <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">;</span>               <span class="token comment">// m is h&#39;s match</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                  <span class="token comment">// waiter is gone</span>
        <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// pop fulfilling node</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token class-name">SNode</span> mn <span class="token operator">=</span> m<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">tryMatch</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment">// help match</span>
            <span class="token comment">// 假如匹配成功，就将 m 和 s 一起弹出栈，将 mn 设置为新的栈顶</span>
            <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> mn<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// pop both h and m</span>
        <span class="token keyword">else</span>                        <span class="token comment">// lost match</span>
            <span class="token comment">// 假如匹配失败，说明 m 可能出现了超时了等情况，帮助将 m 移出栈</span>
            h<span class="token punctuation">.</span><span class="token function">casNext</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> mn<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// help unlink</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="核心方法-transferstack-awaitfulfill" tabindex="-1"><a class="header-anchor" href="#核心方法-transferstack-awaitfulfill" aria-hidden="true">#</a> 核心方法 TransferStack#awaitFulfill</h3><p>这个方法主要在上一节的 CASE1 中因为栈中的元素的模式都相同，此时需要压栈等待匹配。那么等待就是调用改的 TransferStack#awaitFulfill 这个方法。</p><p>这个方法的思路很明显，就是在实际阻塞线程前需要自旋一段时间等待匹配，因为阻塞线程的代价比短暂的自旋代价要大。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">SNode</span> <span class="token function">awaitFulfill</span><span class="token punctuation">(</span><span class="token class-name">SNode</span> s<span class="token punctuation">,</span> <span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> timed <span class="token operator">?</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanos <span class="token operator">:</span> <span class="token number">0L</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> w <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 当前请求线程在下面的 for 自旋中的自旋次数，自选次数后还未匹配成功则 park 线程</span>
    <span class="token keyword">int</span> spins <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">shouldSpin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">?</span>
                 <span class="token punctuation">(</span>timed <span class="token operator">?</span> maxTimedSpins <span class="token operator">:</span> maxUntimedSpins<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 自旋检查逻辑 1.是否超时 2.是否中断 3.是否匹配成功</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment">// 收到中断信息，取消</span>
            s<span class="token punctuation">.</span><span class="token function">tryCancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// s.match 两种情况</span>
        <span class="token comment">// 1. 正常情况是匹配到值了，就是匹配到的节点</span>
        <span class="token comment">// 2. 异常情况就是被取消了，match 是 this，指向当前节点</span>
        <span class="token class-name">SNode</span> m <span class="token operator">=</span> s<span class="token punctuation">.</span>match<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token comment">// 匹配到值了，获取取消了，直接返回</span>
            <span class="token keyword">return</span> m<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>timed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            nanos <span class="token operator">=</span> deadline <span class="token operator">-</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 超时了，取消</span>
                s<span class="token punctuation">.</span><span class="token function">tryCancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 继续循环，会在上面返回 return</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>spins <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token comment">// 自旋次数-1</span>
            spins <span class="token operator">=</span> <span class="token function">shouldSpin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>spins<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">// 说明自旋次数完了，保存当前线程对象到 waiter 中</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>waiter <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            s<span class="token punctuation">.</span>waiter <span class="token operator">=</span> w<span class="token punctuation">;</span> <span class="token comment">// establish waiter so can park next iter</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timed<span class="token punctuation">)</span>
            <span class="token comment">// 无限挂起，等待唤醒</span>
            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&gt;</span> spinForTimeoutThreshold<span class="token punctuation">)</span>
            <span class="token comment">// 超时挂起</span>
            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="非公平模式图解" tabindex="-1"><a class="header-anchor" href="#非公平模式图解" aria-hidden="true">#</a> 非公平模式图解</h3><p>假设一个流程：</p><ol><li>线程 A put 一个元素；</li><li>线程 B put 一个元素；</li><li>线程 C put 一个元素；</li><li>线程 D take 一个元素；</li></ol><p><img src="`+t+'" alt="46-SynchronousQueue非公平模式简要流程"></p><h2 id="synchronousqueue-公平模式" tabindex="-1"><a class="header-anchor" href="#synchronousqueue-公平模式" aria-hidden="true">#</a> SynchronousQueue 公平模式</h2><p>SynchronousQueue 公平模式是使用双端队列实现的。</p><p>前面的非公平模式使用栈，当栈顶遇到不同模式的节点后，此时会与栈顶元素匹配，不公平。</p><p>这里使用双端队列的公平性体现在，当栈顶遇到不同模式的节点时，会与双端队列的队首元素匹配。</p><p>SynchronousQueue 公平模式的实现可以自己去看，这里就做一个简单的图解。</p><h3 id="公平模式图解" tabindex="-1"><a class="header-anchor" href="#公平模式图解" aria-hidden="true">#</a> 公平模式图解</h3><p><img src="'+e+'" alt="47-SynchronousQueue公平模式简要流程"></p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>无</p>',85),l=[c];function i(u,k){return s(),a("div",null,l)}const m=n(o,[["render",i],["__file","32-阻塞队列SynchronousQueue.html.vue"]]);export{m as default};
